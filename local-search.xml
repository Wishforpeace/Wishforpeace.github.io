<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>3.8 集线器与交换机的区别</title>
    <link href="/2023/04/02/3-8-%E9%9B%86%E7%BA%BF%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/04/02/3-8-%E9%9B%86%E7%BA%BF%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="3-8-集线器与交换机的区别"><a href="#3-8-集线器与交换机的区别" class="headerlink" title="3.8 集线器与交换机的区别"></a>3.8 集线器与交换机的区别</h1><h2 id="早期的总线型以太网"><a href="#早期的总线型以太网" class="headerlink" title="早期的总线型以太网"></a>早期的总线型以太网</h2><p>采用细同轴电缆（淘汰）</p><p><img src="/Users/wuyuxian/Library/Application%20Support/typora-user-images/image-20230402084859321.png" alt="image-20230402084859321"></p><h2 id="使用双绞线和集线器HUB的星型以太网"><a href="#使用双绞线和集线器HUB的星型以太网" class="headerlink" title="使用双绞线和集线器HUB的星型以太网"></a>使用双绞线和集线器HUB的星型以太网</h2><p><img src="/Users/wuyuxian/Library/Application%20Support/typora-user-images/image-20230402085012721.png" alt="image-20230402085012721" style="zoom:33%;" /></p><ul><li>使用集线器的以太网在逻辑上仍是一个<strong>总线网</strong>，各站共享总线资源，使用的还是<strong>CSMA/CD协议</strong></li><li>集线器只工作在<strong>物理层</strong>，它的每个接口仅简单地进行转发比特，不进行碰撞检测（由各站的网卡检测）</li><li>集线器有少量的<strong>容错能力和管理功能</strong>（检测故障网卡，切断连线）</li></ul><h2 id="使用集线器HUB在物理层拓展以太网"><a href="#使用集线器HUB在物理层拓展以太网" class="headerlink" title="使用集线器HUB在物理层拓展以太网"></a>使用集线器HUB在物理层拓展以太网</h2><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230402085605182.png" alt="image-20230402085605182"></p><p>原来的三个碰撞域合并成一个更大的碰撞域</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230402085729684.png" alt="image-20230402085729684"></p><h2 id="以太网交换机"><a href="#以太网交换机" class="headerlink" title="以太网交换机"></a>以太网交换机</h2><p> <img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230402085855435.png" alt="image-20230402085855435"></p><p>交换机会把单播帧发送给目的主机，而不是其他的主机</p><p>此处忽略了ARP过程，假设交换机的帧交换表已经学习好了</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230402090857195.png" alt="image-20230402090857195"></p><ul><li>以太网交换机通常有<strong>多个接口</strong>，每个接口可直接与一台主机或另一个以太网交换机相连。一般都在<strong>全双工方式</strong>下工作。</li><li>以太网交换机具有并行性，能<strong>同时连通多对接口</strong>，使多对主机能同时通信，<strong>无碰撞（不适用CSMA/CD协议）</strong></li><li>以太网交换机一般有<strong>多种速率</strong>的接口</li><li>以太网交换机<strong>工作在数据链路层</strong>（也包括物理层），它收到帧后，在帧交换表中查找<strong>帧的目的MAC地址所对应的接口号</strong>，然后通过该接口转发帧</li><li>以太网交换机即插即用，内部的帧交换表通过<strong>自学习算法</strong>建立</li><li>帧的两种转发方式<ul><li>存储转发</li><li>直通交换：基于硬件的交叉矩阵</li></ul></li></ul><h2 id="对比集线器和交换机"><a href="#对比集线器和交换机" class="headerlink" title="对比集线器和交换机"></a>对比集线器和交换机</h2><h3 id="单播帧"><a href="#单播帧" class="headerlink" title="单播帧"></a>单播帧</h3><p> <img src="/Users/wuyuxian/Library/Application%20Support/typora-user-images/image-20230402093551158.png" alt="image-20230402093551158" style="zoom: 33%;" /></p><h3 id="广播帧"><a href="#广播帧" class="headerlink" title="广播帧"></a>广播帧</h3><p>两者没有区别</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230402093646478.png" alt="image-20230402093646478"></p><h3 id="多台主机发送单播帧"><a href="#多台主机发送单播帧" class="headerlink" title="多台主机发送单播帧"></a>多台主机发送单播帧</h3><p>产生碰撞，传播到总线的各个主机上</p><p><img src="/Users/wuyuxian/Library/Application%20Support/typora-user-images/image-20230402093845615.png" alt="image-20230402093845615" style="zoom:33%;" /></p><p>对于使用交换机的交换式以太网，交换机收到多个帧后，会将其缓存起来，逐个发送个目的主机，不产生碰撞</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230402094028326.png" alt="image-20230402094028326" style="zoom:33%;" /></p><h3 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h3><h4 id="单播帧-1"><a href="#单播帧-1" class="headerlink" title="单播帧"></a>单播帧</h4><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230402094151071.png" alt="image-20230402094151071"></p><h4 id="广播帧-1"><a href="#广播帧-1" class="headerlink" title="广播帧"></a>广播帧</h4><p>效果上是相同的，同属于一个广播域</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230402094222456.png" alt="image-20230402094222456"></p><h4 id="竞争总线产生碰撞"><a href="#竞争总线产生碰撞" class="headerlink" title="竞争总线产生碰撞"></a>竞争总线产生碰撞</h4><p>集线器发生碰撞，而交换机没有</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230402094347363.png" alt="image-20230402094347363"></p><p>总结：</p><ul><li>集线器和交换机都能够扩大广播域</li><li>但是集线器也扩大了碰撞域，而交换机隔离了碰撞域</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3.7 MAC地址、IP地址、ARP协议</title>
    <link href="/2023/03/31/3-7-MAC%E5%9C%B0%E5%9D%80%E3%80%81IP%E5%9C%B0%E5%9D%80%E3%80%81ARP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2023/03/31/3-7-MAC%E5%9C%B0%E5%9D%80%E3%80%81IP%E5%9C%B0%E5%9D%80%E3%80%81ARP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="3-7-MAC地址、IP地址、ARP协议"><a href="#3-7-MAC地址、IP地址、ARP协议" class="headerlink" title="3.7 MAC地址、IP地址、ARP协议"></a>3.7 MAC地址、IP地址、ARP协议</h1><ul><li>MAC地址：MAC子层。     数据链路层</li><li>IP地址：TCP\IP 体系结构中网际层使用的地址。    网际层</li><li>ARP协议属于TCP\IP体系结构的网际层，通过IP地址获取MAC地址。    网际层</li></ul><h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><ul><li>广播信道，每个主机都要有唯一标识，即数据链路层地址</li><li>MAC（Media Access Control）媒体接入控制，携带标识<strong>发送主机和接收主机的地址</strong></li><li>MAC地址有时被称为<strong>物理地址</strong>，但是不属于物理层</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230331203101830.png" alt="image-20230331203101830"></p><ul><li>主机包含两个网络适配器：有限局域网适配器、无线局域网适配器</li><li>MAC地址是对网络上<strong>各接口的唯一标识</strong>，而不是对网络上各个设备的唯一标识</li></ul><h3 id="IEEE-802局域网的MAC地址格式"><a href="#IEEE-802局域网的MAC地址格式" class="headerlink" title="IEEE 802局域网的MAC地址格式"></a>IEEE 802局域网的MAC地址格式</h3><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230331203649205.png" alt="image-20230331203649205"></p><p><strong>字节发送顺序</strong>：第一字节 ——————&gt; 第六子节</p><p><strong>字节内的比特发送顺序</strong>：b0——————&gt;b7</p><h3 id="单播MAC地址"><a href="#单播MAC地址" class="headerlink" title="单播MAC地址"></a>单播MAC地址</h3><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230402084444065.png" alt="image-20230402084444065"></p><h3 id="广播MAC地址"><a href="#广播MAC地址" class="headerlink" title="广播MAC地址"></a>广播MAC地址</h3><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230331204259276.png" alt="image-20230331204259276"></p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230331204425519.png" alt="image-20230331204425519"></p><h3 id="多播MAC地址"><a href="#多播MAC地址" class="headerlink" title="多播MAC地址"></a>多播MAC地址</h3><p>最后一位不能被2整除，就是多播地址</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230331204701214.png" alt="image-20230331204701214"></p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230331204803016.png" alt="image-20230331204803016"></p><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP地址：因特网上的主机和路由器所使用的地址，用于标识两部分信息</p><ul><li>网络编号：标识因特网上数以百万计的网络</li><li>主机编号：标识同一网络上不同主机（或路由器各接口）</li></ul><p>不接入网络，可只使用MAC地址，但是如果要接入因特网，必须同时使用IP地址和MAC地址</p><h3 id="网络体系结构看IP地址和MAC地址"><a href="#网络体系结构看IP地址和MAC地址" class="headerlink" title="网络体系结构看IP地址和MAC地址"></a>网络体系结构看IP地址和MAC地址</h3><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230331205608085.png" alt="image-20230331205608085"></p><h3 id="数据包转发过程中IP地址与MAC地址的变化情况"><a href="#数据包转发过程中IP地址与MAC地址的变化情况" class="headerlink" title="数据包转发过程中IP地址与MAC地址的变化情况"></a>数据包转发过程中IP地址与MAC地址的变化情况</h3><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230401195823510.png" alt="image-20230401195823510"></p><ul><li>数据包转发过程中源IP地址和目的IP地址<strong>保持不变</strong></li><li>数据包转发过程中源MAC地址和目的MAC地址<strong>逐个链路（或逐个网络）改变</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230401200854545.png" alt="image-20230401200854545"></p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>主机B已知主机C的IP地址，但是不知道其MAC地址，所以需要发送广播请求，获取到主机C的MAC地址</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230401201331790.png" alt="image-20230401201331790"></p><p>广播到了A和C，分别交付给上层处理，并获取响应</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230401201418429.png" alt="image-20230401201418429"></p><p>C确认请求报文后，发送ARP响应报文（单播）</p><p>传送给其他主机，主机交由上层处理</p><p>主机B将主机C的MAC地址记录到自己的ARP高速缓存表中</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230402083243219.png" alt="image-20230402083243219"></p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230402083514715.png" alt="image-20230402083514715" style="zoom:50%;" /></p><ul><li>动态：自动获取，生命周期默认为两分钟</li><li>静态：手工设置，不同操作系统下的生命周期不同，例如系统重启后不存在或系统重启后依然有效</li></ul><p><strong>注意</strong>⚠️：</p><ul><li>ARP协议只能在一段网络内使用，不能够跨网络</li><li>跨网络，ARP协议是逐段链路使用的</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230402083826110.png" alt="image-20230402083826110"></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GCC编译器</title>
    <link href="/2023/03/31/GCC%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    <url>/2023/03/31/GCC%E7%BC%96%E8%AF%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="GCC编译器"><a href="#GCC编译器" class="headerlink" title="GCC编译器"></a>GCC编译器</h1><h2 id="1-GCC编译器的使用"><a href="#1-GCC编译器的使用" class="headerlink" title="1.GCC编译器的使用"></a>1.GCC编译器的使用</h2><p>GNU CC</p><p>查看版本:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -v<br></code></pre></td></tr></table></figure><p>查看所在路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">which gcc<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>针对2023mini project和团队经营现状想到的一点问题</title>
    <link href="/2023/03/19/%E9%92%88%E5%AF%B92023mini-project%E5%92%8C%E5%9B%A2%E9%98%9F%E7%BB%8F%E8%90%A5%E7%8E%B0%E7%8A%B6%E6%83%B3%E5%88%B0%E7%9A%84%E4%B8%80%E7%82%B9%E9%97%AE%E9%A2%98/"/>
    <url>/2023/03/19/%E9%92%88%E5%AF%B92023mini-project%E5%92%8C%E5%9B%A2%E9%98%9F%E7%BB%8F%E8%90%A5%E7%8E%B0%E7%8A%B6%E6%83%B3%E5%88%B0%E7%9A%84%E4%B8%80%E7%82%B9%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="针对2023mini-project和团队经营现状想到的一点问题"><a href="#针对2023mini-project和团队经营现状想到的一点问题" class="headerlink" title="针对2023mini project和团队经营现状想到的一点问题"></a>针对2023mini project和团队经营现状想到的一点问题</h1><h2 id="mini-project"><a href="#mini-project" class="headerlink" title="mini project"></a>mini project</h2><p>mini project是团队的传统，已经有了很多年的历史，个人认为这是提升新人水平的一次关键性的项目，是觉得绝大部分同学第一次开发实战，理论上应该是一个很良好的开端，并且为之后个人的发展奠定较为不错的基础，但是目前来看，近年来团队的mini project的效果反馈并不理想，个人认为有以下几点表现：</p><h3 id="1-各组协调工作能力有待提高"><a href="#1-各组协调工作能力有待提高" class="headerlink" title="1.各组协调工作能力有待提高"></a>1.各组协调工作能力有待提高</h3><p>​        mini project是大家第一次真正意义上的组间合作，是从产品想法提出，到最后项目落地的完整过程，并不是简简单单的前后端合作。所以，产品、设计、前端（安卓）、后端在一个项目上都应该平等交流，但是限于产品的甲方身份，产品不仅有义务去提升大家工作的激情，更需要做到的应该是一个协调工作。将本不熟悉的一群人组合到一起，做成一件事，这并不是简单的任务分发安排，这里其实更多是管理能力的提升。</p><p>​        我觉得一直以来产品组的定位有一些局限，产品组不应该仅仅是从想法池中捞出想法，然后商议讨论确定方案，就选取各组人员进行工作。虽然木犀的结构是参照于互联网企业，但是我们不同于真正意义上的公司，参与开发的技术组和产品组之间不存在任何因为工作性质上的牵连，我们的状态应该也必须是一群志同道合的人做着大家喜欢的事情，为了共同的目标而努力。同样，这就会造成两种结果，如果进展顺利，大家的热情会愈发高涨，因为成就感会带来一系列的正向反馈；如果因为技术组参与热情度不足，很可能会出现项目搁置的结果。</p><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>随记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3.5 TensorFlow</title>
    <link href="/2023/03/14/3-5-TensorFlow/"/>
    <url>/2023/03/14/3-5-TensorFlow/</url>
    
    <content type="html"><![CDATA[<h1 id="3-5-TensorFlow"><a href="#3-5-TensorFlow" class="headerlink" title="3.5 TensorFlow"></a>3.5 TensorFlow</h1><ul><li>低阶张量</li></ul>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>09 时间函数：时间类数据，MySQL是怎么处理的？</title>
    <link href="/2023/03/13/09-%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0%EF%BC%9A%E6%97%B6%E9%97%B4%E7%B1%BB%E6%95%B0%E6%8D%AE%EF%BC%8CMySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E7%9A%84%EF%BC%9F/"/>
    <url>/2023/03/13/09-%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0%EF%BC%9A%E6%97%B6%E9%97%B4%E7%B1%BB%E6%95%B0%E6%8D%AE%EF%BC%8CMySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E7%9A%84%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="09-时间函数：时间类数据，MySQL是怎么处理的？"><a href="#09-时间函数：时间类数据，MySQL是怎么处理的？" class="headerlink" title="09-时间函数：时间类数据，MySQL是怎么处理的？"></a>09-时间函数：时间类数据，MySQL是怎么处理的？</h1><h2 id="获取日期时间数据中部分信息的函数"><a href="#获取日期时间数据中部分信息的函数" class="headerlink" title="获取日期时间数据中部分信息的函数"></a><strong>获取日期时间数据中部分信息的函数</strong></h2><p>超市经营者希望通过实际的销售数据，了解到一天当中什么时间段卖得好，什么时间段卖的不好，以此根据不同时间的销售情况，合理安排商品陈列和人员促销，以实现收益最大化。</p><p>销售单头表 demo.transactionhead</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230314132003689.png" alt="销售单头表 demo.transactionhead" style="zoom:50%;" /></p><p>销售单明细表 demo.transactiondetails</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230314132838193.png" alt="销售单明细表 demo.transactiondetails" style="zoom:50%;" /></p><p>商品信息表 demo.goodsmaster</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230314132904407.png" alt="商品信息表 demo.goodsmaster" style="zoom:50%;" /></p><p>销售单明细表通过流水编号与销售单头表关联，其中流水编号是外键。</p><p>首先分析一下“统计一天中每小时的销售数量和销售金额”</p><p>统计一天中每小时的销售情况，先把销售数据按照小时进行分组统计。</p><p>解决问题的关键是把交易时间的小时部分提取出来。使用EXTRACT()和HOUR()函数。</p><p><code>EXTRACT(type FROM date)</code>表示从日期时间date中抽取type指定部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT <br>EXTRACT(HOUR FROM b.transdate) AS 时段,<br>SUM(a.quantity) AS 数量,<br>SUM(a.salesvalue) AS 金额<br>FROM <br>demo.transactiondetails a<br>JOIN <br>demo.transactionhead b ON (a.transactionid = b.transactionid)<br>GROUP BY EXTRACT(HOUR FROM b.transdate)<br>ORDER BY EXTRACT(HOUR FROM b.transdate);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230321133159958.png" alt="image-20230321133159958"></p><p>查询过程：</p><ul><li>先从交易时间中抽取出小时信息</li><li>按照交易时间进行分组</li><li>按照分组来统计数量和金额</li><li>按照时间进行排序</li></ul><p>使用HOUR()函数直接提取时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT <br>HOUR(b.transdate) AS 时段,<br>SUM(a.quantity) AS 数量,<br>SUM(a.salesvalue) AS 金额<br>FROM<br>demo.transactiondetails a<br>JOIN <br>demo.transactionhead b ON (a.transactionid = b.transactionid)<br>GROUP BY HOUR(b.transdate)<br>ORDER BY HOUR(b.transdate);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230321134013491.png" alt="image-20230321134013491"></p><p>支持的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">YEAR（date）：获取 date 中的年。<br>MONTH（date）：获取 date 中的月。<br>DAY（date）：获取 date 中的日。<br>HOUR（date）：获取 date 中的小时。<br>MINUTE（date）：获取 date 中的分。<br>SECOND（date）：获取 date 中的秒。<br></code></pre></td></tr></table></figure><h2 id="计算日期时间的函数"><a href="#计算日期时间的函数" class="headerlink" title="计算日期时间的函数"></a>计算日期时间的函数</h2><ul><li>DATE_ADD(date,INTERVAL表达式type):</li><li>LAST_DAY(date):</li></ul><p>第一步：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DATE_ADD(&#x27;2020-12-10&#x27;,INTERVAL -1 YEAR);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230321135506213.png" alt="image-20230321135506213"></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2.5 回顾第一个例子</title>
    <link href="/2023/03/13/2-5-%E5%9B%9E%E9%A1%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90/"/>
    <url>/2023/03/13/2-5-%E5%9B%9E%E9%A1%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h1 id="2-5-回顾第一个例子"><a href="#2-5-回顾第一个例子" class="headerlink" title="2.5 回顾第一个例子"></a>2.5 回顾第一个例子</h1><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230313165310408.png" alt="神经网络、层、损失函数与优化器之间的关系" style="zoom:50%;"></p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2.4　神经网络的“引擎”：基于梯度的优化</title>
    <link href="/2023/03/05/2-4-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E2%80%9C%E5%BC%95%E6%93%8E%E2%80%9D%EF%BC%9A%E5%9F%BA%E4%BA%8E%E6%A2%AF%E5%BA%A6%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <url>/2023/03/05/2-4-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E2%80%9C%E5%BC%95%E6%93%8E%E2%80%9D%EF%BC%9A%E5%9F%BA%E4%BA%8E%E6%A2%AF%E5%BA%A6%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="2-4-神经网络的“引擎”：基于梯度的优化"><a href="#2-4-神经网络的“引擎”：基于梯度的优化" class="headerlink" title="2-4 神经网络的“引擎”：基于梯度的优化"></a>2-4 神经网络的“引擎”：基于梯度的优化</h1><p>随机初始化：选择权重较小的矩阵进行运算。</p><p>训练：逐步调节</p><p><strong>训练循环</strong>：</p><ul><li>抽取训练样本x和对应目标y_true组成的一个数据批量</li><li>在x上运行模型，得到y_pred（向前传播）</li><li>计算损失值，用于衡量y_pred和y_true之间的差距</li><li>更新模型的所有权重，以略微减小模型在这批数据上的损失值。</li></ul><h2 id="2-4-1-导数"><a href="#2-4-1-导数" class="headerlink" title="2.4.1 导数"></a>2.4.1 导数</h2><script type="math/tex; mode=display">f(x) = y</script><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230305213325111.png" alt="image-20230305213325111"></p><p>函数是连续的，x增加很小的epsilon,y也发生微小变化。</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230305213445742.png" alt="image-20230305213445742"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">f(x + epsilon_x) = y + a * epsilon_x<br></code></pre></td></tr></table></figure><p>x足够接近p时，近似认为是斜率</p><p>斜率a时f在p点的导数</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230305213623201.png" alt="image-20230305213623201"></p><h2 id="2-4-2-张量运算的导数：梯度"><a href="#2-4-2-张量运算的导数：梯度" class="headerlink" title="2.4.2 张量运算的导数：梯度"></a>2.4.2 张量运算的导数：梯度</h2><p>标量元组<code>(x,y)</code>映射一个标量值<code>z</code>，可以绘制三维空间（以x、y、z为坐标轴）中的二维表面。</p><p>张量运算的导数叫做梯度（gradient）.</p><p>对于标量函数，导数表示曲线的局部斜率(local slope)是加入了epsilon,epsilon足够小时，接近斜率。</p><p><strong>张量函数的梯度表示该函数所对应多维表面的曲率(curvature)。</strong></p><p>以机器学习中的一个例子为展示：</p><ul><li>输入向量x（数据集的一个样本）</li><li>矩阵W(模型权重)</li><li>目标值y_true(模型应该学到的与x相关的结果)</li><li>一个损失函数loss(用于衡量模型当前预测值与y_true之间的差距)</li></ul><p>可以用W来计算预测值y_pre，然后计算损失值，即预测值y_pre与目标值y_true之间的差距</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">y_pred = dot(W,x) <span class="hljs-comment">#利用模型权重w对x进行预测</span><br>loss_value = loss(y_pred,y_true) <span class="hljs-comment">#估算预测值的偏差有多大</span><br></code></pre></td></tr></table></figure><p><strong>用梯度更新W，以使loss_value变小</strong></p><p>保持输入数据x和y_true不变，可以讲前面的运算看作一个将模型权重W的值映射到损失值的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">loss_value = f(w) <span class="hljs-comment">#f描述的是：当W变化时，损失值所形成的曲线（或高维表面）</span><br></code></pre></td></tr></table></figure><p>假设W的当前值为<code>W0</code>，f在W0点的导数是一个张量<code>grad(loss_value,W0)</code></p><p>其形状与W相同，每个元素<code>grad(loss_value,W0)[i][j]</code>表示当<code>W0[i][j]</code>发生变化时<code>loss_value</code>变化的方向和大小。张量<code>grad(loss_value,W0)</code>函数<code>f(w)=loss_value</code>在W0处的梯度，也叫做loss_value相对于W在W0附近的梯度。</p><h3 id="偏导数"><a href="#偏导数" class="headerlink" title="偏导数"></a>偏导数</h3><p>张量运算<code>grad(f(W),W)</code>以矩阵W为输入，它可以表示为<strong>标量函数<code>grad_ij(f(w),w_ij)</code>的组合</strong>，每个标量函数返回的是<code>loss_value = f(W)</code>相对于<code>W[i,j]</code>的导数。（假设W的其他所有元素都不变）</p><p><code>grad_ij</code>叫作f对于<code>W[i,j]</code>的偏导数。(partial derivative)。</p><p><code>grad(loss_value,W0)</code><strong>具体含义</strong>：</p><p>单变量函数f(x)的导数可以看做函数f曲线的斜率，同样的，<code>grad(loss_value,W0)</code>可以看作表示<code>loss_value = f(W)</code>在W0附近最陡上升方向的张量，也表示这一上升方向的斜率。<strong>每个偏导数表示f在某个方向的斜率。</strong></p><p>对于一个函数f(x)沿着导数的反方向移动可以进一步减小f(x)的值，同样对于一个张量f(W)，可以将W沿着梯度的反方向移动来减小<code>loss_value = f(W)</code></p><p>比如：</p><p>W1 = W0 - step * grad(f(W0),W0)</p><p>step是一个很小的比例因子。</p><p>沿着f最陡上升的反方向移动，直观上可以移动到曲线上更低的位置。</p><p><strong>注意</strong>：比例因子step是必须的，因为grad(loss_value,W0)只是W0附近曲率的近似值，所以不能离W0太远。</p><h2 id="2-4-3-随机梯度下降"><a href="#2-4-3-随机梯度下降" class="headerlink" title="2.4.3 随机梯度下降"></a>2.4.3 随机梯度下降</h2><p>可微函数的最小值在导数为0处</p><p>应用于神经网络之中，通过对<code>grad(f(W),W) = 0</code>求解W来实现。</p><p>但是在实际神经网络中无法求解，参数的个数成千上万个。</p><h3 id="小批量随机梯度下降（小批量SGD）"><a href="#小批量随机梯度下降（小批量SGD）" class="headerlink" title="小批量随机梯度下降（小批量SGD）"></a>小批量随机梯度下降（小批量SGD）</h3><blockquote><p>stochastic = random</p></blockquote><ol><li>抽取训练样本x和对应目标的y_true组成一个数据批量</li><li>在x上运行模型，得到预测值y_pred（向前传播）</li><li>计算损失值，衡量y_pred和y_true之间的差距</li><li>计算损失相对于模型参数的梯度(反向传播)</li><li>将参数沿着梯度的反方向移动一小步，比如W-=learning_rate * gradient，从而使这批数据上的损失值减小一点。学习率（learning_rate)是一个调节梯度下降速度的标量因子。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230307161415582.png" alt="沿着一维损失函数曲线的随机梯度下降" style="zoom:50%;"></p><p>小批量SGD算法的一个变体每次迭代只选取一个样本和目标，而不是抽取一批数据。</p><p>这是<strong>真SGD</strong>，有别于小批量SGD。</p><p>另一种极端，<strong>批量梯度下降</strong>，每次迭代在所有数据上。</p><h3 id="SGD的多种变体"><a href="#SGD的多种变体" class="headerlink" title="SGD的多种变体"></a>SGD的多种变体</h3><ul><li>带动量的SGD</li><li>Adagrad</li><li>RMSprop</li></ul><p>这些变体在计算下一次权重更新时，不仅要考虑当前的梯度值，还要考虑上一次权重的更新，这些方法被称为优化方法（optimization method）或者优化器（optimizer）。</p><h3 id="动量SGD"><a href="#动量SGD" class="headerlink" title="动量SGD"></a>动量SGD</h3><p>解决了两个问题：</p><ul><li>收敛速度</li><li>局部极小值</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230307162333831.png" alt="局部极小点和全局极小点" style="zoom:50%;"></p><p>在图中局部极小点处，左移和右移都会导致损失值的增大，所以使用learning_rate较小的SGD对参数进行优化，优化过程会陷入到局部极小点，而无法找到全局极小点。</p><p>使用动量方法，参考物理，每次移动小球，不仅考虑它的当前加速度，还考虑它的速度。</p><p><strong>实践意义</strong>：更新W时不仅考虑当前的梯度值，还要考虑上一次参数更新。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">past_velocity = <span class="hljs-number">0.</span><br>momentum = <span class="hljs-number">0.1</span>   ←---- 不变的动量因子<br><span class="hljs-keyword">while</span> loss &gt; <span class="hljs-number">0.01</span>:   ←---- 优化循环<br>    w, loss, gradient = get_current_parameters()<br>    velocity = past_velocity * momentum - learning_rate * gradient<br>    w = w + momentum * velocity - learning_rate * gradient<br>    past_velocity = velocity<br>    update_parameter(w)<br></code></pre></td></tr></table></figure><h2 id="2-4-4-链式求导：反向传播算法"><a href="#2-4-4-链式求导：反向传播算法" class="headerlink" title="2.4.4 链式求导：反向传播算法"></a>2.4.4 链式求导：反向传播算法</h2><p>双层模型，计算损失相对于权重的梯度，使用<strong>反向传播算法</strong>。</p><h3 id="01-链式法则"><a href="#01-链式法则" class="headerlink" title="01.链式法则"></a>01.链式法则</h3><p>利用简单运算的导数，可以轻松算出这些基本运算的任意复杂组合的梯度。</p><p>神经网络由许多链接在一起的张量运算组成，每个张量运算的的导数已知，且都很简单。</p><p>代码清单2-2中定义的模型，一个由变量W1、b1、W2、b2（分别属于第一个Dense层和第二个Dense层）参数化的函数，运用到的基本运算是dot、relu、sotfmax和+，以及损失函数loss。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">loss_value = loss(y_true, softmax(dot(relu(dot(inputs, W1) + b1), W2) + b2))<br></code></pre></td></tr></table></figure><h4 id="链式法则求导（Chain-Rule）"><a href="#链式法则求导（Chain-Rule）" class="headerlink" title="链式法则求导（Chain Rule）"></a>链式法则求导（Chain Rule）</h4><p>两个函数f和g复合。</p><p>复合函数：</p><script type="math/tex; mode=display">fg:fg(x)==f(g(x))</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fg</span>(<span class="hljs-params">x</span>):<br>  x1 = g(x)<br>  y = f(x1)<br>  <span class="hljs-keyword">return</span> y<br></code></pre></td></tr></table></figure><p>链式法则规定：<script type="math/tex">grad(y,x) = grad(y,x1) * grad(x1,x)</script></p><p>知道f和g的导数，就能求出fg的导数，添加多个函数就像一条链，因此称为链式法则。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fghj</span>:<br>  x1 = j(x)<br>  x2 = g(x1)<br>  x3 = h(x2)<br>  y = f(x3)<br>  <span class="hljs-keyword">return</span> y<br>grad(y,x) = (grad(y,x3),grad(x3,x2),grad(x2,x1),grad(x1,x))<br></code></pre></td></tr></table></figure><p>将链式法则应用于神经网络梯度值的计算，就得到了一种叫作<strong>反向传播</strong>的算法。</p><h3 id="02-用计算图自动划分"><a href="#02-用计算图自动划分" class="headerlink" title="02 用计算图自动划分"></a>02 用计算图自动划分</h3><p>计算图是思考反向传播算法的一种有用方法，深度学习的核心数据结构，由运算构成的有向无环图。</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230307171139764.png" alt="双层模型示例的计算图表示" style="zoom: 33%;"></p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230307171340596.png" alt="简单计算图示例" style="zoom:33%;"></p><p>取两个标量变量 w 和 b，以及一个标量输入 x，然后对它们做一些运算，得到输出 y。最后，我们使用绝对值误差损失函数：<script type="math/tex">loss\underline{ }val = abs(y\underline{ }true - y)</script>。我们希望更新<script type="math/tex">w</script>和 <script type="math/tex">b</script>以使<script type="math/tex">loss\underline{ }val</script>最小化，所以需要计算 <script type="math/tex">grad(loss\underline{ }val, b)</script> 和 <script type="math/tex">grad(loss\underline{ }val, w)</script>。</p><p>从上到下，直到获得<script type="math/tex">loss\underline{ }value</script>，这是<strong>向前传播</strong>的过程。</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230307171820440.png" alt="运行一次向前传播" style="zoom:33%;"></p><p>画出反向的边，表示<strong>反向传播</strong>的过程。</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230307171935175.png" alt="运行一次反向传播" style="zoom:33%;"></p><p><strong>结果</strong>：</p><ul><li>grad(loss_val, x2) = 1，随x2变化一个小量epsilon,  loss_val = abs(4 - x2) 的变化量相同。</li><li>grad(x2, x1) = 1，随着x1变化一个小量epsilon，x2 = x1 + b = x1 + 1 的变化量相同。</li><li>grad(x2, b) = 1，随着b变化一个小量epsilon, x2 = x1 +b = 6+ b的变化量相同。</li><li>grad(x1, w) = 2，随着w变化一个小量epsilon，x1 = x <em> w = 2 </em> w的变化量为2倍的epsilon。</li></ul><p>根据链式法则，对于反向图，想求一个节点相对于另一个节点的导数，<strong>将链接两个节点的路径上的每条边的导数相乘。</strong></p><p>比如计算grad(loss, w) = grad(loss, x2) <em> grad(x2, x1) </em> grad(x1, w) </p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230307173444116.png" alt="在反向图中从 loss_val 到 w 的路径" style="zoom:33%;"></p><p>对应链式法则，得到想要的结果：</p><ul><li>grad(loss_val, w) = 1 <em> 1 </em> 2 = 2</li><li>grad(loss_val,b) = 1*1 = 1 </li></ul><p><strong>注意</strong>：在方向图中，如果a和b节点之间有多条路径，那么grad(a,b)等于所有路径值相加</p><h3 id="03-TensorFlow的梯度带"><a href="#03-TensorFlow的梯度带" class="headerlink" title="03 TensorFlow的梯度带"></a>03 TensorFlow的梯度带</h3><p><code>GradientTape</code>是一个API，进行自动微分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br>x = tf.Variable(<span class="hljs-number">0.</span>)  <span class="hljs-comment"># 将标量Variable的值初始化为0</span><br><span class="hljs-keyword">with</span>  tf.GradientTape() <span class="hljs-keyword">as</span> tape: <span class="hljs-comment">#创建一个GradientTape作用域</span><br>    y = <span class="hljs-number">2</span> * x +<span class="hljs-number">3</span>  <span class="hljs-comment">#在作用域内，对变量进行张量运算</span><br>    grad_of_y_wrt_x = tape.gradient(y,x) <span class="hljs-comment">#利用梯度带获取输出y相对于变量x的梯度</span><br></code></pre></td></tr></table></figure><p>张量运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># GradientTape 也可以用于张量运算</span><br>x = tf.Variable(tf.zeros(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)) <span class="hljs-comment"># 将Variable初始化为形状（2，2）的零张量</span><br><span class="hljs-keyword">with</span> tf.GradientTape() <span class="hljs-keyword">as</span> tape:<br>    y = <span class="hljs-number">2</span> * x + <span class="hljs-number">3</span><br>grad_of_y_wrt_x = tape.gradient(y,x) <span class="hljs-comment">#grad_of_y_wrt_x是一个形状为(2,2)的张量，与x相同</span><br><span class="hljs-comment">#表示y = 2 * x + 3 在x = [[0,0],[0,0]]附近的曲率</span><br><br></code></pre></td></tr></table></figure><p>变量列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 适用于变量列表</span><br>W = tf.Variable(tf.random.uniform((<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)))<br>b = tf.Variable(tf.zeros((<span class="hljs-number">2</span>,)))<br>x = tf.random.uniform((<span class="hljs-number">2</span>,<span class="hljs-number">2</span>))<br><span class="hljs-keyword">with</span> tf.GradientTape() <span class="hljs-keyword">as</span> tape:<br>    y = tf.matmul(x,W)+b <span class="hljs-comment"># 在TensorFlow中matmul是指点积</span><br>grad_of_y_wrt_W_and_b = tape.gradient(y,[W,b]) <span class="hljs-comment">#grad_of_y_wrt_W_and_b是由两个张量组成的列表</span><br><span class="hljs-comment">#这两个张量的形状分别于W和b相同</span><br><span class="hljs-built_in">print</span>(grad_of_y_wrt_W_and_b)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03｜Mutex：4种易错场景大盘点</title>
    <link href="/2023/03/03/03%EF%BD%9CMutex%EF%BC%9A4%E7%A7%8D%E6%98%93%E9%94%99%E5%9C%BA%E6%99%AF%E5%A4%A7%E7%9B%98%E7%82%B9/"/>
    <url>/2023/03/03/03%EF%BD%9CMutex%EF%BC%9A4%E7%A7%8D%E6%98%93%E9%94%99%E5%9C%BA%E6%99%AF%E5%A4%A7%E7%9B%98%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="03｜Mutex：4种易错场景大盘点"><a href="#03｜Mutex：4种易错场景大盘点" class="headerlink" title="03｜Mutex：4种易错场景大盘点"></a>03｜Mutex：4种易错场景大盘点</h1><h2 id="1-Lock-Unlock-不是成对出现"><a href="#1-Lock-Unlock-不是成对出现" class="headerlink" title="1.Lock/Unlock 不是成对出现"></a>1.<strong>Lock/Unlock</strong> <strong>不是成对出现</strong></h2><p>Lock/Unlock 没有成对出现，就意味着会出现死锁的情况，或者是因为 Unlock 一个未加锁的Mutex 而导致 panic。</p><p>缺少Unlock的场景，常见的三种情况：</p><ul><li>if-else分支太多，漏写Unlock</li><li>重构时删除Unlock</li><li>Unlock误写成Lock</li></ul><p>在这种情况下，锁被获取之后，就不会被释放了，这也就意味着，其它的 goroutine 永远都没机会获取到锁。</p><p>误删Lock()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> mu sync.Mutex<br><span class="hljs-keyword">defer</span> mu.Unlock()<br>fmt.Println(<span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行之后panic</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230304000406863.png" alt="image-20230304000406863"></p><h2 id="2-Copy已经使用的Mutex"><a href="#2-Copy已经使用的Mutex" class="headerlink" title="2.Copy已经使用的Mutex"></a>2.Copy已经使用的Mutex</h2><p>Package sync 的同步原语在使用后是不能复制的。</p><p>为什么Mutex不能够复制？</p><p>Mutex是一个有状态的对象，它的state字段记录了这个锁的状态。如果复制一个已经加锁的Mutex给一个新的变量，新的初始化的变量就被加锁了，显然不符合预期，我们期待一个零值的Mutex。</p><p>在并发环境之中，我们不知道复制的Mutex状态是什么，因为要复制的 Mutex 是由其它 goroutine 并发访问的，状态可能总是在变化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Counter <span class="hljs-keyword">struct</span> &#123;<br>sync.Mutex<br>Count <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> c Counter<br>c.Lock()<br><span class="hljs-keyword">defer</span> c.Unlock()<br>c.Count++<br>foo2(c)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo2</span><span class="hljs-params">(c Counter)</span></span> &#123;<br>c.Lock()<br><span class="hljs-keyword">defer</span> c.Unlock()<br>fmt.Println(<span class="hljs-string">&quot;in foo&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230304001403468.png" alt="image-20230304001403468"></p><p>这里第18行调用foo函数时，复制了c作为函数的参数，但是c已经被使用，复制出来的Counter带有状态。</p><h3 id="死锁的检查机制"><a href="#死锁的检查机制" class="headerlink" title="死锁的检查机制"></a>死锁的检查机制</h3><p>这个例子中因为复制了一个使用了的 Mutex，导致锁无法使用，程序处于死锁的状态。程序运行的时候，死锁检查机制能够发现这种死锁情况并输出错误信息，如下图中错误信息以及错误堆栈。</p>]]></content>
    
    
    <categories>
      
      <category>Concurrency</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第一部分 学习shell</title>
    <link href="/2023/03/03/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%AD%A6%E4%B9%A0shell/"/>
    <url>/2023/03/03/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%AD%A6%E4%B9%A0shell/</url>
    
    <content type="html"><![CDATA[<h1 id="第一部分-学习shell"><a href="#第一部分-学习shell" class="headerlink" title="第一部分-学习shell"></a>第一部分-学习shell</h1><p>shell是一个接收由键盘输入的命令，并将其传递给操作系统来执行的程序。</p><h2 id="第一章-什么是Shell"><a href="#第一章-什么是Shell" class="headerlink" title="第一章 什么是Shell"></a>第一章 什么是Shell</h2><h3 id="1-1终端仿真器"><a href="#1-1终端仿真器" class="headerlink" title="1.1终端仿真器"></a>1.1终端仿真器</h3><p>当使用图形用户界面时，需要另一种叫做终端仿真器（terminal emulator）的程序与shell进行交互。</p><h3 id="1-2-第一次键盘输入"><a href="#1-2-第一次键盘输入" class="headerlink" title="1.2 第一次键盘输入"></a>1.2 第一次键盘输入</h3><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230303075554381.png" alt="image-20230303075554381"></p><h4 id="1-2-1命令历史记录"><a href="#1-2-1命令历史记录" class="headerlink" title="1.2.1命令历史记录"></a>1.2.1命令历史记录</h4><p>如果按下向上方向指示键，将会看到先前的命令kaekfjaeifj再一次出现在 提示符的后面，这称为命令历史记录。在默认情况下，大部分Linux发行 版本能够存储最近输入的500个命令。按下向下方向指示键，则先前的命令消失。</p><h4 id="1-2-2光标移动"><a href="#1-2-2光标移动" class="headerlink" title="1.2.2光标移动"></a>1.2.2光标移动</h4><p>再次按下向上方向指示键，重新调用先前的命令，然后分别按下向左和向右方向指示键，看看如何将光标定位到命令行的任意位置。</p><h3 id="1-3几个简单命令"><a href="#1-3几个简单命令" class="headerlink" title="1.3几个简单命令"></a>1.3几个简单命令</h3><p>系统时间和日期</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(base) wyx@microbe-System-Product-Name:~$ date<br>2023年 03月 03日 星期五 07:57:42 CST<br></code></pre></td></tr></table></figure><p>当前月的日历</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">(base) wyx@microbe-System-Product-Name:~$ cal<br>      三月 2023         <br>日 一 二 三 四 五 六  <br>          1  2  3  4  <br> 5  6  7  8  9 10 11  <br>12 13 14 15 16 17 18  <br>19 20 21 22 23 24 25  <br>26 27 28 29 30 31     <br></code></pre></td></tr></table></figure><p>查看磁盘驱动器当前的可用空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs shell">(base) wyx@microbe-System-Product-Name:~$ df<br>文件系统            1K-块       已用       可用 已用% 挂载点<br>udev             49376016          0   49376016    0% /dev<br>tmpfs             9880236       2044    9878192    1% /run<br>/dev/sda2       479079112   55672484  398997236   13% /<br>tmpfs            49401176          0   49401176    0% /dev/shm<br>tmpfs                5120          4       5116    1% /run/lock<br>tmpfs            49401176          0   49401176    0% /sys/fs/cgroup<br>/dev/loop0            512        512          0  100% /snap/gnome-characters/781<br>/dev/loop1         457088     457088          0  100% /snap/gnome-42-2204/44<br>/dev/loop2          51072      51072          0  100% /snap/snapd/17950<br>/dev/loop3          64896      64896          0  100% /snap/core20/1778<br>/dev/loop4         354688     354688          0  100% /snap/gnome-3-38-2004/119<br>/dev/loop5            768        768          0  100% /snap/gnome-logs/115<br>/dev/loop6           1536       1536          0  100% /snap/gnome-system-monitor/181<br>/dev/sda1          523248      29164     494084    6% /boot/efi<br>/dev/sdb2      3844533232 1097744044 2551422788   31% /home<br>/dev/loop7          74752      74752          0  100% /snap/core22/522<br>/dev/loop8         463360     463360          0  100% /snap/gnome-42-2204/56<br>/dev/loop9           2688       2688          0  100% /snap/gnome-system-monitor/178<br>/dev/loop10        354688     354688          0  100% /snap/gnome-3-38-2004/115<br>/dev/loop11         83328      83328          0  100% /snap/gtk-common-themes/1534<br>/dev/loop12         74752      74752          0  100% /snap/core22/509<br>tmpfs             9880232         16    9880216    1% /run/user/121<br>/dev/loop13         64896      64896          0  100% /snap/core20/1822<br>/dev/loop14        224256     224256          0  100% /snap/gnome-3-34-1804/77<br>/dev/loop15           768        768          0  100% /snap/gnome-characters/741<br>/dev/loop16          2688       2688          0  100% /snap/gnome-calculator/920<br>/dev/loop17         56960      56960          0  100% /snap/core18/2697<br>/dev/loop18        224256     224256          0  100% /snap/gnome-3-34-1804/72<br>/dev/loop19          2560       2560          0  100% /snap/gnome-calculator/884<br>/dev/loop20           128        128          0  100% /snap/bare/5<br>/dev/loop21         93952      93952          0  100% /snap/gtk-common-themes/1535<br>/dev/loop22         56960      56960          0  100% /snap/core18/2679<br>/dev/loop23         51072      51072          0  100% /snap/snapd/18357<br>/dev/loop24           640        640          0  100% /snap/gnome-logs/112<br>tmpfs             9880232         64    9880168    1% /run/user/1014<br>tmpfs             9880232          0    9880232    0% /run/user/1018<br><br></code></pre></td></tr></table></figure><p>显示可用内存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">(base) wyx@microbe-System-Product-Name:~$ free<br>              总计         已用        空闲      共享    缓冲/缓存    可用<br>内存：    98802352     4754444    84879532       28500     9168376    93033984<br>交换：     2097148           0     2097148<br></code></pre></td></tr></table></figure><h3 id="1-4结束终端会话"><a href="#1-4结束终端会话" class="headerlink" title="1.4结束终端会话"></a>1.4结束终端会话</h3><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230303080129518.png" alt="image-20230303080129518"></p><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h2 id="第2章-导航"><a href="#第2章-导航" class="headerlink" title="第2章 导航"></a>第2章 导航</h2><h3 id="2-1文件系统树"><a href="#2-1文件系统树" class="headerlink" title="2.1文件系统树"></a>2.1文件系统树</h3><p>类Unix操作系统使用分层目录结构的方式来组织文件。</p><p>文件系统的第一个目录叫做根目录，包含文件和子目录。</p><p>windows系统每个存储设备都有一个独立的文件系统树，但是在linux中，无论有多少驱动器和存储设备，通常只有一个文件树。</p><h3 id="2-2当前工作目录"><a href="#2-2当前工作目录" class="headerlink" title="2.2当前工作目录"></a>2.2当前工作目录</h3><p>使用pwd显示当前工作目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(base) wyx@microbe-System-Product-Name:~$ pwd<br>/home/wyx<br></code></pre></td></tr></table></figure><h3 id="2-3列出目录内容"><a href="#2-3列出目录内容" class="headerlink" title="2.3列出目录内容"></a>2.3列出目录内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(base) wyx@microbe-System-Product-Name:~$ ls<br>anaconda3  Anaconda3-2022.10-Linux-x86_64.sh  examples.desktop  MSA-Robustness<br></code></pre></td></tr></table></figure><h3 id="2-4更改当前工作目录"><a href="#2-4更改当前工作目录" class="headerlink" title="2.4更改当前工作目录"></a>2.4更改当前工作目录</h3><p>使用cd命令可以改变工作目录（即在文件系统树的位置）；只需输入cd命令，然后再输入目标工作目录的路径名即可。</p><ul><li>绝对路径</li><li>相对路径</li></ul><h4 id="2-4-1绝对路径名"><a href="#2-4-1绝对路径名" class="headerlink" title="2.4.1绝对路径名"></a>2.4.1绝对路径名</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(base) wyx@microbe-System-Product-Name:~$  cd /usr/bin<br>(base) wyx@microbe-System-Product-Name:/usr/bin$ <br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230303081311498.png" alt="image-20230303081311498"></p><h4 id="2-4-2相对路径名"><a href="#2-4-2相对路径名" class="headerlink" title="2.4.2相对路径名"></a>2.4.2相对路径名</h4><p>它通常使用一些特殊符号来表示文件系统树中的相对位置，这些特殊符号是“.”（点）和“..”（点点）。</p><p>“.” 代表工作目录，”..”代表工作目录的父目录</p><p>从/usr/bin回到父目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr<br><br>cd ..<br></code></pre></td></tr></table></figure><p>从/usr到/usr/bin</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/bin<br><br>cd ./bin<br><br>cd bin<br></code></pre></td></tr></table></figure><h3 id="2-4-3一些有用的快捷方式"><a href="#2-4-3一些有用的快捷方式" class="headerlink" title="2.4.3一些有用的快捷方式"></a>2.4.3一些有用的快捷方式</h3><div class="table-container"><table><thead><tr><th>快捷方式</th><th>结果</th></tr></thead><tbody><tr><td>cd</td><td>回到主目录</td></tr><tr><td>cd -</td><td>把工作目录改成先前的工作目录</td></tr><tr><td>cd ~username</td><td>将工作目录改为username的主目录</td></tr></tbody></table></div><h2 id="第3章-操作系统"><a href="#第3章-操作系统" class="headerlink" title="第3章 操作系统"></a>第3章 操作系统</h2><h3 id="3-1-ls命令"><a href="#3-1-ls命令" class="headerlink" title="3.1 ls命令"></a>3.1 ls命令</h3><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230303082319410.png" alt="image-20230303082319410"></p><p>指定要显示的目录</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230303082340877.png" alt="image-20230303082340877"></p><p>指定多个目录</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230303082412289.png" alt="image-20230303082412289"></p><p>展示更多细节</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230303082708973.png" alt="image-20230303082708973"></p><h4 id="3-1-1-选项和参数"><a href="#3-1-1-选项和参数" class="headerlink" title="3.1.1 选项和参数"></a>3.1.1 选项和参数</h4><p>ls命令包含了两个选项；l选项产生长格式输出，而t选项则表示以文件修改时间的先后将结果进行排序。</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230303083006111.png" alt="image-20230303083006111"></p><p>以相反顺序输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -lt --reverse<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>选项</th><th>长选项</th><th>含义</th></tr></thead><tbody><tr><td>-a</td><td>—all</td><td>列出所有文件，包括以点号开头的文件，这些文件通常是不列出来的</td></tr><tr><td>-d</td><td>—directory</td><td>通常，如果指定了一个目录，ls命令会列出目录中的内容而不是目录本</td></tr><tr><td>-F</td><td>—classify</td><td>选项会在每个所列出的名字后面加上类型指示符（例如，如果名字是目录名，则会加上一个斜杠）</td></tr><tr><td>-h</td><td>—human-readable</td><td>以长格式列出，以人们可读的方式而不是字节数来显示文件大小</td></tr><tr><td>-l</td><td></td><td>使用长格式显示结果</td></tr><tr><td>-r</td><td>—reverse</td><td>以相反的顺序显示结果。通常，ls命令按照字母升序排列显示结果</td></tr><tr><td>-S</td><td></td><td>按文件大小对结果排序</td></tr><tr><td>-t</td><td></td><td>按照修改时间排序</td></tr></tbody></table></div><h4 id="3-1-2-进一步了解长列表格式"><a href="#3-1-2-进一步了解长列表格式" class="headerlink" title="3.1.2 进一步了解长列表格式"></a>3.1.2 进一步了解长列表格式</h4><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230303084604541.png" alt="image-20230303084604541"></p><h3 id="3-2-使用file命令确定文件类型"><a href="#3-2-使用file命令确定文件类型" class="headerlink" title="3.2 使用file命令确定文件类型"></a>3.2 使用file命令确定文件类型</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">file filename<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230303085148597.png" alt="image-20230303085148597"></p><h3 id="3-3-less命令查看文件内容"><a href="#3-3-less命令查看文件内容" class="headerlink" title="3.3 less命令查看文件内容"></a>3.3 less命令查看文件内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">less /etc/password<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230303085811698.png" alt="image-20230303085811698"></p><p>一旦less程序运行起来，我们就可查看文件内容。如果文件不止一页，可以上下滚动文件。按Q键可退出less程序。</p><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">PAGE UP或b</td><td style="text-align:center">后翻一页</td></tr><tr><td style="text-align:center">PAGE DOWN或</td><td style="text-align:center">前翻一页</td></tr><tr><td style="text-align:center">向上箭头键</td><td style="text-align:center">向上一行</td></tr><tr><td style="text-align:center">向下箭头键</td><td style="text-align:center">向下一行</td></tr><tr><td style="text-align:center">G</td><td style="text-align:center">跳转到文本文件的末尾</td></tr><tr><td style="text-align:center">1G或g</td><td style="text-align:center">跳转到文本文件的开头</td></tr><tr><td style="text-align:center">/<em>charecters</em></td><td style="text-align:center">向前查找指定的字符串</td></tr><tr><td style="text-align:center">n</td><td style="text-align:center">向前查找下一个出现的字符串，这个字符串是之前所指定查</td></tr><tr><td style="text-align:center">h</td><td style="text-align:center">显示帮助屏幕</td></tr><tr><td style="text-align:center">q</td><td style="text-align:center">退出less</td></tr></tbody></table></div><p>less命令属于“页面调度器（pagers）”程序类，这些程序允许通过一页一页的方式，轻松浏览很长的文本文档。而more程序只允许向前翻页，使用less命令既可以前后翻页，还具有很多其他的特性。</p><h3 id="3-4-快速浏览"><a href="#3-4-快速浏览" class="headerlink" title="3.4 快速浏览"></a>3.4 快速浏览</h3><ol><li>使用cd命令进入一个给定目录</li><li>使用ls -l命令列出目录内容</li><li>看到感兴趣的文件，使用file命令确定文件内容</li><li>如果文件看起来是一个文件，可以使用less命令浏览其内容</li></ol><div class="table-container"><table><thead><tr><th>目录</th><th>内容</th></tr></thead><tbody><tr><td>/</td><td>根目录，一切从这里开始</td></tr><tr><td>/bin</td><td>包含系统启动和运行必须的二进制文件</td></tr><tr><td>/boot</td><td>包含Linux内核和最初的RAM磁盘映像（系统启动时，驱动程序会用到），以及启动加载程序。<br />有趣的文件：<br />/boot/grub/grub.conf或menu.lst，用来配置启动加载程序 ；<br />•/boot/vmlinuz，Linux内核</td></tr><tr><td>/dev</td><td>这是一个包含设备节点的特殊目录。”把一切当作文件“也适用于设备。内核将它能够识别的设备存放在这个目录里。</td></tr><tr><td>/etc</td><td>/etc目录包含了所有系统层面的配置文件，同时含有一系列shell脚本，系统每次启动时，这些shell脚本都会打开每个系统服务。该目录中包含的内容都是可读的文本文件。<br />有趣的文件：<br />/etc/crontab,定义了自动化任务运行的时间<br />/etc/fstab,存储设备以及相关挂载点的列表<br />/etc/password，用户账号列表</td></tr><tr><td>/home</td><td>在通常的配置中，每个用户会在/home目录拥有一个属于自己的目录。普通用户只能在自己的主目录中创建文件，保护系统免遭错误的用户行为破坏。</td></tr><tr><td>/lib</td><td>包含核心系统程序使用的共享文件库，与windows的DDL类似</td></tr><tr><td>/lost+found</td><td>每个使用Linux文件系统的格式化分区或设备，例如ext3文件系统，都会有这个目录。当文件系统崩溃时，该目录用于恢复分区。除非系统真的发生很严重的问题，否则这个目录一直是空的</td></tr><tr><td>/media</td><td>/media 包含了可移除媒体设备的挂载点</td></tr><tr><td>/mnt</td><td>/mnt目录包含手动挂载的可移除设备的挂接点</td></tr><tr><td>/opt</td><td>/opt目录用来安装其他可选的软件。主要用来存放可能安装在系统中</td></tr><tr><td>/proc</td><td>/proc目录很特殊。从文件的角度来说，它不是存储在硬盘中的真正的文件系统，反而是一个Linux内核维护的虚拟文件系统。它包含的文件是内核的窥视孔。该文件是可读的，从中可以看到内核是如何监管计算机的。</td></tr><tr><td>/root</td><td>root账户的主目录</td></tr><tr><td>/sbin</td><td>该目录放置“系统”二进制文件。这些程序执行重要的系统任务，这些任务通常是为超级用户预留的</td></tr><tr><td>/tmp</td><td>/tmp是供用户存放各类程序创建的临时文件的目录。某些配置使得每次系统重启时都会清空该目录</td></tr><tr><td>/usr</td><td>/usr目录可能是Linux系统中最大的目录树。它包含普通用户使用的所有程序和相关文件</td></tr><tr><td>/usr/bin</td><td>/usr/bin目录中放置了一些Linux发行版安装的可执行程序。该目录通常会存储成千上万个程序</td></tr><tr><td>/usr/lib</td><td>/usr/bin目录中的程序使用的共享库</td></tr><tr><td>/usr/local</td><td>这个/usr/local目录是并非系统发行版自带，但却打算让系统使用的程序的安装目录。由源代码编译好的程序通常安装在/usr/local/bin中。在一个新安装的Linux系统中，就存在这一个目录，但却是空目录，直到系统管理员向其中添加内容</td></tr><tr><td>/usr/sbin</td><td>包含更多的系统管理程序</td></tr><tr><td>/usr/share</td><td>/usr/share目录里包含了/usr/bin中的程序所使用的全部共享数据，这包括默认配置文件、图标、屏幕背景、音频文件等</td></tr><tr><td>/usr/share/doc</td><td>安装在系统中的大部分程序包包含一些文档文件。在/usr/share/doc中，文档文件是按照软件包来组织分类的</td></tr><tr><td>/var</td><td>除了/tmp和/home目录之外，目前看到的目录相对来说都是静态的；也就是说，其包含的内容是不变的。而那些可能改变的数据存储在/var目录树里。各种数据库、假脱机文件、用户邮件等都存储在这里</td></tr><tr><td>/var/log</td><td>/var/log目录包含的日志文件，记录了各种系统活动。这些文件非常重要，并且应该时不时地监控它们。其中最有用的文件是/var/log/messages。注意，为了安全起见，在一些系统里，必须是超级用户才能查看日志文件</td></tr></tbody></table></div><h3 id="3-5-符号链接"><a href="#3-5-符号链接" class="headerlink" title="3.5 符号链接"></a>3.5 符号链接</h3><p>浏览过程中看到以下条目的目录信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">lrwxrwxrwx 1 root root 11 2012-08-11 07:34 libc.so.6 -&gt; libc-2.6.so<br></code></pre></td></tr></table></figure><p>注意，该条目信息的第一个字母是l，而且看起来像是有两个文件名。这种特殊的文件叫做<strong>符号链接</strong>（又叫软链接或symlink）。protoc 指定为 arch_64 版本</p><p>在大多类UNIX系统中，一个文件很可能采用多个名字引用。</p><p>某个程序需要使用foo文件中的一个共享资源，文件名包含了版本号，但是foo的版本变化频繁，版本变化后，如果名称变化，就必须跟踪每个可能使用该共享资源的程序，安装了该资源的版本后，都要让使用该资源的程序去寻找新的资源名字。</p><p>创建一个符号链接foo指向foo-2.6,打开foo文件其实就是意味着打开foo-2.6。升级到2.7时，将文件添加到系统里，删除符号链接文件，创建指向新版本的符号链接即可。</p><p>解决了版本问题，还保存了原有的版本文件。</p><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><p>允许文件有多个名字。</p><h2 id="第4章-操作文件与目录"><a href="#第4章-操作文件与目录" class="headerlink" title="第4章 操作文件与目录"></a>第4章 操作文件与目录</h2><ul><li>cp：复制文件与目录</li><li>mv：移动或重命名文件和目录</li><li>mkdir：创建目录</li><li>rm：移除文件和目录</li><li>in：创建硬链接和符号链接</li></ul><h3 id="4-1-通配符"><a href="#4-1-通配符" class="headerlink" title="4.1 通配符"></a>4.1 通配符</h3><p>​                                                                                        <strong>通配符</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">通配符</th><th style="text-align:center">匹配项</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td style="text-align:center">匹配任意多个字符（包括0和1个）</td></tr><tr><td style="text-align:center">？</td><td style="text-align:center">匹配任意单个字符（不包括0）</td></tr><tr><td style="text-align:center">[characters]</td><td style="text-align:center">匹配任意一个属于字符集中的字符</td></tr><tr><td style="text-align:center">[!characters]</td><td style="text-align:center">匹配任意一个不属于字符集中的字符</td></tr><tr><td style="text-align:center">[[:class:]]</td><td style="text-align:center">匹配任意一个属于指定字符类中的字符</td></tr></tbody></table></div><p>​                                                                                    <strong>常用字符类</strong>            </p><div class="table-container"><table><thead><tr><th style="text-align:center">字符类</th><th style="text-align:center">匹配项</th></tr></thead><tbody><tr><td style="text-align:center">[:alnum:]</td><td style="text-align:center">匹配任意一个字母或数字</td></tr><tr><td style="text-align:center">[:alpha:]</td><td style="text-align:center">匹配任意一个字母</td></tr><tr><td style="text-align:center">[:digit]</td><td style="text-align:center">匹配任意一个数字</td></tr><tr><td style="text-align:center">[:lower]</td><td style="text-align:center">匹配任意一个小写字母</td></tr><tr><td style="text-align:center">[:upper:]</td><td style="text-align:center">匹配任意一个大写字母</td></tr></tbody></table></div><p>​                                                                                    <strong>通配符示例</strong>            </p><div class="table-container"><table><thead><tr><th style="text-align:center">模式</th><th style="text-align:center">匹配项</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td style="text-align:center">所有文件</td></tr><tr><td style="text-align:center">g*</td><td style="text-align:center">以g开头的所有文件</td></tr><tr><td style="text-align:center">b*.txt</td><td style="text-align:center">以b开头的txt文件</td></tr><tr><td style="text-align:center">Data???</td><td style="text-align:center">以Data开头，后面跟3个字符的任一文件</td></tr><tr><td style="text-align:center">[abc]*</td><td style="text-align:center">以abc任一开头的任一文件</td></tr><tr><td style="text-align:center"><code>BACKUP.[0-9][0-9][0-9]</code></td><td style="text-align:center">以<code>BACKUP.</code>开头，后面紧跟3个数字的任一文件</td></tr><tr><td style="text-align:center">[[:upper:]]*</td><td style="text-align:center">以大写字母开头的任一文件</td></tr><tr><td style="text-align:center">[![:digit:]]*</td><td style="text-align:center">不以数载开头的任一文件</td></tr><tr><td style="text-align:center">*[[:lower]123]</td><td style="text-align:center">以小写字母或数字1、2、3中的任一结尾的任一文件</td></tr></tbody></table></div><p>​                            </p><h4 id="字符范围"><a href="#字符范围" class="headerlink" title="字符范围"></a>字符范围</h4><p>[a-z]和[A-Z]尽管还能用，但是难以确保不会发生意想不到的错误</p><h4 id="通配符在GUI中也奏效"><a href="#通配符在GUI中也奏效" class="headerlink" title="通配符在GUI中也奏效"></a>通配符在GUI中也奏效</h4><ul><li><p>Nautilus：Edit-&gt;Select Pattern选择文件。输入通配符表示的文件选择模式，会显示匹配的文件</p></li><li><p>Dolphin和Konqueror：直接地址栏输入通配符，比如在<code>\usr\bin</code>目录下，输入<code>u*</code>，可以显示匹配结果。</p></li></ul><h3 id="4-2-mkdir——创建目录"><a href="#4-2-mkdir——创建目录" class="headerlink" title="4.2 mkdir——创建目录"></a>4.2 mkdir——创建目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir dir1<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir dir1 dir2 dir3<br></code></pre></td></tr></table></figure><h3 id="4-3-cp——复制文件和目录"><a href="#4-3-cp——复制文件和目录" class="headerlink" title="4.3 cp——复制文件和目录"></a>4.3 cp——复制文件和目录</h3><p>复制文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp item1 item2<br></code></pre></td></tr></table></figure><p>复制目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp item... directory<br></code></pre></td></tr></table></figure><p>​                                                                                        <strong>cp常用选项</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">-a<br />—archive</td><td style="text-align:center">复制文件和目录及其属性，包括所有权和权限。通常来说，复制的文件具有用户操作文件的默认属性</td></tr><tr><td style="text-align:center">-i<br />—interactive</td><td style="text-align:center">在覆盖一个已存在的文件前，提升用户进行确认。如果没有指定该项，cp会默认覆盖文件</td></tr><tr><td style="text-align:center">-r<br />—recursive</td><td style="text-align:center">递归地复制目录及其内容。复制目录时需要使用这个选项(或者-a选项)</td></tr><tr><td style="text-align:center">-u<br />—update</td><td style="text-align:center">当将文件从一个目录复制到另一个目录时，只会复制目标目录中没有的文件或者更新已有的文件</td></tr><tr><td style="text-align:center">-v<br />—verbose</td><td style="text-align:center">复制文件时，显示信息性消息(informative message)</td></tr></tbody></table></div><p>​                                                                                <strong>cp命令示例</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center">cp file1 file2</td><td style="text-align:center">将file1复制到file2。如果file2存在，会被file1覆盖，不存在，会生成file2</td></tr><tr><td style="text-align:center">cp -i file1 file2</td><td style="text-align:center">同上，区别是覆盖前会通知用户确认</td></tr><tr><td style="text-align:center">cp file1 file2 dir1</td><td style="text-align:center">将file1和file2复制到dir1文件夹下，前提是dir1存在</td></tr><tr><td style="text-align:center">cp dir/* dir2</td><td style="text-align:center">将dir1中全部文件复制到dir2中，前提是dir2存在</td></tr><tr><td style="text-align:center">cp -r dir1 dir2</td><td style="text-align:center">将dir1目录(及其内容)复制到dir2中，如果dir2不存在，创建dir2</td></tr><tr><td style="text-align:center"></td></tr></tbody></table></div><h3 id="4-4-mv——移除和重命名文件"><a href="#4-4-mv——移除和重命名文件" class="headerlink" title="4.4 mv——移除和重命名文件"></a>4.4 mv——移除和重命名文件</h3><p>重命名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv item1 item2<br></code></pre></td></tr></table></figure><p>将item移入dir</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv item... directory<br></code></pre></td></tr></table></figure><p>​                                                                               <strong>mv选项</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">-i<br />—interactive</td><td style="text-align:center">覆盖一个已存在的文件之前，提示用户确认。如果没有指定该选项，mv会默认覆盖</td></tr><tr><td style="text-align:center">-u<br />—update</td><td style="text-align:center">把文件从一个目录移动到另一个目录，只移动没有的文件，或更新已有的文件</td></tr><tr><td style="text-align:center">-v<br />—verbose</td><td style="text-align:center">移动文件时显示信息性消息</td></tr></tbody></table></div><p>​                                                                          <strong>mv示例</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center">mv file1 file2</td><td style="text-align:center">file1移动到file2，如果存在file2，会覆盖file2，不存在，会创建file2</td></tr><tr><td style="text-align:center">mv -i file1 file2</td><td style="text-align:center">同上，显示确认信息</td></tr><tr><td style="text-align:center">mv file1 file2 dir</td><td style="text-align:center">移动file1和file2到dir下，dir必须存在</td></tr><tr><td style="text-align:center">mv dir1 dir2</td><td style="text-align:center">将dir1移动到dir2，删除原来位置的dir1，如果dir2不存在，创建dir2</td></tr></tbody></table></div><h3 id="4-5-rm——删除文件和目录"><a href="#4-5-rm——删除文件和目录" class="headerlink" title="4.5 rm——删除文件和目录"></a>4.5 rm——删除文件和目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm item...<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm *.html<br></code></pre></td></tr></table></figure><p>如果不小心多打了一个空格</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm * .html<br></code></pre></td></tr></table></figure><p>rm 命令将会删除目录中所有文件，并提示说明目录中没有叫做.html的文件。</p><p>​                                                                                    <strong>rm选项</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">-i<br />-interactive</td><td style="text-align:center">删除一个已经存在的文件时，提示用户确认</td></tr><tr><td style="text-align:center">-r<br />—recursive</td><td style="text-align:center">递归删除目录</td></tr><tr><td style="text-align:center">-f<br />—force</td><td style="text-align:center">忽视不存在的文件，无需提示确认，覆盖-i</td></tr><tr><td style="text-align:center">-v<br />—verbose</td><td style="text-align:center">删除文件时显示信息性消息</td></tr></tbody></table></div><p>​                                                                                    <strong>rm实例</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center">rm file1</td><td style="text-align:center">在不提示用户的情况下，删除file1</td></tr><tr><td style="text-align:center">rm -i file1</td><td style="text-align:center">删除file1前提示用户</td></tr><tr><td style="text-align:center">rm -r file1 dir1</td><td style="text-align:center">删除file1、dir1及它们的内容</td></tr><tr><td style="text-align:center">rm -rf file1 dir1</td><td style="text-align:center">即使file1和dir1不存在，也会继续删除</td></tr></tbody></table></div><h3 id="4-6-ln——创建链接"><a href="#4-6-ln——创建链接" class="headerlink" title="4.6 ln——创建链接"></a>4.6 ln——创建链接</h3><p>创建硬链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln file link<br></code></pre></td></tr></table></figure><p>创建符号链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s item link<br></code></pre></td></tr></table></figure><h4 id="4-6-1-硬链接"><a href="#4-6-1-硬链接" class="headerlink" title="4.6.1 硬链接"></a>4.6.1 硬链接</h4><p>默认情况下，每一个文件都有一个硬链接，该硬链接会给文件起名字。</p><p>当创建一个硬链接时，也会为这个文件创建一个额外的目录条目。</p><p><strong>硬链接的局限性：</strong></p><ul><li>硬链接不能引用自身系统之外的文件，不在同一磁盘分区的无法引用</li><li>硬链接不能够引用目录</li></ul><p>硬链接与文件本身无区别，但是包含硬链接的目标列表没有特别的链接指示说明。</p><p>当硬链接被删除时，只是删除了链接，文件本身还存在，除非删除文件的全部链接。</p><h4 id="4-6-2-符号链接"><a href="#4-6-2-符号链接" class="headerlink" title="4.6.2 符号链接"></a>4.6.2 符号链接</h4><p>克服硬链接的局限性。</p><p>符号链接通过创建特殊类型的文件起作用，该文件包含了指向引用文件或目录的文本指针。</p><p>向符号链接中写入东西，同样会写入引用文件，删除符号链接时，只会删除链接，不会删除文件本身。</p><p>坏链接：文件本身先被删除，符号链接仍然存在，不指向任何位置。</p><p>ls命令会显示坏链接，标红。</p><h3 id="4-7-实战演练"><a href="#4-7-实战演练" class="headerlink" title="4.7 实战演练"></a>4.7 实战演练</h3><p>创建目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir playground<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230317151028103.png" alt="image-20230317151028103"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd playground<br>mkdir dir1 dir2<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230317151130584.png" alt="image-20230317151130584"></p><p>复制文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp /etc/passwd .<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230317151228702.png" alt="image-20230317151228702"></p><p>查看文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -l<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230317151305530.png" alt="image-20230317151305530"></p><p>重复操作复制命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp -v /etc/passwd .<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230324081055206.png" alt="image-20230324081055206"></p><p>加上交互信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp -i /etc/passwd .<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230324081235903.png" alt="image-20230324081235903"></p><p>重命名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv passwd fun<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230324081553017.png" alt="image-20230324081553017"></p><p>移动文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv fun dir1<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230324081700946.png" alt="image-20230324081700946"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv /dir1/fun  dir2<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230324081830661.png" alt="image-20230324081830661"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv ~/dir2/fun .<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230324081931795.png" alt="image-20230324081931795"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01 - Relational Model &amp; Relational Algebra</title>
    <link href="/2023/03/01/01-Relational-Model-Relational-Algebra/"/>
    <url>/2023/03/01/01-Relational-Model-Relational-Algebra/</url>
    
    <content type="html"><![CDATA[<h1 id="01-Relational-Model-amp-Relational-Algebra"><a href="#01-Relational-Model-amp-Relational-Algebra" class="headerlink" title="01 - Relational Model &amp; Relational Algebra"></a>01 - Relational Model &amp; Relational Algebra</h1><h2 id="1-Database"><a href="#1-Database" class="headerlink" title="1.Database"></a>1.Database</h2><p>A database is an organized collection of inter-related data that models some aspects of the real-world.</p><p>Distinguish  “database” with “database management systems”(DBMS).</p><p>DBMS is the software that manage a database.</p><h2 id="2-Flat-File-Strawman"><a href="#2-Flat-File-Strawman" class="headerlink" title="2.Flat File Strawman"></a>2.Flat File Strawman</h2><p>Database is stored as comma-separated value(CSV) files that DBMS manages.</p><p>Each entity has its own set of attributes ,so in each file,different records are delimited by new lines, while each of the corresponding attributes within a record are delimited by a comma.</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230301171931187.png" alt="image-20230301171931187"></p><h2 id="3-Database-Management-System"><a href="#3-Database-Management-System" class="headerlink" title="3.Database Management System"></a>3.Database Management System</h2><p>A DBMS is an software that allows applications to store and analyze information in a database.</p><h3 id="Function"><a href="#Function" class="headerlink" title="Function:"></a>Function:</h3><ul><li>Definition</li><li>Creation</li><li>Querying</li><li>Update</li><li>Administration of databases</li></ul><h3 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h3><ul><li>relational(most common)</li><li>NoSQL(key/value,graph)</li><li>Array/Matrix/Vectors</li></ul><p>A schema is a description of a particular collection of data based on a data model.</p><h2 id="4-Relational-Model"><a href="#4-Relational-Model" class="headerlink" title="4.Relational Model"></a>4.Relational Model</h2><p>The relational model defines a database abstraction based on realtions to avoid maintenance overhead.</p><p>It has three key points:</p><ul><li>Store database in simple <strong>data structure</strong></li><li>Access data through <strong>high-level language</strong>,DBMS figures out best execution strategy.</li><li><strong>Physical storage</strong> left up to the DBMS simplementation.</li></ul><h3 id="Three-Concept-of-Realtional-Data-Model"><a href="#Three-Concept-of-Realtional-Data-Model" class="headerlink" title="Three Concept of Realtional Data Model:"></a>Three Concept of Realtional Data Model:</h3><ul><li><strong>Structure</strong>:The definition of relations and their contents.This is the attributes the relations have and the  values that those attributes can hold.</li><li><strong>Integrity</strong>:Ensure the database’s contents satisfy constraints.</li><li><strong>Manipulation</strong>:How to access and modify a database’s contents.</li></ul><p>A <strong>relation</strong> is an unordered set that contain the relationship of attributes that represent entities.</p><p>A <strong>tuple</strong> is a set of attribute value(also known as its domain) in the relation.</p><h3 id="Keys"><a href="#Keys" class="headerlink" title="Keys:"></a>Keys:</h3><ul><li>Primary key uniquely identifies a single tuple.</li><li>Foreigin key specifies that an attributes from one relation has to map to a tuple in another relation.</li></ul><h2 id="5-Data-Manipulation-Language-DMLs"><a href="#5-Data-Manipulation-Language-DMLs" class="headerlink" title="5.Data Manipulation Language(DMLs)"></a>5.Data Manipulation Language(DMLs)</h2><p>Two classes of language to store and retrieve information from a database.</p><ul><li><strong>Procedural:</strong>The query specifies the (high-level) strategy to find the desired result based on sets / bags</li><li><strong>Non-Procedural(Declarative)</strong>:The query specifies only what data is wanted and not how to find it.</li></ul><h2 id="6-Relational-Algebra"><a href="#6-Relational-Algebra" class="headerlink" title="6.Relational Algebra"></a>6.Relational Algebra</h2><p>Based on set algebra</p><p><strong>σ</strong> ：Select</p><p><strong>π</strong> ：Projection</p><p><strong>∪</strong> ：Union</p><p><strong>∩</strong>： Intersection</p><p><strong>–</strong> ：Difference</p><p><strong>×</strong> ：Product</p><p><strong>⋈</strong> ：Join</p><h3 id="Select"><a href="#Select" class="headerlink" title="Select:"></a>Select:</h3><p>Choose a subset of the tuples from a  relation that satisfies a selection predicate.</p><p>Syntax: <script type="math/tex">σ_{predicate}(R)</script></p><p>Example: <script type="math/tex">{\sigma}_{a\underline{}i d ='a2'}(R)</script></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> R <span class="hljs-keyword">WHERE</span> a_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a2&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="Projection"><a href="#Projection" class="headerlink" title="Projection:"></a>Projection:</h3><p>Projection takes in a relation and outputs a relation with tuples that contain only specified attributes. You</p><p>can rearrange the ordering of the attributes in the input relation as well as manipulate the values.</p><p>Syntax:<script type="math/tex">\pi_{A1,A2,...,An}(R)</script></p><p>Example:<script type="math/tex">\pi_{b\underline{ }id,a\underline{ }id}(\sigma_{a\underline{ }id='a}(R))</script></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> b_id<span class="hljs-number">-100</span>,a_id <span class="hljs-keyword">FROM</span> R <span class="hljs-keyword">WHERE</span> a_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a2&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="Union"><a href="#Union" class="headerlink" title="Union:"></a>Union:</h3><p>Union takes in two relations and outputs a relation that contains all tuples that appear in at least one of the</p><p>input relations. Note: The two input relations have to have the exact same attributes.</p><p>Syntax:<script type="math/tex">R\cap S</script></p>]]></content>
    
    
    <categories>
      
      <category>15-445</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Go并发简介</title>
    <link href="/2023/02/24/Go%E5%B9%B6%E5%8F%91%E7%AE%80%E4%BB%8B/"/>
    <url>/2023/02/24/Go%E5%B9%B6%E5%8F%91%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Go并发简介"><a href="#Go并发简介" class="headerlink" title="Go并发简介"></a>Go并发简介</h1><h2 id="Go并发编程的困难"><a href="#Go并发编程的困难" class="headerlink" title="Go并发编程的困难"></a>Go并发编程的困难</h2><ol><li>在面对并发难题时，感觉无从下手，不知道<strong>该用什么并发原语来解决问题</strong>。</li></ol><ol><li>如果多个并发原语都可以解决问题，那么，<strong>究竟哪个是最优解呢</strong>？比如说是用互斥锁，还是</li></ol><p>用 Channel。</p><ol><li><strong>不知道如何编排并发任务</strong>。并发编程不像是传统的串行编程，程序的运行存在着很大的不确</li></ol><p>定性。这个时候，就会面临一个问题，<strong>怎么才能让相应的任务按照你设想的流程运行呢</strong>？</p><ol><li>有时候，按照正常理解的并发方式去实现的程序，结果莫名其妙就 panic 或者死锁了，<strong>排</strong></li></ol><p><strong>查起来非常困难</strong>。</p><ol><li><strong>已知的并发原语都不能解决并发问题</strong>，程序写起来异常复杂，而且代码混乱，容易出错。</li></ol><h2 id="Go并发编程能力"><a href="#Go并发编程能力" class="headerlink" title="Go并发编程能力"></a>Go并发编程能力</h2><p>两条主线：</p><ul><li><strong>知识主线</strong></li><li><strong>学习主线</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230224101635312.png" alt="image-20230224101635312"></p><h3 id="基本并发元语："><a href="#基本并发元语：" class="headerlink" title="基本并发元语："></a>基本并发元语：</h3><p>Mutex、RWMutex、Waitgroup、Cond、Pool、Context 等标准库中的并发原语</p><h3 id="原子操作："><a href="#原子操作：" class="headerlink" title="原子操作："></a>原子操作：</h3><p>Go 标准库中提供的原子操作</p><h3 id="Channel："><a href="#Channel：" class="headerlink" title="Channel："></a>Channel：</h3><p>Channel 类型是 Go 语言独特的类型，因为比较新，所以难以掌握。</p><h2 id="扩展并发元语："><a href="#扩展并发元语：" class="headerlink" title="扩展并发元语："></a>扩展并发元语：</h2><p>Go 开发组不准备在标准库中扩充并发原语了，但是还有一些并发原语应用广泛，比如信号量、SingleFlight、循环栅栏、ErrGroup 等。掌握了它们，就可以在处理一些并发问题时，取得事半功倍的效果。</p><h3 id="分布式并发元语："><a href="#分布式并发元语：" class="headerlink" title="分布式并发元语："></a>分布式并发元语：</h3><p>etcd 实现的一些分布式并发原语，比如 Leader 选举、分布式互斥锁、分布式读写锁、分布式队列等，在处理分布式场景的并发问题时，特别有用。</p><h2 id="资源并发访问问题："><a href="#资源并发访问问题：" class="headerlink" title="资源并发访问问题："></a>资源并发访问问题：</h2><h3 id="进程和线程："><a href="#进程和线程：" class="headerlink" title="进程和线程："></a>进程和线程：</h3><p>进程是资源分配的最小单位，线程是CPU调度的最小单位。</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230224103234848.png" alt="image-20230224103234848"></p><p><strong>进程=火车，线程=车厢</strong></p><ul><li>线程在进程下行进（单纯的车厢无法运行）</li><li>一个进程可以包含多个线程（一辆火车可以有多个车厢）</li><li>不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）</li><li>同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）</li><li>进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）</li><li>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）</li><li>进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）</li><li>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－”互斥锁”</li><li>进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”</li></ul><h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><p>在Java和C++开发中，实现并发编程需要自己维护一个线程池，需要自己包装任务，还需要自己去调用线程执行任务并且切换上下文，非常痛苦！</p><p>goroutine就是这种机制，类似于线程，由runtime调度和管理。</p><h3 id="使用goroutine"><a href="#使用goroutine" class="headerlink" title="使用goroutine"></a>使用goroutine</h3><p>在调用函数前加上go关键字</p><h3 id="启动单个goroutine"><a href="#启动单个goroutine" class="headerlink" title="启动单个goroutine"></a>启动单个goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;hello goroutine&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>hello()<br>fmt.Println(<span class="hljs-string">&quot;main go routine done!&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>顺序执行的结果：</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230224111809045.png" alt="image-20230224111809045"></p><p>在hello前加上go关键字</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> hello()<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230224111904021.png" alt="image-20230224111904021"></p><p>没有打印<code>hello goroutine</code></p><p>Why?</p><p>程序启动时，会为<code>main()</code>函数创建一个默认的<code>goroutine</code>,        <code>main()</code>函数返回时，该<code>goroutine</code>结束，所有<code>main()</code>中启动的<code>goroutine()</code>会一同结束。</p><p>能不能想办法，让main函数等等hello</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;hello goroutine&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> hello()<br>fmt.Println(<span class="hljs-string">&quot;main go routine done!&quot;</span>)<br>time.Sleep(time.Second)<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230224114542872.png" alt="image-20230224114542872"></p><p>此时，创建新的goroutine需要花费一定时间，main中的goroutine会继续执行</p><h3 id="启动多个goroutine"><a href="#启动多个goroutine" class="headerlink" title="启动多个goroutine"></a>启动多个goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello2</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>fmt.Println(<span class="hljs-string">&quot;Hello Goroutine!&quot;</span>, i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> hello2(i)<br>&#125;<br>wg.Wait()<br>&#125;<br><br></code></pre></td></tr></table></figure><p>执行结果：<strong>多次执行的结果并不相同</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230224172920481.png" alt="image-20230224172920481"></p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230224173005952.png" alt="image-20230224173005952"></p><p>因为10个goroutine是并发执行的，而goroutine的调度是随机的。</p><p>主协程退出后，其他任务是否执行？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 合起来写</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> &#123;<br>i++<br>fmt.Printf(<span class="hljs-string">&quot;new goroutine: i = %d\n&quot;</span>, i)<br>time.Sleep(time.Second)<br>&#125;<br>&#125;()<br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> &#123;<br>i++<br>fmt.Printf(<span class="hljs-string">&quot;main goroutine: i = %d\n&quot;</span>, i)<br>time.Sleep(time.Second)<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230224173334444.png" alt="image-20230224173334444"></p><h2 id="runtime包"><a href="#runtime包" class="headerlink" title="runtime包"></a>runtime包</h2><h3 id="runtime-Gosched"><a href="#runtime-Gosched" class="headerlink" title="runtime.Gosched()"></a>runtime.Gosched()</h3><p>这个函数的作用是让当前goroutine让出CPU，好让其它的goroutine获得执行的机会。同时，当前的goroutine也会在未来的某个时间点继续运行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++ &#123;<br>fmt.Println(s)<br>&#125;<br>&#125;(<span class="hljs-string">&quot;world&quot;</span>)<br><br><span class="hljs-comment">// 主协程</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++ &#123;<br><span class="hljs-comment">//runtime.Gosched()</span><br>fmt.Println(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="runtime-Goexit"><a href="#runtime-Goexit" class="headerlink" title="runtime.Goexit()"></a>runtime.Goexit()</h3><p>runtime.Goexit函数在终止调用它的Goroutine的运行之前会先执行该Groution中还没有执行的defer语句。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;runtime&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;A.defer&quot;</span>)<br>        <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;B.defer&quot;</span>)<br>            <span class="hljs-comment">// 结束协程</span><br>            runtime.Goexit()<br>            <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;C.defer&quot;</span>)<br>            fmt.Println(<span class="hljs-string">&quot;B&quot;</span>)<br>        &#125;()<br>        fmt.Println(<span class="hljs-string">&quot;A&quot;</span>)<br>    &#125;()<br>    <span class="hljs-keyword">for</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="runtime-GoMAXPROCS"><a href="#runtime-GoMAXPROCS" class="headerlink" title="runtime.GoMAXPROCS()"></a>runtime.GoMAXPROCS()</h3><p>Go运行时的调度器使用GOMAXPROCS参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。</p><p>Go语言中可以通过runtime.GOMAXPROCS()函数设置当前程序并发时占用的CPU逻辑核心数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;runtime&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>fmt.Println(<span class="hljs-string">&quot;A:&quot;</span>, i)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>fmt.Println(<span class="hljs-string">&quot;B:&quot;</span>, i)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>runtime.GOMAXPROCS(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">go</span> a()<br><span class="hljs-keyword">go</span> b()<br>time.Sleep(time.Second)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>此时使用的CPU核心为1核，任务会挨个完成。</p><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>单纯并发无意义，出现函数与函数的数据交换时，才能体现并发执行函数的意义。</p><p>如果说goroutine是Go程序并发的执行体，channel就是它们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。</p><p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个<strong>传送带或者队列</strong>，总是遵循<strong>先入先出（First In First Out）的规则</strong>，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p><h3 id="channel类型"><a href="#channel类型" class="headerlink" title="channel类型"></a>channel类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ch1 <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>   <span class="hljs-comment">// 声明一个传递整型的通道</span><br><span class="hljs-keyword">var</span> ch2 <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>  <span class="hljs-comment">// 声明一个传递布尔型的通道</span><br><span class="hljs-keyword">var</span> ch3 <span class="hljs-keyword">chan</span> []<span class="hljs-type">int</span> <span class="hljs-comment">// 声明一个传递int切片的通道</span><br></code></pre></td></tr></table></figure><h3 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a>创建channel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ch <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span><br>fmt.Println(ch) <span class="hljs-comment">//结果为nil</span><br></code></pre></td></tr></table></figure><p>通道声明之后需要使用make函数初始化之后才可以使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> 元素类型, [缓冲大小]) <span class="hljs-comment">// 缓冲可以自选</span><br><br>ch4 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>ch5 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br>ch6 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> []<span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure><h3 id="channel操作"><a href="#channel操作" class="headerlink" title="channel操作"></a>channel操作</h3><p>通道有<strong>发送（send）、接收(receive）和关闭（close）</strong>三种操作。</p><p>发送和接收都使用<code>&lt;-</code>符号。</p><p>初始化一个通道</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure><p>发送</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ch &lt;- <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>接受</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">x := &lt;-ch <span class="hljs-comment">//从通道内接受值并赋给变量x</span><br>&lt;-ch      <span class="hljs-comment">//从ch中接受值，忽略结果</span><br></code></pre></td></tr></table></figure><p>关闭</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">close</span>(ch)<br></code></pre></td></tr></table></figure><p>只有在goroutine所有数据都发送完毕时，才能关闭通道。</p><p>通道是可以被垃圾回收机制回收的，所以不一定需要关闭，但是文件操作是一定要关闭通道的。</p><p><strong>关闭通道后，会有以下注意点：</strong></p><ul><li>关闭后的通道再进行发送，会panic</li><li>关闭后的通道可以继续接受值，知道通道为空</li><li>关闭的没有值的通道接受到的为类型对应的零值</li><li>关闭一个已经关闭的通道，会panic</li></ul><h3 id="无缓冲通道"><a href="#无缓冲通道" class="headerlink" title="无缓冲通道"></a>无缓冲通道</h3><p>无缓冲通道又称为阻塞通道</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    ch &lt;- <span class="hljs-number">10</span><br>    fmt.Println(<span class="hljs-string">&quot;发送成功&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>此段代码编译可以通过，但是执行时会出现以下错误</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230224212700464.png" alt="image-20230224212700464"></p><p>这是死锁错误，因为我们使用的是<code>ch := make(chan int)</code>，建立的是无缓冲通道，只有在有人接收值的时候才能够发送值。</p><p>上述代码<code>ch &lt;- 10</code>会造成死锁。</p><p>如何解决？只有在接收的时候，才能发送，那我们就启动一个协程去接收值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">recv</span><span class="hljs-params">(c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>    ret := &lt;-c<br>    fmt.Println(<span class="hljs-string">&quot;接收成功&quot;</span>, ret)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">go</span> recv(ch) <span class="hljs-comment">// 启用goroutine从通道接收值</span><br>    ch &lt;- <span class="hljs-number">10</span><br>    fmt.Println(<span class="hljs-string">&quot;发送成功&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>无缓冲通道上的发送操作会阻塞，直到另一个goroutine在该通道上执行接收操作，这时值才能发送成功，两个goroutine将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个goroutine在该通道上发送一个值。</p><p>使用无缓冲通道进行通信将导致发送和接收的goroutine同步化。</p><p>因此，无缓冲通道也被称为<strong>同步通道</strong>。</p><h3 id="有缓冲的通道"><a href="#有缓冲的通道" class="headerlink" title="有缓冲的通道"></a>有缓冲的通道</h3><p>使用make初始化通道时，指定通道容量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 创建一个容量为1的有缓冲区通道</span><br>  ch &lt;- <span class="hljs-number">10</span><br>  fmt.Println(<span class="hljs-string">&quot;发送成功&quot;</span>)<br>  fmt.Println(<span class="hljs-built_in">len</span>(ch))<br>fmt.Println(<span class="hljs-built_in">cap</span>(ch))<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Close"><a href="#Close" class="headerlink" title="Close()"></a>Close()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>            c &lt;- i<br>        &#125;<br>        <span class="hljs-built_in">close</span>(c)<br>    &#125;()<br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">if</span> data, ok := &lt;-c; ok &#123;<br>            fmt.Println(data)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;main结束&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何优雅的从通道循环取值"><a href="#如何优雅的从通道循环取值" class="headerlink" title="如何优雅的从通道循环取值"></a>如何优雅的从通道循环取值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    ch2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    <span class="hljs-comment">// 开启goroutine将0~100的数发送到ch1中</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>            ch1 &lt;- i<br>        &#125;<br>        <span class="hljs-built_in">close</span>(ch1)<br>    &#125;()<br>    <span class="hljs-comment">// 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> &#123;<br>            i, ok := &lt;-ch1 <span class="hljs-comment">// 通道关闭后再取值ok=false</span><br>            <span class="hljs-keyword">if</span> !ok &#123;<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>            ch2 &lt;- i * i<br>        &#125;<br>        <span class="hljs-built_in">close</span>(ch2)<br>    &#125;()<br>    <span class="hljs-comment">// 在主goroutine中从ch2中接收值打印</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> ch2 &#123; <span class="hljs-comment">// 通道关闭后会退出for range循环</span><br>        fmt.Println(i)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a>单向通道</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">counter</span><span class="hljs-params">(out <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>        out &lt;- i<br>    &#125;<br>    <span class="hljs-built_in">close</span>(out)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">squarer</span><span class="hljs-params">(out <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>, in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> in &#123;<br>        out &lt;- i * i<br>    &#125;<br>    <span class="hljs-built_in">close</span>(out)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printer</span><span class="hljs-params">(in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> in &#123;<br>        fmt.Println(i)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    ch2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">go</span> counter(ch1)<br>    <span class="hljs-keyword">go</span> squarer(ch2, ch1)<br>    printer(ch2)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><h3 id="select多路复用"><a href="#select多路复用" class="headerlink" title="select多路复用"></a>select多路复用</h3><p>试想，现有多个通道需要接收数据，可以怎么写？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//使用遍历</span><br><span class="hljs-keyword">for</span>&#123;<br>  data,ok := &lt;-ch1<br>  data,ok := &lt;-ch2<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法可以实现多通道接受数据的请求，但是执行效率太低，go自带了select语句，可以同时响应多个通道的操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-chan1:<br>       <span class="hljs-comment">// 如果chan1成功读到数据，则进行该case处理语句</span><br>    <span class="hljs-keyword">case</span> chan2 &lt;- <span class="hljs-number">1</span>:<br>       <span class="hljs-comment">// 如果成功向chan2写入数据，则进行该case处理语句</span><br>    <span class="hljs-keyword">default</span>:<br>       <span class="hljs-comment">// 如果上面都没有成功，则进入default处理流程</span><br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>select可以同时监听一个或多个channel，直到其中一个channel ready</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test1</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;<br>time.Sleep(time.Second * <span class="hljs-number">5</span>)<br>ch &lt;- <span class="hljs-string">&quot;test1&quot;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test2</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;<br>time.Sleep(time.Second * <span class="hljs-number">2</span>)<br>ch &lt;- <span class="hljs-string">&quot;test2&quot;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 建立两个通道</span><br>output1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>output2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br><br><span class="hljs-keyword">go</span> test1(output1)<br><span class="hljs-keyword">go</span> test2(output2)<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> s1 := &lt;-output1:<br>fmt.Println(<span class="hljs-string">&quot;s1 = &quot;</span>, s1)<br><span class="hljs-keyword">case</span> s2 := &lt;-output2:<br>fmt.Println(<span class="hljs-string">&quot;s2 = &quot;</span>, s2)<br><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>如果多个channel同时ready，则随机选择一个执行</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">// 创建2个管道</span><br>   int_chan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br>   string_chan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">1</span>)<br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      <span class="hljs-comment">//time.Sleep(2 * time.Second)</span><br>      int_chan &lt;- <span class="hljs-number">1</span><br>   &#125;()<br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      string_chan &lt;- <span class="hljs-string">&quot;hello&quot;</span><br>   &#125;()<br>   <span class="hljs-keyword">select</span> &#123;<br>   <span class="hljs-keyword">case</span> value := &lt;-int_chan:<br>      fmt.Println(<span class="hljs-string">&quot;int:&quot;</span>, value)<br>   <span class="hljs-keyword">case</span> value := &lt;-string_chan:<br>      fmt.Println(<span class="hljs-string">&quot;string:&quot;</span>, value)<br>   &#125;<br>   fmt.Println(<span class="hljs-string">&quot;main结束&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>可以用于判断管道是否存满</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// 判断管道有没有存满</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">// 创建管道</span><br>   output1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">10</span>)<br>   <span class="hljs-comment">// 子协程写数据</span><br>   <span class="hljs-keyword">go</span> write(output1)<br>   <span class="hljs-comment">// 取数据</span><br>   <span class="hljs-keyword">for</span> s := <span class="hljs-keyword">range</span> output1 &#123;<br>      fmt.Println(<span class="hljs-string">&quot;res:&quot;</span>, s)<br>      time.Sleep(time.Second)<br>   &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">write</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;<br>   <span class="hljs-keyword">for</span> &#123;<br>      <span class="hljs-keyword">select</span> &#123;<br>      <span class="hljs-comment">// 写数据</span><br>      <span class="hljs-keyword">case</span> ch &lt;- <span class="hljs-string">&quot;hello&quot;</span>:<br>         fmt.Println(<span class="hljs-string">&quot;write hello&quot;</span>)<br>      <span class="hljs-keyword">default</span>:<br>         fmt.Println(<span class="hljs-string">&quot;channel full&quot;</span>)<br>      &#125;<br>      time.Sleep(time.Millisecond * <span class="hljs-number">500</span>)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="并发安全和锁"><a href="#并发安全和锁" class="headerlink" title="并发安全和锁"></a>并发安全和锁</h2><h3 id="竞态问题"><a href="#竞态问题" class="headerlink" title="竞态问题"></a>竞态问题</h3><p>多个goroutine同时操作同一资源，存在数据竞争，结果与预期不符</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-type">int64</span><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++ &#123;<br>        x = x + <span class="hljs-number">1</span><br>    &#125;<br>    wg.Done()<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    wg.Add(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">go</span> add()<br>    <span class="hljs-keyword">go</span> add()<br>    wg.Wait()<br>    fmt.Println(x)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个goroutine可以访问共享资源。Go语言中使用sync包的Mutex类型来实现互斥锁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-type">int64</span><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-keyword">var</span> lock sync.Mutex<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++ &#123;<br>        lock.Lock() <span class="hljs-comment">// 加锁</span><br>        x = x + <span class="hljs-number">1</span><br>        lock.Unlock() <span class="hljs-comment">// 解锁</span><br>    &#125;<br>    wg.Done()<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    wg.Add(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">go</span> add()<br>    <span class="hljs-keyword">go</span> add()<br>    wg.Wait()<br>    fmt.Println(x)<br>&#125;<br></code></pre></td></tr></table></figure><p>使用互斥锁能够保证同一时间有且只有一个goroutine进入临界区，其他的goroutine则在等待锁；当互斥锁释放后，等待的goroutine才可以获取锁进入临界区，多个goroutine同时等待一个锁时，唤醒的策略是随机的。</p><h3 id="读写互斥锁"><a href="#读写互斥锁" class="headerlink" title="读写互斥锁"></a>读写互斥锁</h3><p><strong>互斥锁是完全互斥的</strong>，但是有很多实际的场景下是读多写少的，<u>当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的</u>，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用sync包中的<strong>RWMutex类型。</strong></p><p>读写锁分为两种：<strong>读锁和写锁。</strong></p><p>当一个goroutine获取读锁之后，其他的goroutine如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个goroutine获取写锁之后，其他的goroutine无论是获取读锁还是写锁都会等待。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    x      <span class="hljs-type">int64</span><br>    wg     sync.WaitGroup<br>    lock   sync.Mutex<br>    rwlock sync.RWMutex<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">write</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// lock.Lock()   // 加互斥锁</span><br>    rwlock.Lock() <span class="hljs-comment">// 加写锁</span><br>    x = x + <span class="hljs-number">1</span><br>    time.Sleep(<span class="hljs-number">10</span> * time.Millisecond) <span class="hljs-comment">// 假设读操作耗时10毫秒</span><br>    rwlock.Unlock()                   <span class="hljs-comment">// 解写锁</span><br>    <span class="hljs-comment">// lock.Unlock()                     // 解互斥锁</span><br>    wg.Done()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// lock.Lock()                  // 加互斥锁</span><br>    rwlock.RLock()               <span class="hljs-comment">// 加读锁</span><br>    time.Sleep(time.Millisecond) <span class="hljs-comment">// 假设读操作耗时1毫秒</span><br>    rwlock.RUnlock()             <span class="hljs-comment">// 解读锁</span><br>    <span class="hljs-comment">// lock.Unlock()                // 解互斥锁</span><br>    wg.Done()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    start := time.Now()<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> write()<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> read()<br>    &#125;<br><br>    wg.Wait()<br>    end := time.Now()<br>    fmt.Println(end.Sub(start))<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Concurrency</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>08-聚合函数:高效进行分组统计</title>
    <link href="/2023/02/19/08-%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0-%E9%AB%98%E6%95%88%E8%BF%9B%E8%A1%8C%E5%88%86%E7%BB%84%E7%BB%9F%E8%AE%A1/"/>
    <url>/2023/02/19/08-%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0-%E9%AB%98%E6%95%88%E8%BF%9B%E8%A1%8C%E5%88%86%E7%BB%84%E7%BB%9F%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="08-聚合函数-高效进行分组统计"><a href="#08-聚合函数-高效进行分组统计" class="headerlink" title="08-聚合函数:高效进行分组统计"></a>08-聚合函数:高效进行分组统计</h1><p>MySQL中的五种常用函数<code>SUM()</code>、<code>AVG()</code>、<code>MAX()</code>、<code>MIN()</code>、<code>COUNT()</code></p><p>超市经营者提出，他们需要统计某个门店，每天、每个单品的销售情况，包括销售数量和销售金额等。</p><p><strong>三个数据表</strong></p><p><strong>销售明细表(demo.transactiondetails)</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230221135311992.png" alt="image-20230221135311992"></p><p><strong>销售单头(demo.transactionhead)</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230302151635149.png" alt="image-20230302151635149"></p><p><strong>商品信息表（demo.goodsmaster）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230302151656986.png" alt="image-20230302151656986"></p><h2 id="SUM"><a href="#SUM" class="headerlink" title="SUM()"></a>SUM()</h2><p>SUM()函数返回指定字段值的和</p><p>查询用户某个门店，每天，每种商品的销售总计数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select <br>left(b.transdate,10),<br>    c.goodsname,<br>    sum(a.quantity),<br>    sum(a.salesvalue)<br>from<br>demo.transactiondetails a<br>join<br>demo.transactionhead b on (a.transactionid = b.transactionid)<br>join<br>demo.goodsmaster c on (a.itemnumber= c.itemnumber)<br>group by left(b.transdate,10),c.goodsname<br>order by left(b.transdate,10),c.goodsname;<br></code></pre></td></tr></table></figure><p>引入关键字<code>left</code>和<code>ORDER BY</code></p><h3 id="LEFT-str-n"><a href="#LEFT-str-n" class="headerlink" title="LEFT(str,n)"></a>LEFT(str,n)</h3><p>返回字符串str<strong>最左边的n个字符</strong>，<code>left(a.transdate,10)</code>，表示返回交易时间字符串最左边的10个字符。在MySQL中，<code>DATETIME</code>的格式为：YYYYY-MM-DD，一共是10个字符。</p><h3 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h3><p>按照指定字段排序</p><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><p>第一步：完成三个表的连接</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230302152449705.png" alt="image-20230302152449705" style="zoom:50%;" /></p><p>第二步：对结果集<strong>按照交易时间和商品名称</strong>进行分组，我们可以分成下面 4 组</p><p>第一组：</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230302152525599.png" alt="image-20230302152525599" style="zoom:50%;" /></p><p>第二组：</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230302152726725.png" alt="image-20230302152726725" style="zoom:50%;" /></p><p>第三组：</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230302152755137.png" alt="image-20230302152755137" style="zoom:50%;" /></p><p>第四组：</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230302152811191.png" alt="image-20230302152811191"></p><p>第三步：对各组的销售数量和销售金额进行统计，并且按照交易日期和商品名称排序。</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230219102927119.png" alt="image-20230219102927119"></p><p>如果用户要知道全部商品销售的总计数量和总计金额，我们可以把数据集的整体看做一张表，进行计算。</p><p>这样就不需要从关联表中获取数据，也不需要连接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br><span class="hljs-built_in">sum</span>(quantity),<br><span class="hljs-built_in">sum</span>(salesvalue)<br><span class="hljs-keyword">from</span><br>demo.transactiondetails;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230309140757400.png" alt="image-20230309140757400"></p><h2 id="AVG-、MAX-、MIN"><a href="#AVG-、MAX-、MIN" class="headerlink" title="AVG()、MAX()、MIN()"></a>AVG()、MAX()、MIN()</h2><h3 id="1-AVG"><a href="#1-AVG" class="headerlink" title="1.AVG()"></a>1.AVG()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select <br>left(a.transdate,10),<br>c.goodsname,<br>avg(b.quantity),<br>avg(b.salesvalue)<br>from<br>demo.transactionhead a<br>join<br>demo.transactiondetails b on (a.transactionid = b.transactionid)<br>join<br>demo.goodsmaster c on(b.itemnumber = c.itemnumber)<br>group by left(a.transdate,10),c.goodsname<br>order by left(a.transdate,10),c.goodsname;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230219105728594.png" alt="image-20230219105728594"></p><h3 id="2-MAX-、MIN"><a href="#2-MAX-、MIN" class="headerlink" title="2.MAX()、MIN()"></a>2.MAX()、MIN()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select <br>left(a.transdate,10),<br>MAX(b.quantity),<br>MAX(b.salesvalue)<br>from<br>demo.transactionhead a<br>join <br>demo.transactiondetails b on(a.transactionid = b.transactionid)<br>join<br>demo.goodsmaster c on (b.itemnumber = c.itemnumber)<br>group by left(a.transdate,10)<br>order by left(a.transdate,10);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230219110136113.png" alt="image-20230219110136113"></p><p><strong>注意</strong>：MAX(b.quantity)和MAX(b.salesvalue)算出的结果不一定是同一条记录的数据。</p><p>实际上，MySQL是分开计算的。</p><p>查询中用了3个相互关联的表：销售流水明细表、销售流水单头表、商品信息表，三张表连接完成后，MySQL进行了分组。</p><p>第一组：<img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230309141610407.png" alt="image-20230309141610407" style="zoom:50%;" /></p><p>第二组：</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230309141650891.png" alt="image-20230309141650891" style="zoom:50%;" /></p><p>第一组，最大数量在第2条记录中，是5，最大金额在第一条记录中，是178。</p><p>第二主中，最大数量出现在第4条记录，是10，最大金额则出现在第1条记录中，是267。</p><p>所以，MAX(字段)这个函数返回分组集中最大的那个值。如果查询MAX(字段1)和MAX(字段2)，他们是相互独立、分别计算的，<strong>千万不要认为结果在同一条记录上！！！！！</strong></p><h2 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT()"></a>COUNT()</h2><p>通过COUNT()了解数据集的大小，对于系统优化十分重要。</p><p>用户数量增多，系统会出现卡顿问题。</p><p>引入分页策略。</p><h3 id="分页策略"><a href="#分页策略" class="headerlink" title="分页策略"></a>分页策略</h3><p>不将查询结果一次性全部返回客户端，而是根据屏幕大小，计算可以显示的记录数，每次返回用户电脑屏幕可以显示的数据集。</p><p>COUNT函数的两种情况：</p><ul><li>COUNT(*):统计一共有多少条记录</li><li>COUNT(字段):统计有多少个不为空的字段值</li></ul><h3 id="1-COUNT"><a href="#1-COUNT" class="headerlink" title="1.COUNT(*)"></a>1.COUNT(*)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * <br>from demo.transactiondetails<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230309150331158.png" alt="image-20230309150331158"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select count(*)<br>from demo.transactiondetails;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230309150518069.png" alt="image-20230309150518069"></p><p>一页可以显示30个数据，一共6个数据，所以就只有1页。</p><p>如果超市经营者想知道每天每种商品有几次销售，就需要按天、按商品名称，进行分组查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select <br>left (a.transdate,10),c.goodsname,count(*)<br>from<br>demo.transactionhead a<br>join<br>demo.transactiondetails b on(a.transactionid = b.transactionid)<br>join<br>demo.goodsmaster c on (b.itemnumber = c.itemnumber)<br>group by left(a.transdate,10),c.goodsname<br>order by left(a.transdate,10),c.goodsname;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230219115456110.png" alt="image-20230219115456110"></p><h3 id="2-COUNT-字段"><a href="#2-COUNT-字段" class="headerlink" title="2.COUNT(字段)"></a>2.COUNT(字段)</h3><p>COUNT(字段)用来统计分组这个字段的值出现了几次，如果字段是空，就不统计。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select *<br>from demo.goodsmaster<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230313224901874.png" alt="image-20230313224901874" style="zoom:50%;" /></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(goodsname)<br><span class="hljs-keyword">from</span> demo.goodsmaster;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230313225002459.png" alt="image-20230313225002459" style="zoom:50%;" /></p><p>统计字段“specification”，用COUNT(specification)，结果为1，空值不统计</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select COUNT(specification)<br>from demo.goodsmaster;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230313225317370.png" alt="image-20230313225317370" style="zoom:50%;" /></p><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07-条件语句：where和having的区分</title>
    <link href="/2023/01/17/07-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%EF%BC%9Awhere%E5%92%8Chaving%E7%9A%84%E5%8C%BA%E5%88%86/"/>
    <url>/2023/01/17/07-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%EF%BC%9Awhere%E5%92%8Chaving%E7%9A%84%E5%8C%BA%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="07-条件语句：where和having的区分"><a href="#07-条件语句：where和having的区分" class="headerlink" title="07-条件语句：where和having的区分"></a>07-条件语句：where和having的区分</h1><ul><li><code>where</code>是直接对表中的字段进行限定，来筛选结果</li><li><code>having</code>则需要跟分组关键字 <code>group by</code>一起使用，通过对分组字段和分组计算函数进行限定，来筛选结果</li></ul><p>虽然都是进行查询限定，但是如果用错场景，就会出现各种查询问题。</p><h2 id="一个实际查询需求"><a href="#一个实际查询需求" class="headerlink" title="一个实际查询需求"></a>一个实际查询需求</h2><p>查询单臂销售金额超过50元的商品。</p><p>直接查询商品的信息表demo.goodsmaster</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from demo.goodsmaster;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117213923810.png" alt="image-20230117213923810"></p><p>查看销售明细表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from demo.trans;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117214659364.png" alt="image-20230117214659364"></p><ul><li>第一步：使用where查询</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select distinct b.goodsname<br>from demo.trans as a<br>join demo.goodsmaster as b<br>on (a.itemnumber = b.itemnumber)<br>where a.salesvalue &gt; 50;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117214841317.png" alt="image-20230117214841317"></p><ul><li>第二步：使用having进行查询</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select b.goodsname<br>from demo.trans as a<br>join demo.goodsmaster as b<br>on (a.itemnumber = b.itemnumber)<br>group by b.goodsname<br>having max(a.salesvalue)&gt;50;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117215231046.png" alt="image-20230117215231046"></p><p>查询结果相同，区别是什么？</p><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>首先，从demo.trans中抽取满足条件的”a.salesvalue&gt;50”记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * <br>from demo.trans as a<br>where a.salesvalue &gt; 50;<br></code></pre></td></tr></table></figure><p>为了获取到销售信息所对应的商品名称，需要通过公共字段itemnumber与demo.goodsmaster进行关联，从demo.goodsmaster中获取商品名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select a.*,b.goodsname<br>from demo.trans a<br>join demo.goodsmaster b on (a.itemnumber = b.itemnumber)<br>where<br>a.salesvalue &gt; 50;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230118103818366.png" alt="image-20230118103818366"></p><p>此时查询商品名称，会出现重复记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select b.goodsname<br>from demo.trans a<br>join demo.goodsmaster b on (a.itemnumber = b.itemnumber)<br>where<br>a.salesvalue &gt; 50;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230118103906213.png" alt="image-20230118103906213"></p><p>为了消除重复语句，需要使用一个关键字：distinct，作用是返回唯一不同的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select distinct(b.goodsname)<br>from demo.trans a<br>join demo.goodsmaster b on (a.itemnumber = b.itemnumber)<br>where<br>a.salesvalue &gt; 50;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230118104026473.png" alt="image-20230118104026473"></p><p>where关键字的特点是，直接用表的字段对数据集进行筛选。</p><p>如果需要通过关联查询从其他的表获取需要的信息，那么执行时也是先通过where条件筛选，用筛选后的较小数据集进行连接。这样，连接过程中的资源占用较少，执行效率也高。</p><h3 id="having"><a href="#having" class="headerlink" title="having"></a>having</h3><p><code>having</code>不能单独使用，必须要和<code>group by</code>一起使用。</p><p>先查看一下数据内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from demo.trans<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230118105411235.png" alt="image-20230118105411235"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * <br>from demo.trans<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230118105446900.png" alt="image-20230118105446900"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from demo.operator;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230118105521051.png" alt="image-20230118105521051"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select<br>a.transdate, -- 交易时间<br>c.operatorname,-- 操作员<br>d.goodsname, -- 商品名称<br>b.quantity, -- 销售数量<br>  b.price, -- 价格<br>  b.salesvalue -- 销售金额<br>from<br>demo.transactionhead as a<br>join<br>demo.transactiondetails as b on (a.transactionid = b.transactionid)<br>join<br>demo.operator as c on (a.operatorid = c.operatorid)<br>join<br>demo.goodsmaster as d on (b.itemnumber = d.itemnumber);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230118105823850.png" alt="image-20230118105823850"></p><p>查看每天的销售数量和销售金额，按照一个字段transdate对数据进行分组和统计</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select <br>a.transdate<br>sum(b.quantity),<br>sum(b.salesvalue)<br>from<br>demo.transactionhead as a<br>join<br>demo.transactiondetails as b on (b.transactionid = b.transactionid)<br>group by a.transdate;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230118111603557.png" alt="image-20230118111603557"></p><p>查看每天每个收营员的销售数量和金额，按照transdate和operatorname分组和统计</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select <br>a.transdate,<br>c.opeatorname,<br>sum(b.quantity),<br>sum(b.salesvalue)<br>from<br>demo.transactionhead as a<br>join<br>demo.transactiondetails as b on (a.transactionid = b.transactionid)<br>join<br>demo.operator as c on (a.operatorid = c.operatorid)<br>group by a.transdate,c.operatorname;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230118112034275.png" alt="image-20230118112034275"></p><p>使用having，查询单笔金额超过50元的商品。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select b.goodsname<br>from demo.transactiondetails as a<br>join demo.goodsmaster as b<br>on (a.itemnumber = b.itemnumber)<br>group by b.goodsname <br>having max(a.salesvalue) &gt; 50;<br></code></pre></td></tr></table></figure><ul><li>第一步：将流水明细表和商品信息表通过公共字段<code>itemnumber</code>连接起来</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select <br>a.* , b.*<br>from <br>demo.transactiondetails a<br>join demo.goodsmaster b on (a.itemnumber = b.itemnumber);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230118112632295.png" alt="image-20230118112632295"></p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230118112703801.png" alt="image-20230118112703801"></p><ul><li><p>第二步：将结果按照商品名称分类</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230118112741572.png" alt="image-20230118112741572"></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230118112748296.png" alt="image-20230118112748296"></p><ul><li>第三步：对分组数据进行筛选，将salesvalue的最大值大于50的组筛选出来</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230118112932680.png" alt="image-20230118112932680"></p><ul><li>第四步：返回商品名称</li></ul><p>having的查询过程，首先将所有信息都准备好，然后包括从关联表中获取的信息，对数据集进行分组，形成一个包含所有需要的信息的数据集，然后再通过having条件的筛选，得到需要的数据</p><h2 id="如何正确使用where和having"><a href="#如何正确使用where和having" class="headerlink" title="如何正确使用where和having"></a>如何正确使用where和having</h2><p>两个典型区别</p><ul><li>如果需要通过连接从关联表中获取需要的数据，where是先筛选后连接，而having是先连接后筛选<ul><li>此方面，where比having更高效，因为where可以先筛选，获得较小的数据集再和关联表进行连接，这样占用的资源较少，执行效率也较高。having需要先把数据集准备好，将未被筛选的数据集进行关联，然后对大的数据集进行筛选，这样占用的资源较多，执行效率低</li></ul></li><li>where直接用表中字段筛选，不能使用分组的计算函数作为筛选条件；having必须与group by结合，可以把分组字段作为筛选条件</li></ul><p>having在对数据进行分组统计的时候，可以完成where不能完成的任务。where在group by之前，所以不能对分组结果进行筛选，而having在group by之后，可以使用分组字段和分组中的计算函数，对分组结果进行筛选。</p><p>超市经营者想看哪个收营员在哪天买了2单，就必须先分组才能筛选。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select <br>a.transdate,c.operatorname<br>from<br>demo.transactionhead as <br>join <br>demo.transactiondetails as b on (a.transactionid = b.transactionid)<br>join<br>demo.operator as c on (a.operatorid = c.operatorid)<br>group by a.transdate,c.operatorname<br>having count(*)=2;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230118114506259.png" alt="image-20230118114506259"></p><p>where和having的各自有缺点</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230118114532090.png" alt="image-20230118114532090"></p><p>where和having并不互相排斥，我们可以在一个查询内同时使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select <br>a.transdate,<br>c.operatorname,<br>d.goodsname,<br>b.price,<br>b.salesvalue<br>from<br>demo.transactionhead as a<br>join<br>demo.transactiondetails as b on (a.transactionid = b.transactionid)<br>join<br>demo.operator as c on (a.operatorid = c.operatorid)<br>join<br>demo.goodsmaster as d on (b.itemnumber = d.itemnumber);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230118114832239.png" alt="image-20230118114832239"></p><p>查询”2020-12-10”和”2020-12-11”这两天的收银金额超过100元的销售日期、收营员名称、销售数量和销售金额。</p><p>此需求需要将收营员和日期进行分组，可以通过group by和having进行查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select <br>a.transdate,<br>c.operatorname,<br>sum(b.quantity),<br>sum(b.salesvalue)<br>from<br>demo.transactionhead as a<br>join<br>demo.transactiondetails as b on (a.transactionid = b.transactionid)<br>join<br>demo.operator as c on (a.operatorid = c.operatorid)<br>group by a.transdate,c.operatorname<br>haing a.transdate in (&#x27;2020-12-10&#x27;,&#x27;2020-12-11&#x27;)<br>and sum(b.salesvalue) &gt; 100;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230118122250004.png" alt="image-20230118122250004"></p><p><code>a.transdate in (&#39;2020-12-10&#39;,&#39;2020-12-11&#39;)</code>可以用where来限定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select <br>a.transdate,<br>c.operatorname,<br>sum(b.quantity),<br>sum(b.salesvalue)<br>from<br>demo.transactionhead as a<br>join<br>demo.transactiondetails as b on (a.transactionid = b.transactionid)<br>join<br>demo.operator as c on (a.operatorid = c.operatorid)<br>where a.transdate in (&#x27;2020-12-12&#x27;,&#x27;2020-12-11&#x27;)<br>group by a.transdate,c.opertorname<br>having sum(b.salesvalue) &gt; 100;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230118122604240.png" alt="image-20230118122604240"></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06-外键和连接的关联查询</title>
    <link href="/2023/01/17/06-%E5%A4%96%E9%94%AE%E5%92%8C%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2/"/>
    <url>/2023/01/17/06-%E5%A4%96%E9%94%AE%E5%92%8C%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="06-外键和连接的关联查询"><a href="#06-外键和连接的关联查询" class="headerlink" title="06-外键和连接的关联查询"></a>06-外键和连接的关联查询</h1><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>将分散在多个不同的表里的数据查询出来的操作成为多表查询</p><p>多表查询查询需要建立起多个表之间的关联，才能去查询，同时还需要规避关联表查询中的常见错误</p><p>现项目的进货模块有两个数据表，分别是进货单头表（importhead）和进货单明细表（importdetails）</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117164605597.png" alt="image-20230117164605597"></p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117164605597.png" alt=""></p><p></p><p>需要查询一次进货的所有相关数据，就需要把两个表关联起来</p><p>将两个表关联，就需要2个重要的功能：外键（foreign key）和连接（join）</p><ul><li>外键需要在创建表的阶段就定义</li><li>连接可以通过相同意义的字段把两个表连接起来，用在查询阶段</li></ul><h2 id="创建外键"><a href="#创建外键" class="headerlink" title="创建外键"></a>创建外键</h2><p>外键是从表中引用主表数据的公共字段</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117171532393.png" alt="image-20230117171532393"></p><p>公共字段A是表A的主键，A是主表，B是从表，公共字段A是B表的外键</p><p>外键是通过外键约束定义的，必须在表中定义，包括哪个是外键字段，以及外键字段所引用的主表的主键字段是什么。</p><p>MySQL会根据外键约束的定义，监控对主表中的数据的删除操作，如果发现要<strong>删除的主表记录</strong>正在表中被某记录当作外键字段使用，就会提示错误，从而确保关联数据不会缺失。</p><p>外键约束可以在创建表的时候定义，也可以通过修改表定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">constraint &lt;外键约束名称&gt; foreign key 字段名<br>references &lt;主表名&gt; 字段名<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 从表名<br>(<br>字段名 类型,<br>  ...<br>  -- 定义外键约束，指出外键字段和参照的主表字段<br>  constraint 外键约束名<br>  foreign key (字段名) references 主表名 (字段名)<br>)<br></code></pre></td></tr></table></figure><p>通过修改表来定义外键约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table 从表名 add constraint 约束名 foreign key 字段名 references 主表名(字段名)<br></code></pre></td></tr></table></figure><p>创建主表demo.importhead</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE demo.importhead (<br>  listnumber INT PRIMARY KEY,<br>  supplierid INT,<br>  stocknumber INT, <br>  importtype INT, <br>  importquantity DECIMAL(10 , 3 ), <br>  importvalue DECIMAL(10 , 2 ), <br>  recorder INT, <br>  recordingdate DATETIME <br>);<br></code></pre></td></tr></table></figure><p>创建从表demo.importdetails，定义外键约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE demo.importdetails <br>( <br>  listnumber INT, <br>  itemnumber INT, <br>  quantity DECIMAL(10,3), <br>  importprice DECIMAL(10,2), <br>  importvalue DECIMAL(10,2), <br>  -- 定义外键约束，指出外键字段和参照的主表字段<br>  CONSTRAINT fk_importdetails_importhead <br>  FOREIGN KEY (listnumber) REFERENCES importhead (listnumber) <br>);<br></code></pre></td></tr></table></figure><p>查看外键约束的相关信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select<br>constraint_name, -- 外键约束名称<br>table_name, -- 外键约束所属数据表的名称<br>column_name, -- 外键约束的字段名称<br>referenced_table_name,-- 外键约束所参照的数据表名称<br>referenced_column_name -- 外键约束所参照的字段名称<br>from<br>information_schema.KEY_COLUMN_USAGE<br>where<br>constraint_name = &#x27;fk_importdetails_importhead&#x27;;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117180912382.png" alt="image-20230117180912382"></p><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>关联关系建立起来之后，需要使用连接查询才能获得我们需要的数据。</p><p>MySQL连接有两种，分为内连接(inner join)和外链接(outer join)</p><ul><li>内连接表示查询结果值返回符合连接条件的记录，比较常用</li><li>外链接，表示查询结果返回某一个表中的所有记录，以及另一个表中满足连接条件的记录</li></ul><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p><code>join</code>、<code>inner join</code>、<code>cross join</code>含义是一样的，都表示内连接。</p><p>项目中有会员销售需求，会员销售的数据记录包括了会员编号，而非会员的会员编号为null。</p><p>销售表demo.trans</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117201242357.png" alt="image-20230117201242357"></p><p>会员信息表demo.membermaster</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117201315100.png" alt="image-20230117201315100"></p><p>两个表存在关联关系，表demo.trans中的<code>cardno</code>字段是关联关系中的外键</p><p>可以通过内连接，查询所有会员销售的流水记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select <br>a.transactionno, <br>a.itemnumber, <br>a.quantity,<br>  a.price, <br>  a.transdate, <br>  b.membername <br> from demo.trans as a<br> join demo.membermaster as b <br> ON (a.cardno = b.cardno);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117202630234.png" alt="image-20230117202630234"></p><p>关键字join和关键字on配对使用，意思是查询满足关联条件demo.trans中的cardno值和demo.membermaster中的cardno值相等的两个表中的所有记录</p><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>外链接与内连接值返回符合连接条件的记录不同，外链接可以返回表中的所有数据，分为左连接和右连接</p><ul><li>左连接，一般写作<code>left join</code>，返回左表中的所有记录，以及右表中符合连接条件的记录</li><li>右连接，一般写作<code>right join</code>，返回右表中的所有记录，以及左表中符合连接条件的记录</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select <br>a.transactionno,<br>a.itemnumber,<br>a.quantity,<br>a.price,<br>a.transdate,<br>b.membername<br>from demo.trans as a<br>left join demo.membermaster as b -- left join,以demo.trans为主<br>on (a.cardno=b.cardno);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117201835732.png" alt="image-20230117201835732"></p><p>使用<code>right join</code>实现同样的效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select <br>a.transactionno,<br>a.itemnumber,<br>a.quantity,<br>a.price,<br>a.transdate,<br>b.membername<br>from demo.trans as a<br>right join demo.membermaster as b <br>on (a.cardno=b.cardno);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117202251313.png" alt="image-20230117202251313"></p><h2 id="关联查询的误区"><a href="#关联查询的误区" class="headerlink" title="关联查询的误区"></a>关联查询的误区</h2><p>有了连接就能实现两个表的关联查询，那关联查询是否必须在外键约束的基础之上？</p><p>外键约束不是关联查询的必要条件，但是外键约束却不可获取。</p><p>超市进货，供货商编号是 1，进货仓库编号是 1。我们进货的商品编号是1234，进货数量是 1，进货价格是 10，进货金额是 10。</p><p>插入单头数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO demo.importhead <br>( <br>  listnumber, <br>  supplierid, <br>  stocknumber <br>) <br>VALUES <br>( <br>  1234, <br>  1, <br>  1<br>);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117211151182.png" alt="image-20230117211151182"></p><p>然后向进货单明细表插入数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO demo.importdetails<br>(<br>  listnumber, <br>  itemnumber, <br>quantity, <br>  importprice, <br>  importvalue <br>)<br>VALUES <br>(<br>  1234,<br>  1,<br>  1,<br>  10, <br>  10<br>);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117211423293.png" alt="image-20230117211423293"></p><p>此时如果删除和进货单头表，就会出现明细没有单头的数据缺失情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delete from demo.importhead<br>where listnumber = 1234;<br></code></pre></td></tr></table></figure><p>提示错误，因为违反了外键约束。</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117212604390.png" alt="image-20230117212604390"></p><p>为什么先插入进货单头表，再插入进货单明细？</p><p>因为如果先插入到从表，就会导致无法找到主表参照信息，从而提示错误，因为添加数据违反了外键约束。</p><p>删除进货单时，也因该先删除明细，再删除单头</p><h3 id="为什么没有外键约束也能进行关联查询？"><a href="#为什么没有外键约束也能进行关联查询？" class="headerlink" title="为什么没有外键约束也能进行关联查询？"></a>为什么没有外键约束也能进行关联查询？</h3><p>外键约束是有成本的，需要消耗系统资源。对于大并发的SQL操作，可能会不适合。</p><p>大型的中央数据库，就会因为外键约束的系统开销而变得特变慢。</p><p>所以MySQL允许不适用系统自带的外键约束，在应用层面完成检查数据一致性的逻辑。也就是说，即使不用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-设置主键</title>
    <link href="/2023/01/17/05-%E8%AE%BE%E7%BD%AE%E4%B8%BB%E9%94%AE/"/>
    <url>/2023/01/17/05-%E8%AE%BE%E7%BD%AE%E4%B8%BB%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="05-设置主键"><a href="#05-设置主键" class="headerlink" title="05-设置主键"></a>05-设置主键</h1><p>设置主键的三种思路：</p><ul><li>业务字段做主键</li><li>自增字段做主键</li><li>手动赋值字段做主键</li></ul><p>以会员信息表为例：</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117105518725.png" alt="image-20230117105518725"></p><h2 id="业务字段做主键"><a href="#业务字段做主键" class="headerlink" title="业务字段做主键"></a>业务字段做主键</h2><p>会员卡号适合，具有唯一性，可以用来表示会员记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table demo.membermaster<br>(<br>cardno char(8) primary key,<br>  membername text,<br>  memberphone text,<br>  memberpid text,<br>  memberaddress text,<br>  sex text,<br>  birthday datetime<br>);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117105816605.png" alt="image-20230117105816605"></p><p>cardno被设置为了主键</p><p>插入两条数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into demo.membermaster<br>(<br>cardno,<br>  membername,<br>  memberphone,<br>  memberpid,<br>  memberaddress,<br>  sex,<br>  birthday<br>)<br>values<br>(<br>&#x27;10000001&#x27;,<br>  &#x27;张三&#x27;,<br>  &#x27;13812345678&#x27;,<br>  &#x27;110123200001017890&#x27;,<br>  &#x27;北京&#x27;,<br>  &#x27;男&#x27;,<br>  &#x27;2000-01-01&#x27;<br>);<br><br><br>insert into demo.membermaster <br>(<br>  cardno,<br>  membername, <br>  memberphone,<br>  memberpid, <br>  memberaddress, <br>  sex, <br>  birthday <br>) <br>values<br>( <br>  &#x27;10000002&#x27;, <br>  &#x27;李四&#x27;, <br>  &#x27;13512345678&#x27;, <br>  &#x27;123123199001012356&#x27;, <br>  &#x27;上海&#x27;, <br>  &#x27;女&#x27;, <br>  &#x27;1990-01-01&#x27; <br>);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117110451072.png" alt="image-20230117110451072"></p><p>张三将卡转给了王五，此时cardno将无法唯一识别某个会员，有的模块获取了修改前的信息，有的模块获取了修改后的信息，导致内部数据不一致。</p><p>这种修改如何影响商家？</p><p>张三有一条买书的流水记录</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117110839531.png" alt="image-20230117110839531"></p><p>创建销售流水表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table demo.trans<br>(<br>transactionno int,<br>  itemnumber int,<br>  quantity decimal(10,3),<br>  price decimal(10,2),<br>  salesvalue decimal(10,2),<br>  cardno char(8),<br>  transdate datetime<br>);<br></code></pre></td></tr></table></figure><p>创建以后，插入一条销售流水</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into demo.trans<br>(<br>transactionno,<br>  itemnumber,<br>  quantity, <br>  price, <br>  salesvalue, <br>  cardno, <br>  transdate<br>)<br>values<br>(<br>1, <br>  1,<br>  1, <br>  89, <br>  89, <br>  &#x27;10000001&#x27;, <br>  &#x27;2020-12-01&#x27;<br>);<br></code></pre></td></tr></table></figure><p>查询2020-12-01的会员销售记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select b.membername,c.goodsname,a.quantity,a.salesvalue,a.transdate<br>from demo.trans as a<br>join demo.membermaster as b<br>join demo.goodsmaster as c<br>on (a.cardno = b.cardno and a.itemnumber=c.itemnumber);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117112728303.png" alt="image-20230117112728303"></p><p>此处使用了join，即表的关联，目的是为了引用其他表的信息，包括了demo.goodsmaster和demo.membermaster</p><p>修改会员信息，将10000001卡给王五</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update demo.membermaster<br>set membername = &#x27;王五&#x27;,<br>memberphone = &#x27;13698765432&#x27;,<br>memberpid = &#x27;475145197001012356&#x27;,<br>memberaddress = &#x27;天津&#x27;,<br>sex = &#x27;女&#x27;,<br>birthday = &#x27;1970-01-01&#x27;<br>where cardno = &#x27;10000001&#x27;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117114142524.png" alt="image-20230117114142524"></p><p>再次查询消费流水</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select b.membername,c.goodsname,a.quantity,a.salesvalue,a.transdate<br>from demo.trans as a<br>join demo.membermaster as b<br>join demo.goodsmaster as c<br>on (a.cardno = b.cardno and a.itemnumber=c.itemnumber);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117114222836.png" alt="image-20230117114222836"></p><p>变成了王五买馒头！</p><p>所以不能拿会员号作为主键</p><p>目前看，任何一个已有字段都不适合做主键</p><p><strong>尽量不要用业务字段作为主键</strong>，因为无法预测项目的整个生命周期内，哪些业务字段会因为项目的业务需求而又重复或重用。</p><h2 id="使用自增字段做主键"><a href="#使用自增字段做主键" class="headerlink" title="使用自增字段做主键"></a>使用自增字段做主键</h2><p>给会员信息添加一个字段id，给字段定义自增约束</p><ul><li>第一步：修改会员信息表，删除表的主键约束</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table demo.membermaster<br>drop primary key<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117114839786.png" alt="image-20230117114839786"></p><ul><li>第二步：修改会员信息表，添加字段id作为主键，定义自增约束</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table demo.membermaster<br>add id int primary key auto_increment;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117122830695.png" alt="image-20230117122830695"></p><ul><li>第三步：修改销售流水表，添加memberid，对应会员表中的主键</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table demo.trans<br>add memberid int;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117123020506.png" alt="image-20230117123020506"></p><ul><li>第四步：更新销售流水表，给新加字段memberid赋值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update demo.trans as a,demo.membermaster as b<br>set a.memberid = b.id<br>where a.transactionno &gt; 0<br>and a.cardno = b.cardno;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117123257361.png" alt="image-20230117123257361"></p><p>此时，再次面对卡号重用，比如张三的卡转给王五，则在会员信息表中增加一条</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into demo.membermaster<br>(<br>cardno,<br>  membername,<br>  memberphone,<br>  memberpid,<br>  memberaddress,<br>  sex,<br>  birthday<br>)<br>values<br>(<br>&#x27;10000001&#x27;,<br>  &#x27;王五&#x27;,<br>  &#x27;13698765432&#x27;, <br>  &#x27;475145197001012356&#x27;,<br>  &#x27;天津&#x27;, <br>  &#x27;女&#x27;, <br>  &#x27;1970-01-01&#x27;<br>);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117161145263.png" alt="image-20230117161145263"></p><p>保存了张三的信息，将不会出现错位问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select b.membername,c.goodsname,a.quantity,a.salesvalue,a.transdate<br>from demo.trans as a<br>join demo.membermaster as b<br>join demo.goodsmaster as c<br>on (a.memberid = b.id and a.itemnumber = c.itemnumber);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117162221748.png" alt="image-20230117162221748"></p><p>但是如果门店新增会员，新会员信息存在本地Mysqk之中，再汇总到总部，本地id自增就会与总部的id相互冲突，这种情况就需要取消id的自增属性，改成信息系统在添加过程中对id进行赋值操作</p><h2 id="手动赋值字段做主键"><a href="#手动赋值字段做主键" class="headerlink" title="手动赋值字段做主键"></a>手动赋值字段做主键</h2><p>具体操作：在总部的Mysql数据库中，有一个管理信息表，里面的信息包括成本核算策略、支付方式等，还有总部的系统参数，只需要天际一个字段用于记录会员编号的最大值</p><p>添加会员时，先获取总部数据库中的id最大值，再在此基础上加1，作为新的id</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Viper</title>
    <link href="/2023/01/17/viper/"/>
    <url>/2023/01/17/viper/</url>
    
    <content type="html"><![CDATA[<h1 id="viper"><a href="#viper" class="headerlink" title="viper"></a>viper</h1><p>我们将使用 Viper 包来作为yaml 和 config 信息的基础库。</p><p><a href="https://github.com/spf13/viper">Viper</a> 是 Go 生态圈里一个很知名的项目，在 GitHub 上有接近 1.8 万个 star。</p><p>它支持以下特性：</p><ul><li>设置默认值（存入时设置）</li><li>支持格式配置信息的格式包括 <code>JSON</code>、<code>TOML</code>、<code>YAML</code>、<code>HCL</code>、<code>envfile</code> 和 <code>Java properties</code></li><li>实时监控和重新读取配置文件（可选）</li><li>从环境变量中读取</li><li>从远程配置系统（etcd 或 Consul）读取并监控配置变化</li><li>从命令行参数读取配置</li><li>从 buffer 读取配置</li><li>显式配置值</li></ul><p>Viper 的功能比较丰富，这意味着面对多变的需求时我们可以很灵活。且作为明星项目，严格测试、使用广泛，很适合作为我们的配置模块的底层包。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get github.com/fsnotify/fsnotify<br><span class="hljs-keyword">go</span> get github.com/spf13/viper<br></code></pre></td></tr></table></figure><h2 id="viper基本用法"><a href="#viper基本用法" class="headerlink" title="viper基本用法"></a>viper基本用法</h2><ul><li><code>config.json</code></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10666</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;mysql&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(127.0.0.1:3306)/biezhi&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;root&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;password&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;123456&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;redis&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;127.0.0.1:6377&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;127.0.0.1:6378&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;127.0.0.1:6379&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;smtp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;enable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;addr&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mail_addr&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mail_user&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;password&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mail_password&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;to&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;xxx@gmail.com&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;xxx@163.com&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><code>config.yaml</code></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">port:</span> <span class="hljs-number">10666</span><br><span class="hljs-attr">mysql:</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">&quot;(127.0.0.1:3306)/biezhi&quot;</span><br><span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br><span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br><span class="hljs-attr">redis:</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:6377</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:6378</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:6379</span><br><span class="hljs-attr">smtp:</span><br><span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">addr:</span> <span class="hljs-string">mail_addr</span><br><span class="hljs-attr">username:</span> <span class="hljs-string">mail_user</span><br><span class="hljs-attr">password:</span> <span class="hljs-string">mail_password</span><br><span class="hljs-attr">to:</span> <br><span class="hljs-string">xxx@gmail.com</span><br><span class="hljs-string">xxx@163.com</span><br></code></pre></td></tr></table></figure><h3 id="建立默认值"><a href="#建立默认值" class="headerlink" title="建立默认值"></a>建立默认值</h3><p>一个好的配置系统应该支持默认值。键不需要默认值，但如果没有通过配置文件、环境变量、远程配置或命令行标志（flag）设置键，则默认值非常有用。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">viper.SetDefault(<span class="hljs-string">&quot;ContentDir&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>)<br>viper.SetDefault(<span class="hljs-string">&quot;LayoutDir&quot;</span>, <span class="hljs-string">&quot;layouts&quot;</span>)<br>viper.SetDefault(<span class="hljs-string">&quot;Taxonomies&quot;</span>, <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;tag&quot;</span>: <span class="hljs-string">&quot;tags&quot;</span>, <span class="hljs-string">&quot;category&quot;</span>: <span class="hljs-string">&quot;categories&quot;</span>&#125;)<br></code></pre></td></tr></table></figure><h3 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h3><p>Viper需要最少知道在哪里查找配置文件的配置。Viper支持<code>JSON</code>、<code>TOML</code>、<code>YAML</code>、<code>HCL</code>、<code>envfile</code>和<code>Java properties</code>格式的配置文件。Viper可以搜索多个路径，但目前单个Viper实例只支持单个配置文件。Viper不默认任何配置搜索路径，将默认决策留给应用程序。</p><p>下面是一个如何使用Viper搜索和读取配置文件的示例。不需要任何特定的路径，但是至少应该提供一个配置文件预期出现的路径。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go">viper.SetConfigFile(<span class="hljs-string">&quot;./config.yaml&quot;</span>) <span class="hljs-comment">// 指定配置文件路径</span><br><br>viper.SetConfigName(<span class="hljs-string">&quot;config&quot;</span>) <span class="hljs-comment">// 配置文件名称(无扩展名)</span><br><br>viper.SetConfigType(<span class="hljs-string">&quot;yaml&quot;</span>) <span class="hljs-comment">// 如果配置文件的名称中没有扩展名，则需要配置此项</span><br><br>viper.AddConfigPath(<span class="hljs-string">&quot;/etc/appname/&quot;</span>)   <span class="hljs-comment">// 查找配置文件所在的路径</span><br><br>viper.AddConfigPath(<span class="hljs-string">&quot;$HOME/.appname&quot;</span>)  <span class="hljs-comment">// 多次调用以添加多个搜索路径</span><br><br>viper.AddConfigPath(<span class="hljs-string">&quot;.&quot;</span>)               <span class="hljs-comment">// 还可以在工作目录中查找配置</span><br><br>err := viper.ReadInConfig() <span class="hljs-comment">// 查找并读取配置文件</span><br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 处理读取配置文件的错误</span><br><span class="hljs-built_in">panic</span>(fmt.Errorf(<span class="hljs-string">&quot;Fatal error config file: %s \n&quot;</span>, err))<br>&#125;<br></code></pre></td></tr></table></figure><p>在加载配置文件出错时，你可以像下面这样处理找不到配置文件的特定情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err := viper.ReadInConfig(); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">if</span> _, ok := err.(viper.ConfigFileNotFoundError); ok &#123;<br>        <span class="hljs-comment">// 配置文件未找到错误；如果需要可以忽略</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 配置文件被找到，但产生了另外的错误</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 配置文件找到并成功解析</span><br></code></pre></td></tr></table></figure><p><em>注意[自1.6起]：</em> 你也可以有不带扩展名的文件，并以编程方式指定其格式。对于位于用户<code>$HOME</code>目录中的配置文件没有任何扩展名，如<code>.bashrc</code>。</p><p><strong>这里补充两个问题供读者解答并自行验证</strong></p><p>当你使用如下方式读取配置时，viper会从<code>./conf</code>目录下查找任何以<code>config</code>为文件名的配置文件，如果同时存在<code>./conf/config.json</code>和<code>./conf/config.yaml</code>两个配置文件的话，<code>viper</code>会从哪个配置文件加载配置呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">viper.SetConfigName(<span class="hljs-string">&quot;config&quot;</span>)<br>viper.AddConfigPath(<span class="hljs-string">&quot;./conf&quot;</span>)<br></code></pre></td></tr></table></figure><p>在上面两个语句下搭配使用<code>viper.SetConfigType(&quot;yaml&quot;)</code>指定配置文件类型可以实现预期的效果吗？</p><h3 id="使用环境变量"><a href="#使用环境变量" class="headerlink" title="使用环境变量"></a>使用环境变量</h3><p>Viper完全支持环境变量。这使<code>Twelve-Factor App</code>开箱即用。有五种方法可以帮助与ENV协作:</p><ul><li><code>AutomaticEnv()</code></li><li><code>BindEnv(string...) : error</code></li><li><code>SetEnvPrefix(string)</code></li><li><code>SetEnvKeyReplacer(string...) *strings.Replacer</code></li><li><code>AllowEmptyEnv(bool)</code></li></ul><p><em>使用ENV变量时，务必要意识到Viper将ENV变量视为区分大小写。</em></p><p>Viper提供了一种机制来确保ENV变量是惟一的。通过使用<code>SetEnvPrefix</code>，你可以告诉Viper在读取环境变量时使用前缀。<code>BindEnv</code>和<code>AutomaticEnv</code>都将使用这个前缀。</p><p><code>BindEnv</code>使用一个或两个参数。第一个参数是键名称，第二个是环境变量的名称。环境变量的名称区分大小写。如果没有提供ENV变量名，那么Viper将自动假设ENV变量与以下格式匹配：前缀+ “_” +键名全部大写。当你显式提供ENV变量名（第二个参数）时，它 <strong>不会</strong> 自动添加前缀。例如，如果第二个参数是“id”，Viper将查找环境变量“ID”。</p><p>在使用ENV变量时，需要注意的一件重要事情是，每次访问该值时都将读取它。Viper在调用<code>BindEnv</code>时不固定该值。</p><p><code>AutomaticEnv</code>是一个强大的助手，尤其是与<code>SetEnvPrefix</code>结合使用时。调用时，Viper会在发出<code>viper.Get</code>请求时随时检查环境变量。它将应用以下规则。它将检查环境变量的名称是否与键匹配（如果设置了<code>EnvPrefix</code>）。</p><p><code>SetEnvKeyReplacer</code>允许你使用<code>strings.Replacer</code>对象在一定程度上重写 Env 键。如果你希望在<code>Get()</code>调用中使用<code>-</code>或者其他什么符号，但是环境变量里使用<code>_</code>分隔符，那么这个功能是非常有用的。可以在<code>viper_test.go</code>中找到它的使用示例。</p><p>或者，你可以使用带有<code>NewWithOptions</code>工厂函数的<code>EnvKeyReplacer</code>。与<code>SetEnvKeyReplacer</code>不同，它接受<code>StringReplacer</code>接口，允许你编写自定义字符串替换逻辑。</p><p>默认情况下，空环境变量被认为是未设置的，并将返回到下一个配置源。若要将空环境变量视为已设置，请使用<code>AllowEmptyEnv</code>方法。</p><h4 id="Env-示例："><a href="#Env-示例：" class="headerlink" title="Env 示例："></a>Env 示例：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">SetEnvPrefix(<span class="hljs-string">&quot;spf&quot;</span>) <span class="hljs-comment">// 将自动转为大写</span><br>BindEnv(<span class="hljs-string">&quot;id&quot;</span>)<br><br>os.Setenv(<span class="hljs-string">&quot;SPF_ID&quot;</span>, <span class="hljs-string">&quot;13&quot;</span>) <span class="hljs-comment">// 通常是在应用程序之外完成的</span><br><br>id := Get(<span class="hljs-string">&quot;id&quot;</span>) <span class="hljs-comment">// 13</span><br></code></pre></td></tr></table></figure><h3 id="从Viper获取值"><a href="#从Viper获取值" class="headerlink" title="从Viper获取值"></a>从Viper获取值</h3><p>在Viper中，有几种方法可以根据值的类型获取值。存在以下功能和方法:</p><ul><li><code>Get(key string) : interface&#123;&#125;</code></li><li><code>GetBool(key string) : bool</code></li><li><code>GetFloat64(key string) : float64</code></li><li><code>GetInt(key string) : int</code></li><li><code>GetIntSlice(key string) : []int</code></li><li><code>GetString(key string) : string</code></li><li><code>GetStringMap(key string) : map[string]interface&#123;&#125;</code></li><li><code>GetStringMapString(key string) : map[string]string</code></li><li><code>GetStringSlice(key string) : []string</code></li><li><code>GetTime(key string) : time.Time</code></li><li><code>GetDuration(key string) : time.Duration</code></li><li><code>IsSet(key string) : bool</code></li><li><code>AllSettings() : map[string]interface&#123;&#125;</code></li></ul><p>需要认识到的一件重要事情是，每一个Get方法在找不到值的时候都会返回零值。为了检查给定的键是否存在，提供了<code>IsSet()</code>方法。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">viper.GetString(<span class="hljs-string">&quot;logfile&quot;</span>) <span class="hljs-comment">// 不区分大小写的设置和获取</span><br><span class="hljs-keyword">if</span> viper.GetBool(<span class="hljs-string">&quot;verbose&quot;</span>) &#123;<br>    fmt.Println(<span class="hljs-string">&quot;verbose enabled&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-增删查改数据表</title>
    <link href="/2023/01/16/04-%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9%E6%95%B0%E6%8D%AE%E8%A1%A8/"/>
    <url>/2023/01/16/04-%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9%E6%95%B0%E6%8D%AE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="04-增删查改数据表"><a href="#04-增删查改数据表" class="headerlink" title="04-增删查改数据表"></a>04-增删查改数据表</h1><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into 表名 [(字段名 [,字段名] ...)] values (值的列表)<br></code></pre></td></tr></table></figure><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into demo.goodsmaster2<br>(<br>itemnumber,<br>  barcode,<br>  goodsname,<br>  specification,<br>  uint,<br>  price<br>)values<br>(<br>4,<br>  &#x27;0003&#x27;,<br>  &#x27;尺子&#x27;,<br>  &#x27;三角型&#x27;,<br>  &#x27;把&#x27;,<br>  5<br>);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230116225511515.png" alt="image-20230116225511515"></p><p>只给三个字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO demo.goodsmaster<br>( <br>  -- 这里只给3个字段赋值，itemnumber、specification、unit不赋值<br>barcode,<br>  goodsname, <br>  price <br>)<br>VALUES<br>(<br>  &#x27;0004&#x27;, <br>  &#x27;测试&#x27;,<br>10<br>);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230116225652251.png" alt="image-20230116225652251"></p><h3 id="插入数据记录时，必须考虑的三种字段约束"><a href="#插入数据记录时，必须考虑的三种字段约束" class="headerlink" title="插入数据记录时，必须考虑的三种字段约束"></a>插入数据记录时，必须考虑的三种字段约束</h3><ul><li>字段允许为空，赋值时可以为空值</li><li>字段是主键，不能为空</li><li>字段定义不能为空，且不是主键，就必须按照添加的约束进行处理</li></ul><p>尝试将<code>specification</code>改为不能为空</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE demo.goodsmaster <br>MODIFY specification TEXT NOT NULL;<br></code></pre></td></tr></table></figure><p><strong>报错：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230116230015683.png" alt="image-20230116230015683"></p><p>因为有部分数据的<code>specification</code>是null，所以不能修改，除非删除null数据</p><h2 id="插入查询结果"><a href="#插入查询结果" class="headerlink" title="插入查询结果"></a>插入查询结果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into 表名<br>select 字段名或值<br>from 表名<br>where 条件<br></code></pre></td></tr></table></figure><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delete from 表名<br>where 条件<br></code></pre></td></tr></table></figure><p>为了防止误删，习惯性添加<code>where</code>语句</p><p>删除所有数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delete from demo.goodsmaster<br>where itemnumber &gt; 1;<br></code></pre></td></tr></table></figure><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update 表名<br>set 字段名=值<br>where 条件<br></code></pre></td></tr></table></figure><p><strong>注意：不要修改主键字段的值</strong></p><p>修改主键字段的值会有怎样的结果?</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230116230701050.png" alt="image-20230116230701050"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update demo.goodsmaster<br>set itemnumber = 10<br>where itemnumber = 3;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230116230857625.png" alt="image-20230116230857625"></p><p>找不到原来的数据了</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230116230930439.png" alt="image-20230116230930439"></p><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select *|字段列表<br>from 数据源<br>where 条件<br>group by 字段<br>having 条件<br>order by 字段<br>limit 起始点，行数<br></code></pre></td></tr></table></figure><ul><li><code>select</code>:查询关键字 ，<code>*</code>是通配符，查询所有字段</li><li><code>where</code>:查询条件</li><li><code>group by</code>:查询结果如何分组，经常与Mysql的聚合函数一起使用</li><li><code>having</code>:筛选查询结果，跟<code>where</code>类似</li></ul><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>FROM关键字表示查询的数据源，数据源不一定是表，也可以是查询结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select a.goodsname,a.price<br>from(<br>select *<br>  from demo.goodsmaster<br>)as a;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230116234258076.png" alt="image-20230116234258076"></p><p>红色框里的部分叫做派生表(derived table)或者自查询(subquery)</p><h3 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h3><p>ASC表示生序，DESC表示降序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * <br>from demo.goodsmaster<br>order by barcode ASC,price DESC;<br></code></pre></td></tr></table></figure><p>不加order，查询</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230116234557128.png" alt="image-20230116234557128"></p><p>加order，查询</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230116234621252.png" alt="image-20230116234621252"></p><h3 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select *<br>from demo.goodsmaster<br>limit 1,2<br></code></pre></td></tr></table></figure><p>起始位2，结束为3</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230116234828638.png" alt="image-20230116234828638"></p><h2 id="处理重复信息"><a href="#处理重复信息" class="headerlink" title="处理重复信息"></a>处理重复信息</h2><p>将B的数据插入A中，解决重复信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into demo.goodsmaster<br>select * <br>from demo.goodsmaster2 as a<br>on duplicate key update barcode = a.barcode,goodsname=a.goodsname;<br></code></pre></td></tr></table></figure><p>表A</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117000446369.png" alt="image-20230117000446369"></p><p>表B</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117000605687.png" alt="image-20230117000605687"></p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230117000709963.png" alt="image-20230117000709963"></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02 | Mutex：庖丁解牛看实现</title>
    <link href="/2023/01/10/02-Mutex%EF%BC%9A%E5%BA%96%E4%B8%81%E8%A7%A3%E7%89%9B%E7%9C%8B%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/01/10/02-Mutex%EF%BC%9A%E5%BA%96%E4%B8%81%E8%A7%A3%E7%89%9B%E7%9C%8B%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="02-Mutex：庖丁解牛看实现"><a href="#02-Mutex：庖丁解牛看实现" class="headerlink" title="02 | Mutex：庖丁解牛看实现"></a>02 | Mutex：庖丁解牛看实现</h1><p>Mutex架构演进分为四个阶段：</p><ul><li>初版：flag标记锁是否被持有</li><li>给新人机会：新的goroutine有机会参与竞争锁</li><li>多给些机会：新来的和被唤醒的goroutine，但带来<strong>饥饿问题</strong></li><li>解决饥饿：解决竞争问题，不让goroutine长久等待</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230110204930565.png" alt="image-20230110204930565"></p><h2 id="初版互斥锁"><a href="#初版互斥锁" class="headerlink" title="初版互斥锁"></a>初版互斥锁</h2><p>通过flag变量，标记当前的锁是否被某个goroutine持有，1为已经被持有，其他goroutine只能等待，flag为0，可以通过CAS将flag置为1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// CAS操作，当时还没有抽象出atomic包</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cas</span><span class="hljs-params">(val *<span class="hljs-type">int32</span>, old, <span class="hljs-built_in">new</span> <span class="hljs-type">int32</span>)</span></span> <span class="hljs-type">bool</span> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">semacquire</span><span class="hljs-params">(*<span class="hljs-type">int32</span>)</span></span> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">semrelease</span><span class="hljs-params">(*<span class="hljs-type">int32</span>)</span></span> <br><span class="hljs-comment">// 互斥锁的结构，包含两个字段</span><br><span class="hljs-keyword">type</span> Mutex <span class="hljs-keyword">struct</span> &#123; <br>  key <span class="hljs-type">int32</span> <span class="hljs-comment">// 锁是否被持有的标识</span><br>  sema <span class="hljs-type">int32</span> <span class="hljs-comment">// 信号量专用，用以阻塞/唤醒goroutine 9 &#125; </span><br><span class="hljs-comment">// 保证成功在val上增加delta的值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">xadd</span><span class="hljs-params">(val *<span class="hljs-type">int32</span>, delta <span class="hljs-type">int32</span>)</span></span> (<span class="hljs-built_in">new</span> <span class="hljs-type">int32</span>) &#123; <br>  <span class="hljs-keyword">for</span> &#123; <br>    v := *val <br>    <span class="hljs-keyword">if</span> cas(val, v, v+delta) &#123; <br>      <span class="hljs-keyword">return</span> v + delta <br>    &#125; <br>  &#125; <br>  <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unreached&quot;</span>) <br>&#125; <br><span class="hljs-comment">// 请求锁</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> Lock() &#123; <br>  <span class="hljs-keyword">if</span> xadd(&amp;m.key, <span class="hljs-number">1</span>) == <span class="hljs-number">1</span> &#123; <span class="hljs-comment">//标识加1，如果等于1，成功获取到锁</span><br><span class="hljs-keyword">return</span> <br>  &#125; <br>  semacquire(&amp;m.sema) <span class="hljs-comment">// 否则阻塞等待</span><br>&#125; <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> Unlock() &#123; <br>  <span class="hljs-keyword">if</span> xadd(&amp;m.key, <span class="hljs-number">-1</span>) == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 将标识减去1，如果等于0，则没有其它等待者</span><br><span class="hljs-keyword">return</span> <br>  &#125;<br>  semrelease(&amp;m.sema) <span class="hljs-comment">// 唤醒其它阻塞的goroutine 35 &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CAS指令"><a href="#CAS指令" class="headerlink" title="CAS指令"></a>CAS指令</h3><h4 id="原子性的"><a href="#原子性的" class="headerlink" title="原子性的"></a>原子性的</h4><p>将给定制和一个内存地址中的值进行比较，如果是同一值，就用新值替换内存地址中的值，这个操作是原子性的</p><p>原子性保证了指令总是基于最新的值进行计算，如果同时又其他线程修改了这个值，CAS返回失败</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230110205605823.png" alt="image-20230110205605823"></p><p>Mutex结构体包含了两个字段</p><ul><li>字段key：flag，表示排外锁是否被goroutine持有</li><li>字段sema：信号变量，控制等待goroutine的阻塞休眠和唤醒</li></ul><p>Unlock方法可以被任意的goroutine调用释放锁，即使是没持有这个互斥锁的goroutine，也可以进行这个操作。因为，Mutex本身并没有包含着这把锁的goroutine的信息，所以，Unlock也不会对此进行检查。</p><p><strong>这是一个有趣而危险的功能！</strong></p><p>goroutine可以强制释放锁，这是一个危险的操作，因为临界区的goroutine可能不知道锁已经被释放，而继续进行临界区的业务操作，goroutine以为自己持有锁，会造成data race问题。</p><p>在使用Mutex时，要保证goroutine不释放自己未持有的锁，遵循“谁申请，谁释放”的原则。</p><p>处于性能考虑，即使释放掉锁，在if-else分之加入释放锁，代码会很臃肿，重构时也会误删或漏掉而出现死锁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Foo <span class="hljs-keyword">struct</span> &#123; <br>  mu sync.Mutex<br>  count <span class="hljs-type">int</span> <br>&#125; <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *Foo)</span></span> Bar() &#123; <br>f.mu.Lock() <br>  <br>  <span class="hljs-keyword">if</span> f.count &lt; <span class="hljs-number">1000</span> &#123; <br>    f.count += <span class="hljs-number">3</span> <br>    f.mu.Unlock() <span class="hljs-comment">// 此处释放锁</span><br><span class="hljs-keyword">return</span> <br>  &#125; <br>f.count++ <br>  f.mu.Unlock() <span class="hljs-comment">// 此处释放锁</span><br><span class="hljs-keyword">return</span> <br>&#125;<br></code></pre></td></tr></table></figure><p>1.14 版本，对defer做了优化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *Foo)</span></span> Bar() &#123;<br>  f.mu.Lock() <br>  <span class="hljs-keyword">defer</span> f.mu.Unlock() <br>  <span class="hljs-keyword">if</span> f.count &lt; <span class="hljs-number">1000</span> &#123; <br>    f.count += <span class="hljs-number">3</span> <br>    <span class="hljs-keyword">return</span> <br>  &#125;<br>  <br>  f.count++ <br>  <span class="hljs-keyword">return</span> <br>&#125;<br></code></pre></td></tr></table></figure><p>初版的Mutex有一个问题：请求锁的goroutine会排队等待获取互斥锁。</p><h2 id="给新人机会"><a href="#给新人机会" class="headerlink" title="给新人机会"></a>给新人机会</h2><p>2011.6.30 Mutex大调整</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Mutex <span class="hljs-keyword">struct</span> &#123; <br>  state <span class="hljs-type">int32</span> <br>  sema <span class="hljs-type">uint32</span> <br>&#125; <br><span class="hljs-keyword">const</span> ( <br>  mutexLocked = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-literal">iota</span> <span class="hljs-comment">// mutex is locked </span><br>  mutexWoken <br>  mutexWaiterShift = <span class="hljs-literal">iota</span> <br>)<br></code></pre></td></tr></table></figure><p><strong>Mutex的结构体第一个字段改为了state</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230110220022268.png" alt="image-20230110220022268"></p><p>state是符合型的字段，包含多重含义</p><ul><li>第一位表示锁是否被持有</li><li>第二位表示是否有唤醒的goroutine</li><li>剩余位数代表等待此锁的goroutine数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> Lock() &#123; <br>  <span class="hljs-comment">// Fast path: 幸运case，能够直接获取到锁</span><br><span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="hljs-number">0</span>, mutexLocked) &#123; <br>    <span class="hljs-keyword">return</span> <br>  &#125; <br>  <br>  awoke := <span class="hljs-literal">false</span> <br>  <span class="hljs-keyword">for</span> &#123; <br>    old := m.state <br>    <span class="hljs-built_in">new</span> := old | mutexLocked <span class="hljs-comment">// 新状态加锁</span><br><span class="hljs-keyword">if</span> old&amp;mutexLocked != <span class="hljs-number">0</span> &#123; <br>      <span class="hljs-built_in">new</span> = old + <span class="hljs-number">1</span>&lt;&lt;mutexWaiterShift <span class="hljs-comment">//等待者数量加一</span><br>&#125;<br><span class="hljs-keyword">if</span> awoke &#123; <br>      <span class="hljs-comment">// goroutine是被唤醒的，</span><br><span class="hljs-comment">// 新状态清除唤醒标志</span><br><span class="hljs-built_in">new</span> &amp;^= mutexWoken <br>    &#125;<br>    <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="hljs-built_in">new</span>) &#123;<span class="hljs-comment">//设置新状态</span><br><span class="hljs-keyword">if</span> old&amp;mutexLocked == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 锁原状态未加锁</span><br><span class="hljs-keyword">break</span> <br>      &#125; <br>      runtime.Semacquire(&amp;m.sema) <span class="hljs-comment">// 请求信号量</span><br> awoke = <span class="hljs-literal">true</span> <br>    &#125; <br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Concurrency</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01 | Mutex：如何解决资源并发访问问题?</title>
    <link href="/2023/01/10/01-Mutex%EF%BC%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B5%84%E6%BA%90%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98/"/>
    <url>/2023/01/10/01-Mutex%EF%BC%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B5%84%E6%BA%90%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="01-Mutex：如何解决资源并发访问问题"><a href="#01-Mutex：如何解决资源并发访问问题" class="headerlink" title="01-Mutex：如何解决资源并发访问问题"></a>01-Mutex：如何解决资源并发访问问题</h1><h2 id="互斥锁的实现机制"><a href="#互斥锁的实现机制" class="headerlink" title="互斥锁的实现机制"></a>互斥锁的实现机制</h2><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>在并发编程中，如果程序中的一部分会被并发访问或修改，那么，为了避免并发访问导致的意想不到的结果，这部分程序需要被保护起来，这部分被保护起来的程序，就叫做临界区。</p><p>临界区就是一个被共享的资源，或者说是一个整体的一组共享资源，比如对数据库的访问、对某一个共享数据结构的操作、对一个 I/O 设备的使用、对一个连接池中的连接的调用，等等。</p><p>多个线程同步访问临界区，就会造成访问或操作错误。</p><p><strong>使用互斥锁，限定临界区只能为一个线程持有。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230110172308798.png" alt="image-20230110172308798"></p><p>Mutex是使用最广泛的同步原语，也叫并发原语</p><h3 id="同步原语的使用场景："><a href="#同步原语的使用场景：" class="headerlink" title="同步原语的使用场景："></a>同步原语的使用场景：</h3><ul><li>共享资源：数据竞争，常用Mutex、RWMutex</li><li>任务编排：goroutine按照一定规律执行，常用WaitGroup、Channel</li><li>消息传递：不同的goroutine之间线程安全交流，常用Channel</li></ul><h2 id="Mutex的基本使用方法"><a href="#Mutex的基本使用方法" class="headerlink" title="Mutex的基本使用方法"></a>Mutex的基本使用方法</h2><h3 id="Locker接口"><a href="#Locker接口" class="headerlink" title="Locker接口"></a>Locker接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Locker <span class="hljs-keyword">interface</span>&#123;<br>  Lock() <br>  Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><p>互斥锁Mutex提供两个方法Lock和Unlock:进入临界区前调用Lock，退出临界区调用Unlock</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(m *Mutex)</span></span>Lock()<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(m *Mutex)</span></span>Unlock()<br></code></pre></td></tr></table></figure><p><strong>当一个 goroutine 通过调用 Lock 方法获得了这个锁的拥有权后， 其它请求锁的 goroutine就会阻塞在 Lock 方法的调用上，直到锁被释放并且自己获取到了这个锁的拥有权。</strong></p><h3 id="为什么要加锁？"><a href="#为什么要加锁？" class="headerlink" title="为什么要加锁？"></a>为什么要加锁？</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 计数器的值</span><br><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span><br><br><span class="hljs-comment">// 辅助变量，用来确定所有goroutine都完成</span><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>wg.Add(<span class="hljs-number">10</span>)<br><br><span class="hljs-comment">// 启动10个goroutine</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++ &#123;<br>count++<br>&#125;<br>&#125;()<br>&#125;<br>wg.Wait()<br>fmt.Println(count)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>执行结果不尽如人意啊！！！</p><p><strong><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230110165713065.png" alt="image-20230110165713065"></strong></p><p><strong>cout++不是一个原子操作！！</strong>好多计数被吞掉了</p><h3 id="race-detector"><a href="#race-detector" class="headerlink" title="race detector"></a>race detector</h3><p>编译器通过探测所 有的内存访问，加入代码能监视对这些内存地址的访问（读还是写）。在代码运行的时候,race detector 就能监控到对共享变量的非同步访问，出现 race 的时候，就会打印出警告信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> run -race example1.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p>但是只能通过真正对实际地址进行读写访问的时候才能探测，所以它并不能在编译的时候发现 data race 的问题。</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230110165833018.png" alt="image-20230110165833018"></p><p>运行<code>go tool compile -race -S example1.go</code>，可以查看计数器例子的代码</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230110193751324.png" alt="image-20230110193751324"></p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>临界区是count++，只要在临界区前面获取锁，在离开临界区的时候释放锁，就可以完美解决data race问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 互斥锁保护计时器</span><br><span class="hljs-keyword">var</span> mu sync.Mutex<br><span class="hljs-comment">// 计数器的值</span><br><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span><br><br><span class="hljs-comment">// 辅助变量，用来确定所有goroutine都完成</span><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>wg.Add(<span class="hljs-number">10</span>)<br><br><span class="hljs-comment">// 启动10个goroutine</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>mu.Lock()<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++ &#123;<br>count++<br>&#125;<br>mu.Unlock()<br>&#125;()<br>&#125;<br>wg.Wait()<br>fmt.Println(count)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>其他用法：</p><p><strong>嵌入字段</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-comment">// Mutex 嵌入字段使用</span><br><span class="hljs-keyword">type</span> Counter1 <span class="hljs-keyword">struct</span> &#123;<br>sync.Mutex<br>count <span class="hljs-type">uint64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> counter Counter1<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>wg.Add(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++ &#123;<br>counter.Lock()<br>counter.count++<br>counter.Unlock()<br>&#125;<br><br>&#125;()<br>&#125;<br>wg.Wait()<br>fmt.Println(counter.count)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>将获取锁、释放锁、计数加一的逻辑封装成一个方法，不对外暴露锁逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> counter Counter2<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>wg.Add(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++ &#123;<br>counter.Incr()<br>&#125;<br>&#125;()<br>&#125;<br>wg.Wait()<br>fmt.Println(counter.Count())<br>&#125;<br><br><span class="hljs-comment">// 线性安全的计数器形式</span><br><span class="hljs-keyword">type</span> Counter2 <span class="hljs-keyword">struct</span> &#123;<br>CounterType <span class="hljs-type">int</span><br>Name        <span class="hljs-type">string</span><br>mu          sync.Mutex<br>count       <span class="hljs-type">uint64</span><br>&#125;<br><br><span class="hljs-comment">// 加1的方法，内部使用互斥锁保护</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(counter *Counter2)</span></span> Incr() &#123;<br>counter.mu.Lock()<br>counter.count++<br>counter.mu.Unlock()<br>&#125;<br><br><span class="hljs-comment">//得到计数器的值，也需要互斥锁的保护</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(counter *Counter2)</span></span> Count() <span class="hljs-type">uint64</span> &#123;<br>counter.mu.Lock()<br><span class="hljs-keyword">defer</span> counter.mu.Unlock()<br><span class="hljs-keyword">return</span> counter.count<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Concurrency</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03 创建和修改数据</title>
    <link href="/2023/01/09/03-%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E8%A1%A8/"/>
    <url>/2023/01/09/03-%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="03-创建和修改数据表"><a href="#03-创建和修改数据表" class="headerlink" title="03-创建和修改数据表"></a>03-创建和修改数据表</h1><h2 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE &lt;表名&gt; <br>( <br>  字段名1 数据类型 [字段级别约束] [默认值],<br>  字段名2 数据类型 [字段级别约束] [默认值],<br>  ...... <br>  [表级别约束] <br>);<br></code></pre></td></tr></table></figure><p><strong>“约束”限定</strong></p><p><strong>了表中数据应该满足的条件</strong>。MySQL 会根据这些限定条件，对表的操作进行监控，阻止破坏约束条件的操作执行，并提示错误，从而确保表中数据的唯一性、合法性和完整性。这是创建表时不可缺少的一部分</p><h3 id="创建数据表-1"><a href="#创建数据表-1" class="headerlink" title="创建数据表"></a>创建数据表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE demo.importhead<br>(<br>  listnumber INT,<br>  supplierid INT,<br>  stocknumber int,<br>  importtype int default 1,<br>  quantity decimal(10,3),<br>  importvalue decimal(10,2),<br>  recorder int,<br>  recordingdate datetime<br>);<br></code></pre></td></tr></table></figure><p>创建表时，字段名称要避开Mysql的系统关键字</p><h3 id="插入记录"><a href="#插入记录" class="headerlink" title="插入记录"></a>插入记录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into demo.importhead<br>(<br>listnumber,<br>    supplierid,<br>    stocknumber,<br>    quantity,<br>    importvalue,<br>    recorder,<br>    recordingdate<br>)<br>values<br>(<br>3456,<br>    1,<br>    1,<br>    10,<br>    100,<br>    1,<br>    &#x27;2023-1-9&#x27;<br>)<br></code></pre></td></tr></table></figure><p>查询内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM demo.importhead<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230109165330652.png" alt="image-20230109165330652"></p><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>给字段设置默认值的方法为默认约束，设置默认约束，插入数据时，如果不明确给字段赋值，系统会将设置的默认值自动赋给字段</p><p>除了默认约束意外，还有主键约束、外键约束、非空约束、唯一性约束、自增约束</p><h3 id="1-非空约束"><a href="#1-非空约束" class="headerlink" title="1.非空约束"></a>1.非空约束</h3><p>非空约束表示字段值不能为空，如果创建表的时候，指明某个字段非空，那么添加数据的时候，这个字段必须有值，否则系统就会提示错误</p><h3 id="2-唯一性约束"><a href="#2-唯一性约束" class="headerlink" title="2.唯一性约束"></a>2.唯一性约束</h3><p>唯一性约束表示这个字段的值不能重复，否则系统会提示错误。跟主键约束相比，唯一性约束要更加弱一些。</p><p>主键约束只能有一个，但是多个字段可以满足唯一性约束。满足主键约束的字段，自动满足非空约束，但是满足唯一性约束的字段，则可以是空值。</p><h3 id="3-自增约束"><a href="#3-自增约束" class="headerlink" title="3.自增约束"></a>3.自增约束</h3><p>自增约束可以让 MySQL 自动给字段赋值，且保证不会重复，非常有用，只是不容易用好。</p><p><code>demo.goodsmaster</code>中的<code>itemnumber</code>改为自增类型</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230109193817443.png" alt="image-20230109193817443"></p><p>插入测试记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into demo.goodsmaster<br>(<br>itemnumber,<br>    barcode,<br>    goodsname,<br>    specification,<br>    uint,<br>    price<br>)<br>values<br>(<br>100,<br>    &#x27;0003&#x27;,<br>    &#x27;测试1&#x27;,<br>    &#x27;&#x27;,<br>    &#x27;个&#x27;,<br>    10<br>);<br></code></pre></td></tr></table></figure><p>此处可以看到itemnumber为100</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230109202520016.png" alt="image-20230109202520016"></p><p>再新增一条数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into demo.goodsmaster<br>(<br>    barcode,<br>    goodsname,<br>    specification,<br>    uint,<br>    price<br>)<br>values<br>(<br>    &#x27;0004&#x27;,<br>    &#x27;测试2&#x27;,<br>    &#x27;&#x27;,<br>    &#x27;个&#x27;,<br>    15<br>);<br></code></pre></td></tr></table></figure><p>新增数据itemnumber为101</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230109202719543.png" alt="image-20230109202719543"></p><h2 id="如何修改表"><a href="#如何修改表" class="headerlink" title="如何修改表"></a>如何修改表</h2><p>复制表，修改表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table demo.importheadhist<br>like demo.importhead;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230109203105898.png" alt="image-20230109203105898"></p><h2 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table demo.importheadhist<br>add confirmer int; -- 添加一个字段confirmer，类型为INT<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230109203435670.png" alt="image-20230109203435670"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table demo.importheadhist<br>add confirmdate DATETIME; -- 添加一个字段confrimdate，类型为DATETIME<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230109203640437.png" alt="image-20230109203640437"></p><p>查看表的结构</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230109203759367.png" alt="image-20230109203759367"></p><h2 id="修改字段"><a href="#修改字段" class="headerlink" title="修改字段"></a>修改字段</h2><p>将quantity改成importquantity</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table demo.importheadhist<br>change quantity importquantity double;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230109204013497.png" alt="image-20230109204013497"></p><p>将imprtquantity改为DECIMAL(10,3)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table demo.importheadhist<br>modify importquantity decimal(10,3);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230109204258004.png" alt="image-20230109204258004"></p><p>添加suppliername，数据类型为TEXT</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table demo.importheadhist<br>add supplierman text after supplierid;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230109204502234.png" alt="image-20230109204502234"></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02 定义字段类型</title>
    <link href="/2023/01/09/02-%E5%AE%9A%E4%B9%89%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B/"/>
    <url>/2023/01/09/02-%E5%AE%9A%E4%B9%89%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="02-定义字段类型"><a href="#02-定义字段类型" class="headerlink" title="02-定义字段类型"></a>02-定义字段类型</h1><h2 id="整型类型"><a href="#整型类型" class="headerlink" title="整型类型"></a>整型类型</h2><p>包括TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）和BIGINT</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230109154457492.png" alt="image-20230109154457492"></p><p>商品编号一般采用INT</p><h2 id="浮点数类型和定点数类型"><a href="#浮点数类型和定点数类型" class="headerlink" title="浮点数类型和定点数类型"></a>浮点数类型和定点数类型</h2><p>浮点数类型分为FLOAT、DOUBLE、REAL</p><ul><li>FLOAT表示单精度浮点数</li><li>DOUBLE表示双精度浮点数</li><li>REAL默认是DOUBLE，如果把SQL模式设定为<code>REAL_AS_FLOAT</code>，那么REAL就是FLOAT类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET sql_mode = &quot;REAL_AS_FLOAT&quot;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230109155028175.png" alt="image-20230109155028175"></p><p>Mysql按照这个格式存储浮点数的：符号(S)、尾数(M)、阶码(E)</p><p>无论有没有符号，MySQL的浮点数都会存储表示符号的部分，因此，所谓的无符号数值取值范围，其实也就是有符号取值范围大于零的部分</p><p><strong>浮点数类型的缺陷是不精准</strong>，对于精确度要求较高的项目，<strong>千万</strong>不能使用浮点数！！！</p><h3 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE demo.goodsmaster<br>( <br>  barcode TEXT, <br>  goodsname TEXT, <br>  price DOUBLE, <br>  itemnumber INT PRIMARY KEY AUTO_INCREMENT <br>);<br></code></pre></td></tr></table></figure><p>插入数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 第一条<br>INSERT INTO demo.goodsmaster <br>( <br>  barcode,<br>  goodsname, <br>  price <br>)<br>VALUES<br>( <br>  &#x27;0001&#x27;, <br>  &#x27;书&#x27;, <br>  0.47 <br>);<br>-- 第二条<br>INSERT INTO demo.goodsmaster <br>( <br>  barcode,<br>  goodsname,<br>  price <br>) <br>VALUES <br>( <br>  &#x27;0002&#x27;, <br>  &#x27;笔&#x27;, <br>  0.44 <br>); <br>-- 第三条<br>INSERT INTO demo.goodsmaster<br>( <br>  barcode,<br>  goodsname, <br>  price <br>) <br>VALUES <br>( <br>  &#x27;0002&#x27;, <br>  &#x27;胶水&#x27;, <br>  0.19 <br>);<br></code></pre></td></tr></table></figure><p>查看表里情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * from demo.goodsmaster<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230109161532743.png" alt="image-20230109161532743"></p><p>将三个价格加到一起</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT SUM(price)<br>FROM demo.goodsmaster;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230109161848208.png" alt="image-20230109161848208"></p><p>改成FLOAT型，误差更大</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230109161933516.png" alt="image-20230109161933516"></p><h3 id="精准的数据类型：定点数类型DECIMAL"><a href="#精准的数据类型：定点数类型DECIMAL" class="headerlink" title="精准的数据类型：定点数类型DECIMAL"></a>精准的数据类型：定点数类型DECIMAL</h3><p>浮点数是将十进制数转换为二进制数存储，DECIMAL是将十进制的整数部分和小数部分拆改，分别转换成十六进制数，进行存储。</p><p>Mysql用DECIMAL(M,D)的方式表示高精度小数，M表示整数部分加小数部分一共有多少位，M&lt;=65，D表示小数部分尾数，D&lt;M</p><p>将price的数据类型修改为DECIMAL(5,2)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE demo.goodsmaster<br>MODIFY COLUMN price DECIMAL(5,2);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230109162401666.png" alt="image-20230109162401666"></p><p>再一次运行求和语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT SUM(price)<br>FROM demo.goodsmaster;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230109162631852.png" alt="image-20230109162631852"></p><h2 id="文本类型"><a href="#文本类型" class="headerlink" title="文本类型"></a>文本类型</h2><ul><li>CHAR(M)：固定长度字符串。CHAR(M) 类型必须预先定义字符串长度。如果太短，数据可能会超出范围；如果太长，又浪费存储空间。</li><li>VARCHAR(M)： 可变长度字符串。VARCHAR(M) 也需要预先知道字符串的最大长度，不过只要不超过这个最大长度，具体存储的时候，是按照实际字符串长度存储的。</li><li>TEXT：字符串。系统自动按照实际长度存储，不需要预先定义长度。</li><li>ENUM： 枚举类型，取值必须是预先设定的一组字符串值范围之内的一个，必须要知道字符串所有可能的取值。</li><li>SET：是一个字符串对象，取值必须是在预先设定的字符串值范围之内的 0 个或多个，也必须知道字符串所有可能的取值。</li></ul><p>TEXT也分4种类型：</p><ul><li>TINYTEXT：255 字符（这里假设字符是 ASCII 码，一个字符占用一个字节，下同）。</li><li>TEXT： 65535 字符。</li><li>MEDIUMTEXT：16777215 字符。</li><li>LONGTEXT： 4294967295 字符（相当于 4GB）。</li></ul><p><strong>注意</strong>：由于实际存储的长度不确定，MySQL 不允许TEXT 类型的字段做主键。遇到这种情况，你只能采用 CHAR(M)，或者 VARCHAR(M)。</p><h2 id="日期与时间类型"><a href="#日期与时间类型" class="headerlink" title="日期与时间类型"></a>日期与时间类型</h2><p>使用最多的是DATETIME</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230109163056213.png" alt="image-20230109163056213"></p><p><strong>建议</strong>：为了确保数据的完整性和系统的稳定性，优先考虑使用DATETIME 类型。因为虽然 DATETIME 类型占用的存储空间最多，但是它表达的时间最为完整，取值范围也最大。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01 完整的数据存储过程</title>
    <link href="/2023/01/09/01-%E5%AE%8C%E6%95%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <url>/2023/01/09/01-%E5%AE%8C%E6%95%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="01-完整的数据存储过程"><a href="#01-完整的数据存储过程" class="headerlink" title="01-完整的数据存储过程"></a>01-完整的数据存储过程</h1><p>数据存储分为4个步骤：</p><ul><li>创建数据库</li><li>确认字段</li><li>创建数据表</li><li>插入数据</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230109151028957.png" alt="image-20230109151028957"></p><h2 id="创建Mysql数据库"><a href="#创建Mysql数据库" class="headerlink" title="创建Mysql数据库"></a>创建Mysql数据库</h2><p>从系统架构层次上看，Mysql数据库系统从小大大依次为：</p><ul><li>数据库服务器</li><li>数据库</li><li>数据表</li><li>数据表的行与列</li></ul><p><strong>数据库是Mysql的最大存储单元</strong></p><h3 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1.创建数据库"></a>1.创建数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE DATABASE demo;<br></code></pre></td></tr></table></figure><h3 id="2-查看数据库"><a href="#2-查看数据库" class="headerlink" title="2.查看数据库"></a>2.查看数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW DATABASES;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230109151411935.png" alt="image-20230109151411935"></p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230109151451931.png" alt="image-20230109151451931"></p><h2 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE demo.test<br>(<br>barcode text,<br>  goodsname text,<br>  price int<br>);<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>创建表时，最好指明数据库</li><li>不要再最后一个字段的后面加上逗号<code>,</code></li></ul><h3 id="1-查看表的结构"><a href="#1-查看表的结构" class="headerlink" title="1.查看表的结构"></a>1.查看表的结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DESC demo.test<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230109151920615.png" alt="image-20230109151920615"></p><ul><li>Field：表示字段名称。</li><li>Type：表示字段类型，这里 barcode、goodsname 是文本型的，price 是整数类型的。</li><li>Null：表示这个字段是否允许是空值（NULL）。这里你一定要注意，在 MySQL 里面，空值不等于空字符串。一个空字符串的长度是 0，而一个空值的长度是空。而且，在 MySQL里面，空值是占用空间的。</li><li>Key：我们暂时把它叫做键。</li><li>Default：表示默认值。我们导入的表的所有的字段都允许是空，默认值都是 NULL。</li><li>Extra：表示附加信息。</li></ul><h3 id="2-查看数据库中的表"><a href="#2-查看数据库中的表" class="headerlink" title="2.查看数据库中的表"></a>2.查看数据库中的表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">USE demo;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230109152115536.png" alt="image-20230109152115536"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW TABLES;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20230109152156696.png" alt="image-20230109152156696"></p><h3 id="3-设置主键"><a href="#3-设置主键" class="headerlink" title="3.设置主键"></a>3.设置主键</h3><p>主键可以确保数据的唯一性，减少数据错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE demo.test<br>ADD COLUMN itemnumber int PRIMARY KEY AUTO_INCREMENT;<br></code></pre></td></tr></table></figure><ul><li>ALTER TABLE，表示修改表；</li><li>ADD COLUMN，表示增加一列；</li><li>PRIMARY KEY，表示这一列是主键；</li><li>AUTO_INCREMENT，表示每增加一条记录，这个值自动增加。一会儿讲到添加数据的时候，我还会详细介绍一下它。</li></ul><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO demo.test<br>(barcode,goodsname,price)<br>VALUES(<br>&#x27;0001&#x27;,<br>  &#x27;本&#x27;,<br>  3<br>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2022/12/26/%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/12/26/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><blockquote><p>链表由一个个数据节点组成，是一个递归结构，要么为空，要么存在就是只想另一个数据节点的引用</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span>(<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> LinkNode <span class="hljs-keyword">struct</span> &#123; <br>  Data <span class="hljs-type">int64</span> <br>  NextNode *LinkNode <br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123; <br>  <span class="hljs-comment">// 新的节点 </span><br>  node := <span class="hljs-built_in">new</span>(LinkNode) <br>  node.Data = <span class="hljs-number">2</span> <br>  <span class="hljs-comment">// 新的节点 </span><br>  node1 := <span class="hljs-built_in">new</span>(LinkNode) <br>  node1.Data = <span class="hljs-number">3</span> <br>  node.NextNode = node1 <br>  <span class="hljs-comment">// node1 链接到 node 节点上</span><br>  <span class="hljs-comment">// 新的节点 </span><br>  node2 := <span class="hljs-built_in">new</span>(LinkNode) <br>  node2.Data = <span class="hljs-number">4</span> <br>  node1.NextNode = node2 <span class="hljs-comment">// node2 链接到 node1 节点上 </span><br>  <span class="hljs-comment">// 按顺序打印数据</span><br>  nowNode := node <br>  <span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-keyword">if</span> nowNode != <span class="hljs-literal">nil</span> &#123; <br>      <span class="hljs-comment">// 打印节点值 </span><br>      fmt.Println(nowNode.Data) <br>      <span class="hljs-comment">// 获取下一个节点 </span><br>      nowNode = nowNode.NextNode &#125;<br>    <span class="hljs-comment">// 如果下一个节点为空，表示链表结束了 </span><br>    <span class="hljs-keyword">break</span> <br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>结构体 <code>LinkNode</code> 有两个字段，一个字段存放数据<code>Data</code> ，另一个字典指向下一个节点 <code>NextNode</code>。这种从一个数据节点指向下一个数据节点的结构，都可以叫做链表。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li><p>单链表，就是链表是单向的，像我们上面这个结构一样，可以一直往下找到下一个数据节点，它只有一个方向，它不能往回找。</p></li><li><p>双链表，每个节点既可以找到它之前的节点，也可以找到之后的节点，是双向的。</p></li><li><p>循环链表，就是它一直往下找数据节点，最后回到了自己那个节点，形成了一个回路。循环单链表和循环双链表的区别就是，一个只能一个方向走，一个两个方向都可以走。</p></li></ol><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><h3 id="1-初始化循环链表"><a href="#1-初始化循环链表" class="headerlink" title="1.初始化循环链表"></a>1.初始化循环链表</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <br><span class="hljs-keyword">import</span> ( <span class="hljs-string">&quot;fmt&quot;</span> )<br><span class="hljs-comment">// 初始化空的循环链表，前驱和后驱都指向自己，因为是循环的 </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Ring)</span></span> init() *Ring &#123; <br>  r.next = r<br>  r.prev = r <br>  <span class="hljs-keyword">return</span> r <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123; <br>  r := <span class="hljs-built_in">new</span>(Ring) <br>  r.init() <br>&#125;<br></code></pre></td></tr></table></figure><p>创建一个指定大小 N 的循环链表，值全为空:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建N个节点的循环链表 </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> *Ring &#123; <br>  <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span> &#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> <br>  &#125;<br>  r := <span class="hljs-built_in">new</span>(Ring) <br>  p := r <br>  <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123; <br>    p.next = &amp;Ring&#123;<br>      prev: p<br>    &#125; <br>    p = p.next <br>  &#125;<br>  p.next = r <br>  r.prev = p<br></code></pre></td></tr></table></figure><h3 id="2-获取上一个或下一个节点"><a href="#2-获取上一个或下一个节点" class="headerlink" title="2.获取上一个或下一个节点"></a>2.获取上一个或下一个节点</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 获取下一个节点 </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Ring)</span></span> Next() *Ring &#123; <br>  <span class="hljs-keyword">if</span> r.next == <span class="hljs-literal">nil</span> &#123; <br>    <span class="hljs-keyword">return</span> r.init() <br>  &#125;<br>  <span class="hljs-keyword">return</span> r.next <br>&#125;<br><span class="hljs-comment">// 获取上一个节点 </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Ring)</span></span> Prev() *Ring &#123; <br>  <span class="hljs-keyword">if</span> r.next == <span class="hljs-literal">nil</span> &#123; <br>    <span class="hljs-keyword">return</span> r.init() <br>  &#125;<span class="hljs-keyword">return</span> <br>  r.prev <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-获取第n个节点"><a href="#3-获取第n个节点" class="headerlink" title="3.获取第n个节点"></a>3.获取第n个节点</h3><p>因为链表是循环的，当 n 为负数，表示从前面往前遍历，否则往后面遍历：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Ring)</span></span> Move(n <span class="hljs-type">int</span>) *Ring &#123; <br>  <span class="hljs-keyword">if</span> r.next == <span class="hljs-literal">nil</span> &#123; <br>    <span class="hljs-keyword">return</span> r.init() <br>  &#125;<br>  <span class="hljs-keyword">switch</span> &#123; <br>    <span class="hljs-keyword">case</span> n &lt; <span class="hljs-number">0</span>: <br>    <span class="hljs-keyword">for</span> ; n &lt; <span class="hljs-number">0</span>; n++ &#123;<br>        r = r.prev <br>      &#125; <br>  <span class="hljs-keyword">case</span> n &gt; <span class="hljs-number">0</span>: <br>    <span class="hljs-keyword">for</span> ; n &gt; <span class="hljs-number">0</span>; n-- &#123; <br>      r = r.next <br>    &#125; <br>  &#125;<br>  <span class="hljs-keyword">return</span> r<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-添加节点"><a href="#4-添加节点" class="headerlink" title="4.添加节点"></a>4.添加节点</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 往节点A，链接一个节点，并且返回之前节点A的后驱节点 </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Ring)</span></span> Link(s *Ring) *Ring &#123; <br>  n := r.Next() <br>  <span class="hljs-keyword">if</span> s != <span class="hljs-literal">nil</span> &#123; <br>    p := s.Prev() <br>    r.next = s <br>    s.prev = r <br>    n.prev = p <br>    p.next = n <br>  &#125;<br>  <span class="hljs-keyword">return</span> n <br>&#125;<br></code></pre></td></tr></table></figure><p>添加节点的操作比较复杂，如果节点 s 是一个新的节点。那么也就是在 r 节点后插入一个新节点 s ，而 r 节点之前的后驱节点，将会链接到新节点后面，并返回 r 节点之前的第一个后驱节点 n 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <br><span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<br>ffunc linkNewTest() &#123; <br>  <span class="hljs-comment">// 第一个节点 </span><br>  r := &amp;Ring&#123;Value: <span class="hljs-number">-1</span>&#125; <br>  <span class="hljs-comment">// 链接新的五个节点 </span><br>  r.Link(&amp;Ring&#123;Value: <span class="hljs-number">1</span>&#125;) <br>  r.Link(&amp;Ring&#123;Value: <span class="hljs-number">2</span>&#125;) <br>  r.Link(&amp;Ring&#123;Value: <span class="hljs-number">3</span>&#125;) <br>  r.Link(&amp;Ring&#123;Value: <span class="hljs-number">4</span>&#125;) <br>  node := r <br>  <span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-comment">// 打印节点值 </span><br>    fmt.Println(node.Value) <br>    <span class="hljs-comment">// 移到下一个节点 </span><br>    node = node.Next() <br>    <span class="hljs-comment">// 如果节点回到了起点，结束 </span><br>    <span class="hljs-keyword">if</span> node == r &#123; <br>      <span class="hljs-keyword">return</span> <br>    &#125; <br>  &#125; <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123; <br>  linkNewTest() <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-删除节点"><a href="#5-删除节点" class="headerlink" title="5.删除节点"></a>5.删除节点</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 删除节点后面的 n 个节点 </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Ring)</span></span> Unlink(n <span class="hljs-type">int</span>) *Ring &#123; <br>  <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span> &#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> <br>  &#125;<br>  <span class="hljs-keyword">return</span> r.Link(r.Move(n + <span class="hljs-number">1</span>)) <br>&#125;<br></code></pre></td></tr></table></figure><p>将循环链表的后面几个节点删除。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <br><span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteTest</span><span class="hljs-params">()</span></span> &#123; <br>  <span class="hljs-comment">// 第一个节点 </span><br>  r := &amp;Ring&#123;Value: <span class="hljs-number">-1</span>&#125; <br>  <span class="hljs-comment">// 链接新的五个节点 </span><br>  r.Link(&amp;Ring&#123;Value: <span class="hljs-number">1</span>&#125;) <br>  r.Link(&amp;Ring&#123;Value: <span class="hljs-number">2</span>&#125;) <br>  r.Link(&amp;Ring&#123;Value: <span class="hljs-number">3</span>&#125;) <br>  r.Link(&amp;Ring&#123;Value: <span class="hljs-number">4</span>&#125;) <br>  temp := r.Unlink(<span class="hljs-number">3</span>) <span class="hljs-comment">// 解除了后面两个节点 </span><br>  <span class="hljs-comment">// 打印原来的节点 </span><br>  node := r <span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-comment">// 打印节点值 </span><br>    fmt.Println(node.Value) <br>    <span class="hljs-comment">// 移到下一个节点 </span><br>    node = node.Next() <br>    <span class="hljs-comment">// 如果节点回到了起点，结束 </span><br>    <span class="hljs-keyword">if</span> node == r &#123; <br>      <span class="hljs-keyword">break</span> <br>    &#125; <br>  &#125;<br>  fmt.Println(<span class="hljs-string">&quot;------&quot;</span>)<br>  <span class="hljs-comment">// 打印被切断的节点 </span><br>  node = temp <span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-comment">// 打印节点值 </span><br>    fmt.Println(node.Value) <br>    <span class="hljs-comment">// 移到下一个节点 node = node.Next()</span><br>    <span class="hljs-comment">// 如果节点回到了起点，结束 </span><br>    <span class="hljs-keyword">if</span> node == temp &#123; <br>      <span class="hljs-keyword">break</span> <br>    &#125; <br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-获取链表长度"><a href="#6-获取链表长度" class="headerlink" title="6.获取链表长度"></a>6.获取链表长度</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 查看循环链表长度 </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Ring)</span></span> Len() <span class="hljs-type">int</span> &#123; <br>  n := <span class="hljs-number">0</span> <br>  <span class="hljs-keyword">if</span> r != <span class="hljs-literal">nil</span> &#123;<br>    n = <span class="hljs-number">1</span> <br>    <span class="hljs-keyword">for</span> p := r.Next(); p != r; p = p.next &#123; <br>      n++ <br>    &#125; <br>  &#125;<br>  <span class="hljs-keyword">return</span> n <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ol><li>新建一个链表ChainList，输入一组数据，并输入m，实现从第m个数及往后数据的倒序(不允许使用数组，不允许新建链表，在原有链表上实现逆置)</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//示例</span><br>输入数的个数：<span class="hljs-number">9</span><br>数据为：<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span><br>m值为：<span class="hljs-number">5</span><br>倒叙后输出：<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span> <span class="hljs-number">8</span> <span class="hljs-number">7</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><ol><li><p>链表排序</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/sort_list_2.jpg" alt="img"></p></li><li><p>使用单链表实现集合的交、并、差运算</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//示例</span><br>Set1 = <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">6</span><br>Set1 = <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">8</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span><br>Set1∩Set2 = <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span><br>Set1∪Set2 = <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span> <span class="hljs-number">8</span> <span class="hljs-number">5</span> <br>Set1-Set2 = <span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span><br>Set2-Set1 = <span class="hljs-number">3</span> <span class="hljs-number">8</span> <span class="hljs-number">5</span> <br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Go项目包管理方法</title>
    <link href="/2022/12/18/Go%E9%A1%B9%E7%9B%AE%E5%8C%85%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95/"/>
    <url>/2022/12/18/Go%E9%A1%B9%E7%9B%AE%E5%8C%85%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="企业级Go项目包管理方法"><a href="#企业级Go项目包管理方法" class="headerlink" title="企业级Go项目包管理方法"></a>企业级Go项目包管理方法</h1><h2 id="Go包管理困境"><a href="#Go包管理困境" class="headerlink" title="Go包管理困境"></a>Go包管理困境</h2><ul><li>没有统一的包管理方式</li><li>包之间的依赖关系很难维护</li><li>如果同时需要一个包的不同版本，很麻烦</li></ul><h2 id="尝试解决"><a href="#尝试解决" class="headerlink" title="尝试解决"></a>尝试解决</h2><ul><li>godep、govendor、glide</li><li>未彻底解决GOPATH问题</li><li>使用起来麻烦</li></ul><h2 id="Go-Modules"><a href="#Go-Modules" class="headerlink" title="Go Modules"></a>Go Modules</h2><ul><li>本质上Go包就是一个项目的源码</li><li>go mod作用：将Go包和Git项目关联起来</li><li>Go包的版本就是git项目的Tag</li><li>go mod解决：需要哪个git项目的什么版本</li></ul><h2 id="使用Modules"><a href="#使用Modules" class="headerlink" title="使用Modules"></a>使用Modules</h2><p>项目地址</p><ul><li>github.com/Jeffail/tunny</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs g">go get github.com/Jeffail/tunny<br><br>go get github.com/Jeffail/tunny@0.1.3<br></code></pre></td></tr></table></figure><h2 id="Github无法访问"><a href="#Github无法访问" class="headerlink" title="Github无法访问"></a>Github无法访问</h2><ul><li>使用goproxy.cn作为代理</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">go env -w GOPROXY=https:<span class="hljs-regexp">//g</span>oporxy.cn,direct<br></code></pre></td></tr></table></figure><h2 id="使用本地文件替代"><a href="#使用本地文件替代" class="headerlink" title="使用本地文件替代"></a>使用本地文件替代</h2><ul><li>go.mod 文件追加</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">replace</span> github.com/Jeffail/<span class="hljs-function"><span class="hljs-params">tunny</span> =&gt;</span> xxx/xxx<br></code></pre></td></tr></table></figure><ul><li>go vendor 缓存到本地</li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">go</span> <span class="hljs-built_in">mod</span> vendor<br><br><span class="hljs-built_in">go</span> build -<span class="hljs-built_in">mod</span> vendor<br></code></pre></td></tr></table></figure><h2 id="创建Go-Module"><a href="#创建Go-Module" class="headerlink" title="创建Go Module"></a>创建Go Module</h2><ul><li>删除本地go.mod</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-keyword">mod</span> init github.<span class="hljs-keyword">com</span>/仓库地址路径<br></code></pre></td></tr></table></figure><ul><li><p>推送至代码仓库</p></li><li><p>增加新版本，在仓库打新Tag</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Go程序如何运行</title>
    <link href="/2022/12/17/Go%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C/"/>
    <url>/2022/12/17/Go%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Go程序如何运行？"><a href="#Go程序如何运行？" class="headerlink" title="Go程序如何运行？"></a>Go程序如何运行？</h1><h2 id="Go程序的入口"><a href="#Go程序的入口" class="headerlink" title="Go程序的入口"></a>Go程序的入口</h2><p>第一行代码在runtime包中</p><p><strong>runtime/rt0_XXX.s</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221217112513003.png" alt="image-20221217112513003"></p><p></p><h2 id="读取命令行参数"><a href="#读取命令行参数" class="headerlink" title="读取命令行参数"></a>读取命令行参数</h2><ul><li>复制参数数量argc和参数值argv到栈上</li></ul><h2 id="初始化g0执行栈"><a href="#初始化g0执行栈" class="headerlink" title="初始化g0执行栈"></a>初始化g0执行栈</h2><ul><li>g0是为了调度协程而产生的协程</li><li>g0是每个go语言的第一个协程</li></ul><h2 id="运行时检测"><a href="#运行时检测" class="headerlink" title="运行时检测"></a>运行时检测</h2><ul><li>检查各类型的长度</li><li>检查指针操作</li><li>检查结构体字段的偏移量</li><li>检查atomic原子操作</li><li>检查CAS操作</li><li>检查栈大小是否是2的幂次</li></ul><h2 id="参数初始化runtime-args"><a href="#参数初始化runtime-args" class="headerlink" title="参数初始化runtime.args"></a>参数初始化runtime.args</h2><ul><li>对命令行中的参数进行处理</li><li>参数数量赋值给<code>argc int32</code></li><li>参数值复制给<code>argv **byte</code></li></ul><h2 id="调度器初始化rumtime-shedinit"><a href="#调度器初始化rumtime-shedinit" class="headerlink" title="调度器初始化rumtime.shedinit"></a>调度器初始化rumtime.shedinit</h2><ul><li>全局栈空间内存分配</li><li>加载命令行参数到os.Args</li><li>堆内存空间的初始化</li><li>加载操作系统环境变量</li><li>初始化当前系统线程</li><li>垃圾回收器的参数初始化</li><li>算法初始化（map、hash）</li><li>设置process数量</li></ul><h2 id="创建主协程"><a href="#创建主协程" class="headerlink" title="创建主协程"></a>创建主协程</h2><ul><li>创建一个新的协程，执行runtime.main</li><li>放入调度器等待调度</li></ul><h2 id="初始化M"><a href="#初始化M" class="headerlink" title="初始化M"></a>初始化M</h2><ul><li>初始化一个M，用来调度主协程</li></ul><h2 id="主协程执行主函数"><a href="#主协程执行主函数" class="headerlink" title="主协程执行主函数"></a>主协程执行主函数</h2><ul><li>执行runtime包中的init方法</li><li>启动GC垃圾收集器</li><li>执行用户包依赖的init方法</li><li>执行用户主函数main.main()</li></ul>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Go程序如何编译</title>
    <link href="/2022/12/17/Go%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91/"/>
    <url>/2022/12/17/Go%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h1 id="Go程序如何编译"><a href="#Go程序如何编译" class="headerlink" title="Go程序如何编译"></a>Go程序如何编译</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br>&#123;<br>fmt.Println(<span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>go build -n</code></p><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221217102250779.png" alt="image-20221217102250779"></p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><ul><li>将源码翻译成Token</li><li>Token是代码中最小的语义结构</li></ul><h3 id="句法分析"><a href="#句法分析" class="headerlink" title="句法分析"></a>句法分析</h3><ul><li><p>Token序列经过处理，变成语法树(SST)</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221217102634690.png" alt="image-20221217102634690"></p></li></ul><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><ul><li>类型检查</li><li>类型推断</li><li>查看类型是否匹配</li><li>函数调用内联</li><li>逃逸分析</li></ul><h3 id="中间码生成"><a href="#中间码生成" class="headerlink" title="中间码生成"></a>中间码生成</h3><ul><li>为了处理不同平台的差异，先生成中间代码(SSA)</li><li>查看从代码到SSA中间码的整个过程</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-variable">$env</span>:<span class="hljs-attribute">GOSSAFUNG</span>=<span class="hljs-string">&quot;main&quot;</span><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">GOSSAFUNC</span>=main<br>go build<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221217103726909.png" alt="image-20221217103726909"></p><h3 id="机器码生成"><a href="#机器码生成" class="headerlink" title="机器码生成"></a>机器码生成</h3><ul><li><p>生成Plan9汇编代码</p></li><li><p>最后编译为机器码</p></li><li><p>输出的机器码为.a文件</p></li><li><p>查看Plan9汇编代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> build -gcflags -S main.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul><li>将各个包进行链接，包括runtime</li></ul>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>runtime</title>
    <link href="/2022/12/17/runtime/"/>
    <url>/2022/12/17/runtime/</url>
    
    <content type="html"><![CDATA[<ul><li>Runtime 就是程序的运行环境</li><li>Java：Java虚拟机</li><li>JavaScript：浏览器内核</li></ul><h1 id="Go的Runtime特点"><a href="#Go的Runtime特点" class="headerlink" title="Go的Runtime特点"></a>Go的Runtime特点</h1><ul><li>go没有虚拟机概念</li><li>Runtime作为程序的一部分打包进二进制产物</li><li>Runtime随用户程序一起运行</li><li>Runtime与用户程序没有明显界限，直接通过函数调用</li></ul><h1 id="Go的Runtime能力"><a href="#Go的Runtime能力" class="headerlink" title="Go的Runtime能力"></a>Go的Runtime能力</h1><ul><li>内存管理能力</li><li>垃圾回收能力（GC）</li><li>超强的并发能力（协程调度）</li></ul><h1 id="Go的Runtime其他特点"><a href="#Go的Runtime其他特点" class="headerlink" title="Go的Runtime其他特点"></a>Go的Runtime其他特点</h1><ul><li>Runtime有一定的屏蔽系统调用能力</li><li>一些go的关键字其实是Runtime下的函数</li></ul><div class="table-container"><table><thead><tr><th>关键字</th><th>函数</th></tr></thead><tbody><tr><td>go</td><td>newproc</td></tr><tr><td>new</td><td>newobject</td></tr><tr><td>make</td><td>makeslice，makechain，makemap</td></tr><tr><td>&lt;-</td><td>chansend1,chanrecv1</td></tr></tbody></table></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Go的Runtime负责内存管理、垃圾回收、协程调度</li><li>Go的Runtime被编译为用户程序的一部分，一起运行</li></ul>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++异常类型以及多级catch匹配</title>
    <link href="/2022/11/30/C++%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E5%A4%9A%E7%BA%A7catch%E5%8C%B9%E9%85%8D/"/>
    <url>/2022/11/30/C++%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E5%A4%9A%E7%BA%A7catch%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="C-异常类型以及多级catch匹配"><a href="#C-异常类型以及多级catch匹配" class="headerlink" title="C++异常类型以及多级catch匹配"></a>C++异常类型以及多级catch匹配</h1><p><code>try-catch</code>使用方法</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">//</span><br>&#125;<span class="hljs-keyword">catch</span>(exceptionType <span class="hljs-keyword">variable</span>)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01深入理解神经网络原理</title>
    <link href="/2022/11/18/01%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"/>
    <url>/2022/11/18/01%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解神经网络原理"><a href="#深入理解神经网络原理" class="headerlink" title="深入理解神经网络原理"></a>深入理解神经网络原理</h1><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221119000842671.png" alt="image-20221119000842671"></p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>方法</title>
    <link href="/2022/11/17/%E6%96%B9%E6%B3%95/"/>
    <url>/2022/11/17/%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p><strong>重点</strong>：面向对象编程（OOP：Object Oriented Programming）</p><p>不同于C++和Java的<code>Class</code>类写法，</p><h2 id="1-方法声明"><a href="#1-方法声明" class="headerlink" title="1.方法声明"></a>1.方法声明</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;math&quot;</span><br><br><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span> &#123;<br>X, Y <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Distance</span><span class="hljs-params">(p, q Point)</span></span> <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Point)</span></span> Distance(q Point) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)<br>&#125;<br></code></pre></td></tr></table></figure><p>此处11行的代码，有一个<code>Point</code>类型的变量为<code>p</code>，此处的<code>p</code>名为方法的接收器<code>receiver</code>，早期也被称为”向一个对象发送消息”。</p><p>此处我们来看一下C++的写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span><br>&#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">float</span> X, Y;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y);<br>    <span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">Distance</span><span class="hljs-params">(Point q)</span></span>;<br>&#125;;<br><br>Point::<span class="hljs-built_in">Point</span>(<span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y)<br>&#123;<br>    X = x;<br>    Y = y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">Point::Distance</span><span class="hljs-params">(Point q)</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hypot</span>(X - q.X, Y - q.Y);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Point <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">Point <span class="hljs-title">q</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)</span></span>;<br>    cout &lt;&lt; p.<span class="hljs-built_in">Distance</span>(q) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>视线回到go</p><p>我们来测试一下上面的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">p := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>q := Point&#123;<span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;<br>fmt.Println(Distance(p, q)) <span class="hljs-comment">// &quot;5&quot;, function call</span><br>fmt.Println(p.Distance(q)) <span class="hljs-comment">// &quot;5&quot;, method call</span><br></code></pre></td></tr></table></figure><p>第三行调用的是函数，第四行调用的是方法，它俩没有产生任何冲突，仅仅是名字相同，一个是简单的函数运算，一个是Point类下的指定方法。</p><p><code>p.Distance(q)</code>被称为选择器，只有对应的类型才能够使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Path []Point<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(path Path)</span></span> Distance() <span class="hljs-type">float64</span> &#123;<br>sum := <span class="hljs-number">0.0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> path &#123;<br><span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &#123;<br>sum += path[i<span class="hljs-number">-1</span>].Distance(path[i])<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> sum<br><br>&#125;<br></code></pre></td></tr></table></figure><p>此处<code>Point</code>是一个<code>slice</code>类型，虽然不是结构体，但是依然可以定义方法。</p><p>其实任何类型都可以定义方法，只要不是指针和<code>interface&#123;&#125;</code></p><p>此处的<code>Distance()</code>是特定于<code>Path</code>的方法</p><p>如果是对于同一类型,内部方法必须使用唯一方法名，但是如果是不同类型，方法名可以相同</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//举例</span><br></code></pre></td></tr></table></figure><h2 id="2-基于指针对象的方法"><a href="#2-基于指针对象的方法" class="headerlink" title="2.基于指针对象的方法"></a>2.基于指针对象的方法</h2><p>调用函数时，会拷贝参数值，但是如果函数需要修改一个变量或者变量太大，这个时候就需要使用指针，通过地址直接修改变量。</p><p>如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Point)</span></span> ScaleBy(factor <span class="hljs-type">float64</span>) &#123;<br>p.X *= factor<br>p.Y *= factor<br>&#125;<br></code></pre></td></tr></table></figure><p>现实之中，如果一个<code>Point</code>的类含有一个指针作为接收器的方法，理论上其余的方法也都应该以指针作为接收器方法。</p><p>特别注意，如果一个类型名本身就是一个指针，是不能够出现在接收器之中的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> P *<span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(P)</span></span> f() &#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>想要使用<code>Point</code>的指针接收器，只需要提供<code>Point</code> 类型的指针即可</p><p>如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">r := &amp;Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>r.ScaleBy(<span class="hljs-number">2</span>)<br>fmt.Println(*r)<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">p := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>pptr := &amp;p<br>pptr.ScaleBy(<span class="hljs-number">2</span>)<br>fmt.Println(p)<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">p := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>(&amp;p).ScaleBy(<span class="hljs-number">2</span>)<br>fmt.Println(p)<br></code></pre></td></tr></table></figure><p>不过后面两种方法略显笨拙，以下为简短写法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">p.ScaleBy(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>编译器会<strong>隐式地帮我们用&amp;p</strong> 去调用 ScaleBy 这个方法。这种简写方法只适用于“变量”，包括struct 里的字段比如 p.X，以及 array 和 slice 内的元素比如 perim[0]。我们不能通过一个无法取到地址的接收器来调用指针方法，比如<strong>临时变量的内存地址</strong>就无法获取得到：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;.ScaleBy(<span class="hljs-number">2</span>) <br></code></pre></td></tr></table></figure><p>但是我们可以用一个<em>Point 这样的接收器来调用 Point 的方法，因为我们可以通过地址来找到这个变量，只要用解引用符号</em>来取到该变量即可。编译器在这里也会给我们<strong>隐式地插入*这个操作符</strong>，所以下面这两种写法等价的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">pptr.Distance(q)<br>(*pptr).Distance(q)<br></code></pre></td></tr></table></figure><h2 id="3-通过嵌入结构体来扩展类型"><a href="#3-通过嵌入结构体来扩展类型" class="headerlink" title="3.通过嵌入结构体来扩展类型"></a>3.通过嵌入结构体来扩展类型</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;image/color&quot;</span><br><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span>&#123; X, Y <span class="hljs-type">float64</span> &#125;<br><span class="hljs-keyword">type</span> ColoredPoint <span class="hljs-keyword">struct</span> &#123;<br> Point<br> Color color.RGBA<br>&#125;<br></code></pre></td></tr></table></figure><p>本来可以将颜色点定义为含有<code>X</code>、<code>Y</code>、<code>Color</code>三个字段的结构体，但是我们可以把<code>Point</code>嵌套放入<code>ColoredPoint</code>之中。</p><p>在声明的时候，我们不需要再定义<code>Point</code>，而是可以直接使用<code>ColoredPoint</code>定义<code>X</code>、<code>Y</code>，</p><p>​    对于 Point 中的方法我们也有类似的用法，我们可以把 ColoredPoint 类型当作接收器来调用Point 里的方法，即使 ColoredPoint 里没有声明这些方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">red := color.RGBA&#123;<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>&#125;<br><br>blue := color.RGBA&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>&#125;<br><br><span class="hljs-keyword">var</span> p = ColoredPoint&#123;Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, red&#125;<br><br><span class="hljs-keyword">var</span> q = ColoredPoint&#123;Point&#123;<span class="hljs-number">5</span>, <span class="hljs-number">4</span>&#125;, blue&#125;<br><br>fmt.Println(p.Distance(q.Point)) <br><br>p.ScaleBy(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>展示可以看出<code>Point</code>类的方法都被引入到了<code>ColoredPoint</code>之中</p><p>此处涉及到面向对象的知识，<code>Point</code>被称之为基类，而<code>ColoredPoint</code>被称之为子类。</p><p>刚刚的调用等价于</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p ColoredPoint)</span></span> Distance(q Point) <span class="hljs-type">float64</span> &#123;<br> <span class="hljs-keyword">return</span> p.Point.Distance(q)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *ColoredPoint)</span></span> ScaleBy(factor <span class="hljs-type">float64</span>) &#123;<br> p.Point.ScaleBy(factor)<br>&#125;<br></code></pre></td></tr></table></figure><p>当 Point.Distance 被第一个包装方法调用时，它的接收器值是 p.Point，而不是 p，当然了，在 Point 类的方法里，你是访问不到 ColoredPoint 的任何字段的。</p><p>在类型中内嵌的匿名字段也可能是一个命名类型的指针，这种情况下字段和方法会被间接地引入到当前的类型中。添加这一层间接关系让我们可以共享通用的结构并动态地改变对象之间的关系。下面这个 ColoredPoint 的声明内嵌了一个*Point 的指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ColoredPoint <span class="hljs-keyword">struct</span> &#123;<br><br> *Point<br><br> Color color.RGBA<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最大子序和</title>
    <link href="/2022/11/12/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <url>/2022/11/12/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h1><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出：6<br>解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[5,4,-1,7,8]</span><br>输出：<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p><h1 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h1><h2 id="解法一：DP"><a href="#解法一：DP" class="headerlink" title="解法一：DP"></a>解法一：DP</h2>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>验证栈序列</title>
    <link href="/2022/11/08/%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97/"/>
    <url>/2022/11/08/%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="验证栈序列"><a href="#验证栈序列" class="headerlink" title="验证栈序列"></a>验证栈序列</h1><p>给定 <code>pushed</code> 和 <code>popped</code> 两个序列，每个序列中的 <strong>值都不重复</strong>，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 <code>true</code>；否则，返回 <code>false</code> 。</p><h2 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h2><p><code>pushed</code>和<code>popped</code>的性质：</p><ul><li><code>pushed</code>中元素互不相同</li><li><code>popped</code>和<code>pushed</code>长度相同</li><li><code>popped</code>是数组<code>pushed</code>的一个排列</li></ul><p>结论：</p><ul><li>栈内无重复元素</li><li>如果<code>pushed</code>和<code>poped</code>是有效的栈操作序列，则经过所有的入栈和出栈操作之后，每个元素各入栈和出栈一次，栈为空</li></ul><p>方法：</p><p>因此，可以遍历两个数组，模拟入栈和出栈操作，判断两个数组是否为有效的栈操作序列。</p><p>模拟入栈操作可以通过遍历数组 <code>pushed</code>实现。由于只有栈顶的元素可以出栈，因此需要判断栈顶元素是否与<code>popped</code>的当前元素相同，如果相同则将栈顶元素出栈。由于元素互不相同，因此当前栈顶元素与<code>popped</code>的当前元素必须将栈顶元素出栈，否则出栈顺序一定不等于<code>popped</code>。</p><p>验证栈序列的模拟做法：</p><ol><li>遍历数组<code>pushed</code>，将<code>pushed</code>的每个元素一次入栈；</li><li>每次将<code>pushed</code>的元素入栈之后，如果栈不为空且栈顶元素与<code>popped</code>的当前元素相同，则将栈顶元素出栈，同时遍历数组<code>popped</code>，直到栈为空或栈顶元素与<code>popped</code>的当前元素不同。</li></ol><p>遍历数组<code>pushed</code>,每个元素都按照<code>pushed</code>的顺序入栈一次。如果结束以后，栈为空，则表明元素按照了<code>popped</code>顺序弹出，返回true，否则返回false。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">validateStackSequences</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;pushed, vector&lt;<span class="hljs-type">int</span>&gt; &amp;popped)</span></span><br><span class="hljs-function">    </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-type">int</span> n = pushed.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-comment">//插入数据</span><br>            <span class="hljs-comment">//能够避免产生不必要的临时变量</span><br>            st.<span class="hljs-built_in">emplace</span>(pushed[i]);<br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>() == popped[j])<br>            &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; pushed = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    vector&lt;<span class="hljs-type">int</span>&gt; popped = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>    <span class="hljs-type">bool</span> result;<br>    Solution solution;<br>    cout &lt;&lt; solution.<span class="hljs-built_in">validateStackSequences</span>(pushed, popped) &lt;&lt; endl;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>复杂度分析:</p><ul><li>时间复杂度O(n)</li><li>空间负责度O(n)，取决于栈的大小for (int x: nums) </li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Uninformed Search</title>
    <link href="/2022/11/02/Uninformed-Search/"/>
    <url>/2022/11/02/Uninformed-Search/</url>
    
    <content type="html"><![CDATA[<h1 id="Artificial-Intelligence-Search"><a href="#Artificial-Intelligence-Search" class="headerlink" title="Artificial Intelligence Search"></a>Artificial Intelligence Search</h1><h2 id="Agents-that-Plan-Ahead"><a href="#Agents-that-Plan-Ahead" class="headerlink" title="Agents that Plan Ahead"></a>Agents that Plan Ahead</h2><ul><li><h3 id="Reflex-Agent"><a href="#Reflex-Agent" class="headerlink" title="Reflex Agent:"></a>Reflex Agent:</h3><ul><li><p>Choose action based on current percept</p></li><li><p>May have memory or a model of the world’s current state</p></li><li>Do not consider the future consequences of their actions</li><li>Consider how the world IS</li></ul></li><li><h3 id="Planning-Agents"><a href="#Planning-Agents" class="headerlink" title="Planning Agents"></a>Planning Agents</h3><ul><li>Ask “what if”</li><li>Decisions based on (hypothesized假设) consequences of actions</li></ul></li></ul><h2 id="Search-Problems"><a href="#Search-Problems" class="headerlink" title="Search Problems"></a>Search Problems</h2><ul><li><h2 id="Uniformed-Search-Methods"><a href="#Uniformed-Search-Methods" class="headerlink" title="Uniformed Search Methods"></a>Uniformed Search Methods</h2></li><li><h3 id="Depth-First-Search"><a href="#Depth-First-Search" class="headerlink" title="Depth-First Search"></a>Depth-First Search</h3></li><li><h3 id="Breadth-First-Search"><a href="#Breadth-First-Search" class="headerlink" title="Breadth-First Search"></a>Breadth-First Search</h3></li><li><h3 id="Uniform-Cost-Search"><a href="#Uniform-Cost-Search" class="headerlink" title="Uniform-Cost Search"></a>Uniform-Cost Search</h3></li></ul>]]></content>
    
    
    <categories>
      
      <category>CS188</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Network Programming PartII</title>
    <link href="/2022/10/25/Network-Programming-PartII/"/>
    <url>/2022/10/25/Network-Programming-PartII/</url>
    
    <content type="html"><![CDATA[<h1 id="Network-Programming-PartII"><a href="#Network-Programming-PartII" class="headerlink" title="Network Programming PartII"></a>Network Programming PartII</h1><h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221025212319689.png" alt="image-20221025212319689"></h1><h2 id="Socket-Interface"><a href="#Socket-Interface" class="headerlink" title="Socket Interface"></a>Socket Interface</h2><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221025214427236.png" alt=" ">    </p><p>This giant block diagram shows all the activities invloved in setting up and running both a server and a client.</p><p>The idead is you need to the server needs to fire up .You can’t contact the server until the server exists.</p><p> A server begins on a machine and then accepts a connection request from a client.</p><p>Each end looks like reading and writing a file.</p><p>Once the client is done with whatever it’s trying to get,it will disconnect.Then the listening server will detect this by receiving an end of file when it attempts to read from the client,then it will close the connection.</p><p> This it’s not going to shut down at this point ,it’s just going to return back and accept new connection request.This is what’s known as an interactive server,which can only handle a single client at a time. </p><p>The first step between client and server is very messy relatively new api call <code>getaddrinfo</code>.</p><p>It contains a lot of other sort of individual protocols.</p><p>It lets you sort of go forward from a domain name to a IP address and go backward from an IP address back to domain name.</p><h2 id="Recall"><a href="#Recall" class="headerlink" title="Recall"></a>Recall</h2><h3 id="Generic-socket-address"><a href="#Generic-socket-address" class="headerlink" title="Generic socket address"></a>Generic socket address</h3><ul><li><p>For address arguments to connect,bind,and accept</p></li><li><p>Necessary only because C did not have generic (void *)Pointers when the sockets interface was designed</p></li><li><p>For casting convenience,we adopt the Stevens convention:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> <span class="hljs-title">SA</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span>&#123;</span><br>  <span class="hljs-type">uint16_t</span>  sa_family; <span class="hljs-comment">//protocol family</span><br>  <span class="hljs-type">char</span> as_data[<span class="hljs-number">14</span>];<span class="hljs-comment">//Address data</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>寄存器</title>
    <link href="/2022/10/19/%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <url>/2022/10/19/%E5%AF%84%E5%AD%98%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p><img src="https://raw.githubusercontent.com/Hyeonwuu/Image/master/image-20221019161654005.png" alt="img"></p><p>一个字型数据可以存放在内存之中 可以由2个连续的地址内存单元组成</p><p><strong>高地址</strong>：内存单元存放字型数据的<strong>高位字节</strong></p><p><strong>低地址</strong>：内存单元存放字型数据的<strong>低位字节</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221019163034201.png" alt="image-20221019163034201"></p><h2 id="ds段地址寄存器"><a href="#ds段地址寄存器" class="headerlink" title="ds段地址寄存器"></a>ds段地址寄存器</h2><p>访问数据用的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov al,ds:[0];mov移动指令CPU中的AL寄存器，内存地址为ds:[0] 0为偏移地址，方括号是ds+0组合成的段地址，方括号内为得到的内容<br>;cpu从段寄存器内读取了8位数据<br></code></pre></td></tr></table></figure><p><strong>错误修改ds的方法</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221019164656493.png" alt="image-20221019164656493" style="zoom:25%;" /></strong></p><p><strong>正确方式，使用寄存器存储</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221019164806872.png" alt="image-20221019164806872" style="zoom:25%;" /></strong></p><p><strong>高位字节到高位地址，低位字节到低位地址</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221019165406196.png" alt="image-20221019165406196" style="zoom:25%;" /></strong></p><h2 id="寄存器ax-bx-cx"><a href="#寄存器ax-bx-cx" class="headerlink" title="寄存器ax bx cx"></a>寄存器ax bx cx</h2><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221019171548323.png" alt="image-20221019171548323"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax,1000H<br>mov ds,ax;获取段地址<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221019170350121.png" alt="image-20221019170350121" style="zoom:25%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221019170656087.png" alt="image-20221019170656087" style="zoom:50%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221019170543070.png" alt="image-20221019170543070"></p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p> 问题3.4</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221019171513948.png" alt="image-20221019171513948"></p>]]></content>
    
    
    <categories>
      
      <category>汇编语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>承上启下</title>
    <link href="/2022/10/19/%E6%89%BF%E4%B8%8A%E5%90%AF%E4%B8%8B/"/>
    <url>/2022/10/19/%E6%89%BF%E4%B8%8A%E5%90%AF%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="承上启下"><a href="#承上启下" class="headerlink" title="承上启下"></a>承上启下</h1><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>数据寄存器</p><p>地址寄存器</p><ul><li>段地址寄存器</li><li>偏移地址寄存器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;通用寄存器<br>AX <br>BX;偏移地址寄存器<br>CX;有其他作用<br>DX;和AX一起处理数据<br></code></pre></td></tr></table></figure><p>通用寄存器都为16位寄存器，可以分割为2个互相独立的8位寄存器</p><h2 id="翻译工作"><a href="#翻译工作" class="headerlink" title="翻译工作"></a>翻译工作</h2><p>保证数据与寄存器之间的位数一致</p><p>由寄存器的位数决定</p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov;移动指令<br>add;运算指令 <br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221019153653119.png" alt="image-20221019153653119" style="zoom:50%;" /></p><p>运算时超过寄存器的最大值，超过部分不会消失，存储到其他部分</p><p>ax与al相互独立，超过部分不会存入ah</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221019154053576.png" alt="image-20221019154053576" style="zoom:50%;" /></p><h3 id="地址寄存器"><a href="#地址寄存器" class="headerlink" title="地址寄存器"></a>地址寄存器</h3><ul><li>ds(data segment)</li><li>es(extern segment)</li><li>ss(stakc segment)</li><li>cs(code segment)</li></ul><h3 id="偏移地址寄存器"><a href="#偏移地址寄存器" class="headerlink" title="偏移地址寄存器"></a>偏移地址寄存器</h3><ul><li>sp</li><li>bp</li><li>si</li><li>di</li><li>ip</li><li>bx</li></ul><h3 id="组合规则：组合起来"><a href="#组合规则：组合起来" class="headerlink" title="组合规则：组合起来"></a>组合规则：组合起来</h3><p>段地址✖️16+偏移地址=<strong>物理地址</strong></p><h4 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h4><p>8086CPU有20根地址线</p><h3 id="CPU区分指令和数据："><a href="#CPU区分指令和数据：" class="headerlink" title="CPU区分指令和数据："></a>CPU区分指令和数据：</h3><p>依靠CS和IP两个寄存器</p><p>任意时刻的CPU将段地址寄存器CS和偏移地址寄存器IP所组合出的地址从中读取内容</p><p>并且全部当作指令执行</p><p>指令是有长度的，且与<strong>IP寄存器</strong>有关</p><p>可以用修改CS和IP两个寄存器的指令</p><p><strong>转移指令</strong>：<code>jmp</code>     <code>call</code></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;jmp格式<br>jmp2000:0<br>jmp[寄存器];相当于mov ip,ax<br><br>;call<br>call    ******<br>;1.CPU从CS:IP所指向的内存单元读取指令，存放到指令缓存器之中<br>;2.IP=IP+所读取指令的长度，从而指向下一条指令<br>;3.执行指令缓存器中的内容，回到步骤1<br></code></pre></td></tr></table></figure><h3 id="指令和数据"><a href="#指令和数据" class="headerlink" title="指令和数据"></a>指令和数据</h3><p>存放在内存之中没有任何区别</p><p>是程序员通过修改寄存器中的内容（地址寄存器），告诉CPU数据在哪里      指令在哪里 </p>]]></content>
    
    
    <categories>
      
      <category>汇编语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>debug调试工具使用总结</title>
    <link href="/2022/10/18/debug%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2022/10/18/debug%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="debug调试工具使用总结"><a href="#debug调试工具使用总结" class="headerlink" title="debug调试工具使用总结"></a>debug调试工具使用总结</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">r     ;查看和改变寄存器中的内容<br>d     ;查看内存中的内容<br>u;将内存中的机器指令翻译成汇编指令<br>a;以汇编指令格式在内存中写入一条汇编指令<br>t;执行当前CS:IP所指向的机器指令<br>e;可以改写内存中内容<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>汇编语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Colly</title>
    <link href="/2022/10/08/Colly/"/>
    <url>/2022/10/08/Colly/</url>
    
    <content type="html"><![CDATA[<h1 id="Colly"><a href="#Colly" class="headerlink" title="Colly"></a><a href="http://go-colly.org/">Colly</a></h1><h2 id="Fast-and-Elegant-Scraping-Framework-for-Gophers"><a href="#Fast-and-Elegant-Scraping-Framework-for-Gophers" class="headerlink" title="Fast and Elegant Scraping Framework for Gophers"></a>Fast and Elegant Scraping Framework for Gophers</h2><p>Colly provides a clean interface to write any kind of <strong>crawler/scraper/spider</strong></p><p>With Colly you can easily extract structured data from websites, which can be used for a wide range of applications, like data mining, data processing or archiving.</p><h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> -<span class="hljs-keyword">u</span> github.<span class="hljs-keyword">com</span>/gocolly/colly/...<br></code></pre></td></tr></table></figure><h2 id="Getting-started"><a href="#Getting-started" class="headerlink" title="Getting started"></a>Getting started</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/gocolly/colly&quot;</span><br></code></pre></td></tr></table></figure><h3 id="Collector"><a href="#Collector" class="headerlink" title="Collector"></a>Collector</h3><p>Colly’s main entity.</p><p>Manages the network communication and responsible for the execution of the attached callbacks while a collector job is running. </p><p>To work with colly, you have to initialize a <code>Collector</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">c := colly.NewCollector()<br></code></pre></td></tr></table></figure><h3 id="Callbacks"><a href="#Callbacks" class="headerlink" title="Callbacks"></a>Callbacks</h3><p>Attach different type of callback functions to a <code>Collector</code> to control a collecting job or retrieve information.</p><h4 id="Add-callbacks-to-a-Collector"><a href="#Add-callbacks-to-a-Collector" class="headerlink" title="Add callbacks to a Collector"></a>Add callbacks to a Collector</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 注册请求回调，每次发送请求时执行该回调</span><br>c.OnRequest(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r *colly.Request)</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Visiting&quot;</span>, r.URL)<br>&#125;)<br><br><span class="hljs-comment">// 注册错误回调，执行请求发生时执行该回调</span><br>c.OnError(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(_ *colly.Response, err <span class="hljs-type">error</span>)</span></span> &#123;<br>    log.Println(<span class="hljs-string">&quot;Something went wrong:&quot;</span>, err)<br>&#125;)<br><span class="hljs-comment">// 注册响应回调，每次收到响应时执行该回调</span><br>c.OnResponse(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r *colly.Response)</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Visited&quot;</span>, r.Request.URL)<br>&#125;)<br><span class="hljs-comment">// 注册HTML回调，对每一个href属性的a元素执行回调函数。</span><br>c.OnHTML(<span class="hljs-string">&quot;a[href]&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(e *colly.HTMLElement)</span></span> &#123;<br>    e.Request.Visit(e.Attr(<span class="hljs-string">&quot;href&quot;</span>))<br>&#125;)<br><span class="hljs-comment">// CSS选择器</span><br>c.OnHTML(<span class="hljs-string">&quot;tr td:nth-of-type(1)&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(e *colly.HTMLElement)</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;First column of a table row:&quot;</span>, e.Text)<br>&#125;)<br><span class="hljs-comment">// 如果接收到的内容是HTML或XML ,则在之后调用(非必需)</span><br>c.OnXML(<span class="hljs-string">&quot;//h1&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(e *colly.XMLElement)</span></span> &#123;<br>    fmt.Println(e.Text)<br>&#125;)<br><span class="hljs-comment">// OnXML回调后调用(非必需)</span><br>c.OnScraped(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r *colly.Response)</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Finished&quot;</span>, r.Request.URL)<br>&#125;)<br><br></code></pre></td></tr></table></figure><h2 id="Combat"><a href="#Combat" class="headerlink" title="Combat"></a>Combat</h2><h2 id="豆瓣"><a href="#豆瓣" class="headerlink" title="豆瓣"></a>豆瓣</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;github.com/PuerkitoBio/goquery&quot;</span><br><span class="hljs-string">&quot;github.com/gocolly/colly&quot;</span><br><span class="hljs-string">&quot;github.com/gocolly/colly/extensions&quot;</span><br><span class="hljs-string">&quot;regexp&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>t := time.Now()<br>number := <span class="hljs-number">1</span><br><br>c := colly.NewCollector(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *colly.Collector)</span></span> &#123;<br>extensions.RandomUserAgent(c) <span class="hljs-comment">// 设置随机头</span><br>c.Async = <span class="hljs-literal">true</span><br>&#125;,<br><span class="hljs-comment">//过滤url,去除不是https://movie.douban.com/top250?start=0&amp;filter= 的url</span><br>colly.URLFilters(<br>regexp.MustCompile(<span class="hljs-string">&quot;^(https://movie\\.douban\\.com/top250)\\?start=[0-9].*&amp;filter=&quot;</span>),<br>),<br>) <span class="hljs-comment">// 创建收集器</span><br><span class="hljs-comment">// 响应的格式为HTML,提取页面中的链接</span><br>c.OnHTML(<span class="hljs-string">&quot;a[href]&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(e *colly.HTMLElement)</span></span> &#123;<br>link := e.Attr(<span class="hljs-string">&quot;href&quot;</span>)<br><span class="hljs-comment">//fmt.Printf(&quot;find link: %s\n&quot;, e.Request.AbsoluteURL(link))</span><br>c.Visit(e.Request.AbsoluteURL(link))<br>&#125;)<br><span class="hljs-comment">// 获取电影信息</span><br>c.OnHTML(<span class="hljs-string">&quot;div.info&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(e *colly.HTMLElement)</span></span> &#123;<br>e.DOM.Each(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>, selection *goquery.Selection)</span></span> &#123;<br>movies := selection.Find(<span class="hljs-string">&quot;span.title&quot;</span>).First().Text()<br>director := strings.Join(strings.Fields(selection.Find(<span class="hljs-string">&quot;div.bd p&quot;</span>).First().Text()), <span class="hljs-string">&quot; &quot;</span>)<br>quote := selection.Find(<span class="hljs-string">&quot;p.quote span.inq&quot;</span>).Text()<br>fmt.Printf(<span class="hljs-string">&quot;%d --&gt; %s:%s %s\n&quot;</span>, number, movies, director, quote)<br>number += <span class="hljs-number">1</span><br>&#125;)<br>&#125;)<br>c.OnError(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(response *colly.Response, err <span class="hljs-type">error</span>)</span></span> &#123;<br>fmt.Println(err)<br>&#125;)<br>  <span class="hljs-comment">// 最后我们调用c.Visit()开始访问第一个页面</span><br>c.Visit(<span class="hljs-string">&quot;https://movie.douban.com/top250?start=0&amp;filter=&quot;</span>)<br>c.Wait()<br>fmt.Printf(<span class="hljs-string">&quot;花费时间:%s&quot;</span>, time.Since(t))<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Step1-创建收集器"><a href="#Step1-创建收集器" class="headerlink" title="Step1 创建收集器"></a>Step1 创建收集器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">c := colly.NewCollector(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *colly.Collector)</span></span> &#123;<br>extensions.RandomUserAgent(c) <span class="hljs-comment">// 设置随机头</span><br>c.Async = <span class="hljs-literal">true</span><br>&#125;,<br><span class="hljs-comment">//过滤url,去除不是https://movie.douban.com/top250?start=0&amp;filter= 的url</span><br>colly.URLFilters(<br>      <span class="hljs-comment">// 正则表达</span><br>regexp.MustCompile(<span class="hljs-string">&quot;^(https://movie\\.douban\\.com/top250)\\?start=[0-9].*&amp;filter=&quot;</span>),<br>),<br>)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221008140519140.png" style="zoom: 50%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221008153946515.png" alt="image-20221008153946515"></p><h3 id="Step2-HTML回调"><a href="#Step2-HTML回调" class="headerlink" title="Step2 HTML回调"></a>Step2 HTML回调</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 响应的格式为HTML,提取页面中的链接</span><br>c.OnHTML(<span class="hljs-string">&quot;a[href]&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(e *colly.HTMLElement)</span></span> &#123;<br>link := e.Attr(<span class="hljs-string">&quot;href&quot;</span>)<br><span class="hljs-comment">//fmt.Printf(&quot;find link: %s\n&quot;, e.Request.AbsoluteURL(link))</span><br>c.Visit(e.Request.AbsoluteURL(link))<br>&#125;)<br><span class="hljs-comment">// 获取电影信息</span><br>c.OnHTML(<span class="hljs-string">&quot;div.info&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(e *colly.HTMLElement)</span></span> &#123;<br>e.DOM.Each(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>, selection *goquery.Selection)</span></span> &#123;<br>movies := selection.Find(<span class="hljs-string">&quot;span.title&quot;</span>).First().Text()<br>director := strings.Join(strings.Fields(selection.Find(<span class="hljs-string">&quot;div.bd p&quot;</span>).First().Text()), <span class="hljs-string">&quot; &quot;</span>)<br>quote := selection.Find(<span class="hljs-string">&quot;p.quote span.inq&quot;</span>).Text()<br>fmt.Printf(<span class="hljs-string">&quot;%d --&gt; %s:%s %s\n&quot;</span>, number, movies, director, quote)<br>number += <span class="hljs-number">1</span><br>&#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;hd&quot;</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://movie.douban.com/subject/1291546/&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>霸王别姬<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;other&quot;</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>/<span class="hljs-symbol">&amp;nbsp;</span>再见，我的妾  /  Farewell My Concubine<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;playable&quot;</span>&gt;</span>[可播放]<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bd&quot;</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>                            导演: 陈凯歌 Kaige Chen<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsqp;</span>主演: 张国荣 Leslie Cheung / 张丰毅 Fengyi Zha...<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>                            1993<span class="hljs-symbol">&amp;nbsp;</span>/<span class="hljs-symbol">&amp;nbsp;</span>中国大陆 中国香港<span class="hljs-symbol">&amp;nbsp;</span>/<span class="hljs-symbol">&amp;nbsp;</span>剧情 爱情 同性<br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>                        <br>                        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;star&quot;</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rating5-t&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rating_num&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;v:average&quot;</span>&gt;</span>9.6<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;v:best&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;10.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>2008403人评价<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;quote&quot;</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;inq&quot;</span>&gt;</span>风华绝代。<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Step3-错误处理，回调页面"><a href="#Step3-错误处理，回调页面" class="headerlink" title="Step3 错误处理，回调页面"></a>Step3 错误处理，回调页面</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">c.OnError(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(response *colly.Response, err <span class="hljs-type">error</span>)</span></span> &#123;<br>fmt.Println(err)<br>&#125;)<br>c.Visit(<span class="hljs-string">&quot;https://movie.douban.com/top250?start=0&amp;filter=&quot;</span>)<br>c.Wait()<br>fmt.Printf(<span class="hljs-string">&quot;花费时间:%s&quot;</span>, time.Since(t))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Colly</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第2章 寻址方式</title>
    <link href="/2022/09/12/%E7%AC%AC2%E7%AB%A0-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/09/12/%E7%AC%AC2%E7%AB%A0-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h1><h2 id="1-直接寻址"><a href="#1-直接寻址" class="headerlink" title="1.直接寻址"></a>1.直接寻址</h2>]]></content>
    
    
    <categories>
      
      <category>汇编语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第1章 预备知识</title>
    <link href="/2022/09/03/%E7%AC%AC1%E7%AB%A0-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/09/03/%E7%AC%AC1%E7%AB%A0-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="第1章-预备知识"><a href="#第1章-预备知识" class="headerlink" title="第1章    预备知识"></a>第1章    预备知识</h1><h2 id="1-1-机器语言与汇编语言"><a href="#1-1-机器语言与汇编语言" class="headerlink" title="1.1 机器语言与汇编语言"></a>1.1 机器语言与汇编语言</h2><h3 id="1-1-1-机器语言"><a href="#1-1-1-机器语言" class="headerlink" title="1.1.1 机器语言"></a>1.1.1 机器语言</h3><p>机器指令：操作码 + 地址码</p><p>指令的全体为计算机的<strong>指令系统</strong></p><p>指令集合为<strong>机器语言</strong></p><p><strong>机器语言程序</strong></p><h3 id="1-1-2-汇编语言"><a href="#1-1-2-汇编语言" class="headerlink" title="1.1.2 汇编语言"></a>1.1.2 汇编语言</h3><p><strong>助记符</strong>表示机器指令的<strong>操作码</strong>；用变量代替操作数的<strong>存放地址</strong>；在指令前冠以<strong>标号</strong>， 用来代表该指令的存放地址等。 </p><p><strong>指令助记符、语句标号、数据变量、伪指令</strong>及它们的使用规则构成了整个汇编语言的内容。</p><h2 id="1-2-Intel系列机"><a href="#1-2-Intel系列机" class="headerlink" title="1.2 Intel系列机"></a>1.2 Intel系列机</h2><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220903152705420.png" alt="image-20220903152705420"></p><h3 id="1-2-1-Intel-80X86-微处理器简介"><a href="#1-2-1-Intel-80X86-微处理器简介" class="headerlink" title="1.2.1 Intel 80X86 微处理器简介"></a>1.2.1 Intel 80X86 微处理器简介</h3><p><strong>8086</strong>:16位CPU</p><p><strong>80286</strong>:直接寻址16MB贮存，含有四个独立处理部件：执行部件、总线部件、指令部件和地址部件</p><p>提供两种工作方式：<strong>实地址方式和保护方式</strong></p><h3 id="1-2-2-Intel-80X86微处理结构"><a href="#1-2-2-Intel-80X86微处理结构" class="headerlink" title="1.2.2 Intel 80X86微处理结构"></a>1.2.2 Intel 80X86微处理结构</h3><p>32位CPU分为六大部件：</p><ul><li>总线接口部件</li><li>执行部件</li><li>指令预取部件</li><li>指令编译部件</li><li>分段部件</li><li>分页部件</li></ul><h4 id="1-总线接口部件"><a href="#1-总线接口部件" class="headerlink" title="1.总线接口部件"></a>1.总线接口部件</h4><p>CPU与整个计算机系统之间的高速接口</p><p>接受总线请求，按有限权进行选择，最大限度利用本身资源位请求服务</p><h4 id="2-执行部件"><a href="#2-执行部件" class="headerlink" title="2.执行部件"></a>2.执行部件</h4><h5 id="（1）数据寄存器组-EAX、EBX、ECX、EDX"><a href="#（1）数据寄存器组-EAX、EBX、ECX、EDX" class="headerlink" title="（1）数据寄存器组(EAX、EBX、ECX、EDX)"></a>（1）数据寄存器组(EAX、EBX、ECX、EDX)</h5><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220903154542135.png" alt="image-20220903154542135"></p><p>EAX(Accumulator)：暂存</p><p>EBX(Base):</p><p>ECX(Count)：标志循环次数上届</p><p>EDX(Data):保存操作数</p><h5 id="2-指示器编制寄存器组-ESI、EDI、ESP、EBP"><a href="#2-指示器编制寄存器组-ESI、EDI、ESP、EBP" class="headerlink" title="(2)指示器编制寄存器组(ESI、EDI、ESP、EBP)"></a>(2)指示器编制寄存器组(ESI、EDI、ESP、EBP)</h5><p>存放操作数的偏移地址，用作指示器或变址寄存器。</p><ul><li>ESP：堆栈指示器，栈顶指针</li><li>EBP：基址寄存器，存放存储单元的偏移地址</li><li>ESI和EDI:指示器、变址寄存器</li><li>ESI用作取源操作数的指示器，源变址寄存器</li><li>EDI用作送目的操作数的指示器，目的变址寄存器</li></ul><h4 id="3-指令预取部件和指令译码部件"><a href="#3-指令预取部件和指令译码部件" class="headerlink" title="3.指令预取部件和指令译码部件"></a>3.指令预取部件和指令译码部件</h4><ul><li>指令<strong>预取</strong>部件：把<strong>将要执行</strong>的指令从主存之中取出，送入指令排队机构中排队（此处为复杂的排队系统）</li><li>指令<strong>译码</strong>部件：从预取指令队列中读<strong>出指令并译码</strong>，再送入译码指令队列排队供执行部件使用</li></ul><p>独取指令时，用到很重要的寄存器——<strong>指令指示器</strong></p><p>保存下一条将要被CPU执行的指令的偏移地址（EA）</p><p>16位代码段之中，指令指示器也为16位，称为IP，可以表示64k的偏移地址</p><p>32位代码段之中，EIP，表示4G的偏移地址</p><h4 id="4-分段部件、分页部件"><a href="#4-分段部件、分页部件" class="headerlink" title="4.分段部件、分页部件"></a>4.分段部件、分页部件</h4><p>程序投入运行时，系统会为每个程序分配一片独立的虚拟内存空间</p><p>只有主存中的程序和数据才能够被访问，所以在执行某一程序或访问某一数据，必须要将其所在的虚拟空间映射到物理存储空间</p><p>32位CPU使用<strong>分段部件</strong>和<strong>分页部件</strong>实现这一映射</p><p><strong>分段部件</strong>用于将各段<strong>二维</strong>的逻辑地址转换为<strong>一维</strong>的线性地址， 从而完成从<strong>虚拟空间</strong>到<strong>线性空间</strong>的转换， 实现系统与用户、用户与用户之间的隔离与共享。</p><p>分段部件有 ６ 个 １６ 位的段寄存器， 它们分别是：</p><p>ＣＳ———代码段寄存器；</p><p>ＳＳ———堆栈段寄存器；</p><p>ＤＳ———数据段寄存器；</p><p>ＥＳ、ＦＳ、ＧＳ———附加数据段寄存器。</p><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220903204235387.png" alt="image-20220903204235387" style="zoom:33%;" /></p><p>实方式下，段的大小最大只能为64KB，取数据或指令的物理地址<strong>直接通过段寄存器的内容和EＡ生成</strong></p><p>保护方式下，段大小可达4GB，这时的段寄存器内容称为<strong>选择符</strong>，通过该选择符找到描述符表，取出描述符后才能确定所需访问的段和存储单元</p><ul><li>分段部件构造虚拟存储空间</li><li>分页部件则主要用于物理存储器的管理</li></ul><h3 id="1-2-3-80X86的3种工作方式"><a href="#1-2-3-80X86的3种工作方式" class="headerlink" title="1.2.3  80X86的3种工作方式"></a>1.2.3  80X86的3种工作方式</h3><h4 id="1-实地址方式"><a href="#1-实地址方式" class="headerlink" title="1.实地址方式"></a>1.实地址方式</h4><p>32位寄存器、32位操作数、32位寻址方式</p><p>32位CPU和16位CPU只能寻址1MB物理存储空间，程序段段大小不超过64KB</p><p>段基址和偏移地址都是32位（16位段）</p><h4 id="2-保护方式"><a href="#2-保护方式" class="headerlink" title="2.保护方式"></a>2.保护方式</h4><p>32位地址先，寻址4GB的物理存储空间，虚拟存储空看可达64TB</p><p>段基址和段内偏移量都是32位，程序段的大小可达4GB，这样的段也称为“32位”。</p><h4 id="3-保护方式下的虚拟8086方式（V86方式）"><a href="#3-保护方式下的虚拟8086方式（V86方式）" class="headerlink" title="3.保护方式下的虚拟8086方式（V86方式）"></a>3.保护方式下的虚拟8086方式（V86方式）</h4><p>保护方式下运行的类似实方式的工作环境</p><p>对于80X86中的32位ＣＰＵ，在实方式下执行的是16位段的程序(寄存器和数据可以是 32/16位);在保护方式下可以对 32位段和 16位段的程序单独或混合操作；</p><p>虚 拟 8086方式可并行执行多个 8086的16位段程序，但由于它与实方式的特权级不同，因此，它还不能代替实方式。 </p><h2 id="1-3-主存储器和物地址的形成"><a href="#1-3-主存储器和物地址的形成" class="headerlink" title="1.3 主存储器和物地址的形成"></a>1.3 主存储器和物地址的形成</h2><h3 id="1-3-1主存储器"><a href="#1-3-1主存储器" class="headerlink" title="1.3.1主存储器"></a>1.3.1主存储器</h3><p><strong>存储器</strong>是用来存放程序和数据的装置</p><p><strong>主存</strong>设在主机内部，用来存放当前运行的程序和所需的数据，一边随时像CPU高速提供信息</p><p>主存由许多存储位构成，这些储存位<strong>每8位</strong>组合成<strong>一个字节</strong>，</p><p>每相邻的<strong>2个字节</strong>又可以组成一个<strong>字</strong>，</p><p>相邻的<strong>2个字</strong>有可以组成一个<strong>双字</strong>。</p><h4 id="区分不同字节存储单元："><a href="#区分不同字节存储单元：" class="headerlink" title="区分不同字节存储单元："></a><strong>区分不同字节存储单元</strong>：</h4><h5 id="物理地址-PA"><a href="#物理地址-PA" class="headerlink" title="物理地址(PA):"></a>物理地址(PA):</h5><p>​    每一单元被指定一个编号，用以区分不同字节存储单元。</p><p>​    80X86机的主存是按8位字节编址的，即以字节为最小寻址单位。</p><p>字由相邻两个字节组成，规定字地址由2个字节中较小的确定</p><p>双字地址由4个字节的最低地址确定</p><p>存放在主存中的程序和数据一般均按<strong>物理地址</strong>存取</p><p><strong>字数据</strong>低8位存放在低地址字节中，高8位存放在相邻的高地址字节中；<strong>双字数据</strong>存放是低16位存放在低地址字中，高16位存放在相邻的高地址字中。</p><h3 id="1-3-2-堆栈"><a href="#1-3-2-堆栈" class="headerlink" title="1.3.2 堆栈"></a>1.3.2 堆栈</h3><p><strong>先进后出</strong>原则，进栈为“压入”，出栈为“弹出”。</p><p>堆栈由一片<strong>存储单元</strong>和一个<strong>指示器</strong>组成，固定端叫做<strong>栈底</strong></p><ul><li><strong>栈指针</strong>：用来指示栈元素进栈和出栈时偏移地址的变化</li><li><strong>栈顶</strong>：指针所指示的最后存入数据的单元</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220903204213353.png" alt="image-20220903204213353" style="zoom:33%;" /></p><h4 id="1-进栈指令PUSH"><a href="#1-进栈指令PUSH" class="headerlink" title="1.进栈指令PUSH"></a>1.进栈指令PUSH</h4><p>语句格式：PUSH OPS</p><p>功能：将立即数或寄存器、段寄存、存储器中的一个字/双字数据压入堆栈中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">PUSH 04F8H<br>执行前:(SP)=1000H<br>执行：(SP)-2 -&gt;SP<br>04F8H-&gt;[SP]<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220903205005287.png" alt="image-20220903205005287" style="zoom:33%;" /></p><h4 id="2-出栈指令POP"><a href="#2-出栈指令POP" class="headerlink" title="2.出栈指令POP"></a>2.出栈指令POP</h4><p>语句格式：POP OPD</p><p>功能：将栈顶元素弹出送至某一寄存器、段寄存器或存储器中。</p><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220903205642816.png" alt="image-20220903205642816" style="zoom: 33%;" /></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">POP</span> <span class="hljs-built_in">BX</span><br>执行前:<span class="hljs-keyword">POP</span> <span class="hljs-built_in">BX</span><br>执行:([<span class="hljs-built_in">SP</span>])-&gt;<span class="hljs-built_in">BX</span><br>(<span class="hljs-built_in">SP</span>)+<span class="hljs-number">1</span>-&gt;<span class="hljs-built_in">SP</span><br>执行后:(<span class="hljs-built_in">BX</span>)=<span class="hljs-number">04F8H</span><span class="hljs-comment">;(SP)=1000H</span><br></code></pre></td></tr></table></figure><p>除了PUSH和POP指令外，如果其他指令要访问堆栈，也可以通过基址寄存器BP进行</p><p><strong>注意</strong>:</p><ol><li>当堆栈段为16位段时，系统自动使用SP作栈指针；32位，使用ESP</li><li>进栈或出栈操作时，<strong>栈指针(SP/ESP)</strong>移动的字节数取决于操作数的类型。字操作，(SP/ESP)均是±2，双字操作，(SP/ESP)均为±4</li></ol><h4 id="3-将8个寄存器内容顺序入栈指令"><a href="#3-将8个寄存器内容顺序入栈指令" class="headerlink" title="3.将8个寄存器内容顺序入栈指令"></a><del>3.将8个寄存器内容顺序入栈指令</del></h4><p><del>该指令分为<strong>8个16位寄存器</strong>入栈和对<strong>8个32位寄存器</strong>入栈</del></p><h5 id="1-将8个16位寄存器入栈"><a href="#1-将8个16位寄存器入栈" class="headerlink" title="(1)将8个16位寄存器入栈"></a><del>(1)将8个16位寄存器入栈</del></h5><p><del>语句格式：PUSHA</del></p><p><del>功能：将8个16位寄存器按AX、CX、DX、BX、SP、BP、SI、DI顺序入栈保存</del></p><h3 id="1-3-3-物理地址的形成"><a href="#1-3-3-物理地址的形成" class="headerlink" title="1.3.3 物理地址的形成"></a>1.3.3 物理地址的形成</h3><p>80X86机，最低档CPU为8086，20根地址线，寻址能力为$2^{20}B$，主内存容量为1MB，物理地址编号从0~0FFFFFH。</p><p>此时CPU与存储器交换信息必须要<strong>20位的物理地址</strong>，但是8086内部为<strong>16位结构</strong>，寄存器也是16位的。</p><p>16位寄存器进行地址运算，表示16位地址，<strong>操作数范围最大为64KB</strong>。</p><h4 id="主存分段使用方案："><a href="#主存分段使用方案：" class="headerlink" title="主存分段使用方案："></a>主存分段使用方案：</h4><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220904155556771.png" alt="image-20220904155556771" style="zoom:33%;" /></p><p>将1MB的存储器<strong>按64KB分段</strong>，设置4个段寄存器CS、DS、SS、ES，保存当前可使用段的段首址。</p><p>段首址从刚好被<strong>16整除</strong>的地址开始，<strong>低四位均为0</strong>，忽略这些0，刚好16位可以存入段寄存器之中，然后操作时，内容左移4位，补上4个0，再加上某待访问存储单元的偏移地址，获得20位物理地址。</p><p>存储单元的地址由两部分组成：<strong>段首地址：偏移地址</strong>，被称为<strong>二维的逻辑地址</strong></p><h4 id="1-实方式物理地址的形成"><a href="#1-实方式物理地址的形成" class="headerlink" title="1. 实方式物理地址的形成"></a>1. 实方式物理地址的形成</h4><p>实方式情况下，32位CPU只能寻址1MB的物理存储空间，采用分段使用的方式，每段大小不超过64KB，段首地址和段内偏移地址都用16位表示。</p><p>在每一给定时刻，CPU可以在不修改段寄存器内容的情况下访问6个段：</p><ul><li>代码段</li><li>堆栈段</li><li>数据段</li><li>3个附加数据段</li></ul><p>这些当前能被CPU访问段的首地址由分段部件中的6个专用段寄存器给出</p><ul><li>CS：给出当前代码段首地址（取指令指针为IP）</li><li>SS：给出当前堆栈段首地址（取栈指针为SP）</li><li>DS：给出当前数据段首地址</li><li>ES、FS、GS：给出当前附加数据段首地址</li></ul><ul><li><strong>代码段</strong>是程序代码的存储区，指令指示器IP总是保存着下一条将要取出指令相对于<strong>CS</strong>的偏移地址在<strong>代码段中取指令</strong>时，指令物理地址：</li></ul><p>​                                        $PA = (CS)_{左移4位}+(IP)$</p><ul><li><p><strong>堆栈段</strong>时程序的<strong>临时数据存储区</strong>，存放暂时无用的数据。用户自定义堆栈段，作子程序调用、系统功能调用、中断处理等操作。系统以<strong>SP</strong>为指针，做堆栈操作时，栈顶物理地址：</p><p>​                                $PA = (SS)_{左移4位}+(SP)$</p></li><li><p><strong>数据段和附加数据段</strong>是程序<strong>使用时</strong>的数据存储区。附加数据段和数据段重合，设置成一个段，数据的物理地址：</p><p>​                                $PA = (DS或ES、FS、GS)_{左移4位}+16位偏移地址$</p></li></ul><h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5><ul><li><p>程序大小可以自定，但是必须要小于或等于64KB，每个段在主存的具体位置由操作系统分配</p></li><li><p>分段不唯一，某一片具体存储单元，可以属于一个段，也可以属于多个段</p></li><li>汇编源程序之中，用户必须将数据段首址置入DS、ES、FS、GS，而CS、SS由系统自动录入</li></ul><h4 id="2-保护方式下物理地址的形成"><a href="#2-保护方式下物理地址的形成" class="headerlink" title="2.保护方式下物理地址的形成"></a>2.保护方式下物理地址的形成</h4><p>保护方式，使用32根地址线，可以寻址4GB物理存储空间，程序大小也可达到4GB，段基址和段内偏移地址都为32位。</p><p><strong>多任务机制</strong>：对虚拟存储空间的任务进入主存进行合理调度和分配，实施执行环境的<strong>隔离和保护</strong>。</p><h5 id="1-特权级"><a href="#1-特权级" class="headerlink" title="(1) 特权级"></a>(1) 特权级</h5><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20220904210520629.png" alt="image-20220904210520629"></p><h5 id="2-描述符"><a href="#2-描述符" class="headerlink" title="(2) 描述符"></a>(2) 描述符</h5><p>除了段基址以外，其余信息被整合到一起，用4个字来描述，被称为<strong>描述符</strong></p><p>按不同的描述对象，可分为：</p><ul><li>存储段描述符</li><li>系统段描述符</li><li>控制描述符</li></ul><h6 id="描述符通用结构"><a href="#描述符通用结构" class="headerlink" title="描述符通用结构"></a>描述符通用结构</h6><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20220904211612369.png" alt="image-20220904211612369"></p><ul><li><p>32位段基址（不分页，该基地址为段在主存的起始物理地址）</p></li><li><p>20位段界限（段长度）</p></li><li><p>第三个字的高字节描述了段的性质及当前使用情况</p><ul><li><p><strong>P</strong>：存在为，P=1，描述符对应段存在，P=0，不存在</p></li><li><p><strong>DPL</strong>：描述符对应段的特权级</p></li><li><p><strong>S</strong>：段类型，S=1，存储段描述符（程序代码段、数据段），S=0，存储系统描述符</p></li><li><p><strong>TYPE</strong>：段的具体属性，共有三位。对存储段来说， 第 11位<strong>E</strong>描述了该段<strong>是否为可执行段</strong>。 Ｅ ＝０ 说明该段为不可执行段， 即为数据段或堆栈段；Ｅ ＝１ 说明该段为可执行段， 即为代码段。</p><p> 在两种不同类型的段中， 另两位（第 １０ ～９ 位）所描述的内容是不同的</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20220904212532573.png" alt="image-20220904212532573"></p></li><li><p><strong>A</strong>：已访问位</p></li></ul></li><li><p>第四个字7~4描述信息</p><ul><li><strong>G</strong>：粒度位  Ｇ ＝０ 时说明段长度的计量单位为字节(B)；Ｇ ＝１ 时说明段长度的计量单位为页， １ 页为 ４KB。</li><li><strong>D</strong>：D=0，16位操作数和16位有效地址，堆栈使用SP作指针，界限值0FFFFH；D=1，32位操作数和32位有效地址， 堆栈使用ESP指针，界限值0FFFFFFFFH。剩余两位为保留位和系统专用位。</li></ul></li></ul><h5 id="3-描述符表"><a href="#3-描述符表" class="headerlink" title="(3)描述符表"></a>(3)描述符表</h5><ul><li>局部描述符表</li><li>全局描述符表</li><li>中断描述符表</li></ul><h5 id="4-段选择符和描述符寄存器"><a href="#4-段选择符和描述符寄存器" class="headerlink" title="(4)段选择符和描述符寄存器"></a>(4)段选择符和描述符寄存器</h5><p>保护方式下，段寄存器不保存段的开始地址，从描述符表中选择相应段的描述符的方式。</p><h6 id="段选择符"><a href="#段选择符" class="headerlink" title="段选择符"></a>段选择符</h6><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20220904213647690.png" alt="image-20220904213647690" style="zoom:33%;" /></p><h5 id="5-保护方式下物理地址的形成"><a href="#5-保护方式下物理地址的形成" class="headerlink" title="(5)保护方式下物理地址的形成"></a>(5)保护方式下物理地址的形成</h5><ol><li>根据段寄存器中的描述符索引值、TI及RPL值，从描述符表中选出描述符，然后判断是否有溢出，进行特权级、使用合法性及各种相关属性检查，合格之后送入对应描述符高速缓冲寄存器。</li><li>需要对该段存储空间访问时，从描述符高速缓冲寄存器中取出段基址，与存放于EIP/ESP或某一指示器中的偏移地址相加，形成32位线性地址。</li><li>不分页，则得到物理地址；分页的话，经过分页部件映射，将线性地址转换为物理地址。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20220904214102185.png" alt="image-20220904214102185"></p><h2 id="1-4数据在计算机内的表示形式"><a href="#1-4数据在计算机内的表示形式" class="headerlink" title="1.4数据在计算机内的表示形式"></a>1.4数据在计算机内的表示形式</h2><ul><li>二进制<ul><li>字节</li><li>字</li><li>双字</li><li>三字</li><li>四字</li><li>十字</li></ul></li><li>八进制</li><li>十六进制</li><li>BCD码</li></ul><h3 id="1-4-1-数值数据在计算机内的表示形式"><a href="#1-4-1-数值数据在计算机内的表示形式" class="headerlink" title="1.4.1 数值数据在计算机内的表示形式"></a>1.4.1 数值数据在计算机内的表示形式</h3><ul><li>定点表示法</li><li>浮点表示法</li></ul><p>有符号数一律采用二进制补码</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20220905162139363.png" alt="image-20220905162139363"></p><p>计算机在进行<strong>算术逻辑运算时</strong>， 总是把参与运算的、用补码表示的操作数作为无符号数处理， 这时， 数的表示范围则与前面讨论的完全不同。</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20220905162310714.png" alt="image-20220905162310714"></p><h3 id="1-4-2-BCD码"><a href="#1-4-2-BCD码" class="headerlink" title="1.4.2 BCD码"></a>1.4.2 BCD码</h3><p>利用4位二进制表示十进制数</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20220905162515343.png" alt="image-20220905162515343" style="zoom: 50%;" /></p><p>BCD码：</p><ul><li><p>未压缩的BCD码</p><ul><li>每个字节只放一个十进制位数</li></ul></li><li><p>压缩的BCD码</p><ul><li>一个字节存放两个十进制位数</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20220905162706328.png" alt="image-20220905162706328" style="zoom:50%;" /></p></li></ul><h3 id="1-4-3-字符数据在机内的表示形式"><a href="#1-4-3-字符数据在机内的表示形式" class="headerlink" title="1.4.3 字符数据在机内的表示形式"></a>1.4.3 字符数据在机内的表示形式</h3><p>$ASCII$码标准</p><h2 id="1-5-标志寄存器"><a href="#1-5-标志寄存器" class="headerlink" title="1.5 标志寄存器"></a>1.5 标志寄存器</h2><p><strong>标志寄存器</strong>：保存在一条指令执行之后， ＣＰＵ 所处状态的信息及运算结果的特征。</p><p>16位CPU中的标志寄存器是16位的，称为FLAGS，32位CPU中的标志寄存器是32位的，称EFLAGS</p><p>32位向下兼容</p><h3 id="1-5-1-标志位"><a href="#1-5-1-标志位" class="headerlink" title="1.5.1 标志位"></a>1.5.1 标志位</h3><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20220905170358493.png" alt="image-20220905170358493"></p><p>常用标志位：</p><ul><li>条件标志位</li><li>控制标志位</li><li>32位寄存器扩充的系统标志位</li></ul><h4 id="1-条件标志位"><a href="#1-条件标志位" class="headerlink" title="1.条件标志位"></a>1.条件标志位</h4><p>由CPU根据执行完一条指令后所得运算结果的特征自动设置的，主要用作控制条件转移指令是否转移的条件。</p><ul><li>符号标志SF（第7位）</li><li>零标志符ZF（第6位）</li><li>溢出标志OF（第11位）</li><li>进位标志CF（第0位）</li><li>辅助进位标志AF（第4位）</li><li>奇偶标志位PF（第2位）</li></ul><h4 id="2-控制标志位"><a href="#2-控制标志位" class="headerlink" title="2.控制标志位"></a>2.控制标志位</h4><ul><li>方向标志DF</li><li>中断允许标志IF</li><li>跟踪标志TF</li></ul><h4 id="3-32-位标志寄存器扩充的系统标志位"><a href="#3-32-位标志寄存器扩充的系统标志位" class="headerlink" title="3.32 位标志寄存器扩充的系统标志位"></a>3.32 位标志寄存器扩充的系统标志位</h4><ul><li>IO 特权标志 IOPL<ul><li>占两位，指定了要求执行I/O指令的特权级</li></ul></li><li>嵌套任务标志 NT<ul><li>控制中断返回指令的执行</li></ul></li><li>恢复标志RF<ul><li>与寄存器一起使用，确定是否接受调试故障</li></ul></li><li>虚拟8086方式标志VM<ul><li>VM置1，CPU在虚拟8086方式下工作，置0，保护方式下工作</li></ul></li></ul><h3 id="1-5-2标志寄存器操作指令"><a href="#1-5-2标志寄存器操作指令" class="headerlink" title="1.5.2标志寄存器操作指令"></a>1.5.2标志寄存器操作指令</h3><h4 id="1-标志寄存器传送指令"><a href="#1-标志寄存器传送指令" class="headerlink" title="1.标志寄存器传送指令"></a>1.标志寄存器传送指令</h4><h5 id="1-LAHF"><a href="#1-LAHF" class="headerlink" title="(1)LAHF"></a>(1)LAHF</h5><p>功能：将标志寄存器低8位存入AH中，即$(EFALGS){7~0} \rightarrow AH$</p><h5 id="2-SAHF"><a href="#2-SAHF" class="headerlink" title="(2)SAHF"></a>(2)SAHF</h5><p>功能：将AH中的内容送入标志寄存器的低8位之中，高位保持不变。</p><h4 id="2-32位标志寄存器进栈指令PUSHFD"><a href="#2-32位标志寄存器进栈指令PUSHFD" class="headerlink" title="2.32位标志寄存器进栈指令PUSHFD"></a>2.32位标志寄存器进栈指令PUSHFD</h4><p>功能：将标志寄存器的内容压入堆栈之中</p><p>​        $(EFLAGS)\rightarrow \downarrow(ESP/SP) $</p><h4 id="3-32位标志寄存器出栈指令POPFD"><a href="#3-32位标志寄存器出栈指令POPFD" class="headerlink" title="3.32位标志寄存器出栈指令POPFD"></a>3.32位标志寄存器出栈指令POPFD</h4><p>功能：$\uparrow(ESP/SP)\rightarrow EFLAGS$</p><p>说明：该指令不影响标志位RF、VM、IOPL、VIF、VIP和未定义位。</p>]]></content>
    
    
    <categories>
      
      <category>汇编语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>go项目部署到linxu</title>
    <link href="/2022/08/08/go%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0linxu/"/>
    <url>/2022/08/08/go%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0linxu/</url>
    
    <content type="html"><![CDATA[<h1 id="go项目部署到linxu"><a href="#go项目部署到linxu" class="headerlink" title="go项目部署到linxu"></a>go项目部署到linxu</h1><p>2020-09-27阅读 4390</p><p>环境: 在<code>mac</code>上编译, 编译后上传到<code>linux</code>, 然后运行代码</p><p><strong><code>go</code>项目打包</strong></p><p>一、直接部署到<code>linux</code></p><ol><li><p>在mac上, 进入到项目目录, 执行以下命令</p><p><code>CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go</code></p></li></ol><p>, 进行编译: , 生成一个main文件. </p><ol><li>将main文件上传到linux任意目录下, 执行<code>nohup ./main &amp;运行项目</code>. 如果出错, 则查看日志即可</li></ol><p>二. 通过nginx部署</p><p><code>**beego</code>项目打包**</p><p> 环境: 本地开发是<code>mac</code>, 部署到<code>linux</code></p><ol><li><p>在mac上, 进入到项目目录, 执行: <code>bee pack -be GOOS=linux</code>进行打包, 打包成功后, 会生成一个<code>****.tar.gz</code>的文件.</p></li><li><p>在<code>linux</code>的某一个目录下创建一个新的文件夹(一定要创建, 否则会解压到根目录), 将<code>***tar.gz</code>文件上传到<code>linux</code>. </p></li><li><p>解压<code>tar -xvzf xxxx.tar.gz</code></p></li><li><p>分配权限: <code>sudo chmod 777 xxxx</code></p></li><li><p>运行可执行文件<code>. nohup ./**** &amp;</code>成功</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>M1 配置numpy和scipy</title>
    <link href="/2022/08/06/M1-%E9%85%8D%E7%BD%AEnumpy%E5%92%8Cscipy/"/>
    <url>/2022/08/06/M1-%E9%85%8D%E7%BD%AEnumpy%E5%92%8Cscipy/</url>
    
    <content type="html"><![CDATA[<h1 id="1-安装anaconda"><a href="#1-安装anaconda" class="headerlink" title="1. 安装anaconda"></a>1. 安装<a href="https://www.anaconda.com/products/distribution">anaconda</a></h1><p>命令行安装</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/v2-5dd0d5f450efafa2c036bd094bfc127c_1440w.jpg" alt="img"></p><p>下载完成后，打开terminal，输入bash空格后，直接将下载的文件拖到terminal里面，会直接转换成当前文件所在的路径，然后回车：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">bash /Users/yourname/Downloads/Anaconda3-2022.05-MacOSX-arm64.sh <br></code></pre></td></tr></table></figure><p>然后一直回车，后面的选项建议都是yes，就不要自己改动了。</p><h1 id="2-创建新环境"><a href="#2-创建新环境" class="headerlink" title="2.创建新环境"></a>2.创建新环境</h1><p>安装好arm64版本的anaconda后，先创建一个新环境，在terminal中输入</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">conda create -n EnvName python=3.8<br></code></pre></td></tr></table></figure><h2 id="报错："><a href="#报错：" class="headerlink" title="报错："></a>报错：</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">zsh：<span class="hljs-keyword">command</span> not <span class="hljs-keyword">find</span>:conda<br></code></pre></td></tr></table></figure><h2 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h2><h3 id="1-检查是否安装conda"><a href="#1-检查是否安装conda" class="headerlink" title="1.检查是否安装conda"></a>1.检查是否安装<code>conda</code></h3><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220806153339601.png" alt="image-20220806153339601"></p><p>在<code>bin</code>目录下查看是否有conda</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> bin<br><span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220806153501459.png" alt="image-20220806153501459"></p><h3 id="2-文件夹有conda，但是显示zsh-command-not-find-conda"><a href="#2-文件夹有conda，但是显示zsh-command-not-find-conda" class="headerlink" title="2.文件夹有conda，但是显示zsh:command not find:conda"></a>2.文件夹有<code>conda</code>，但是显示<code>zsh:command not find:conda</code></h3><p>需要修改.zshrc这个文件中的路径。</p><blockquote><p>.zshrc是什么 ：The individual per-interactive-shell startup file<br> 简单来说它是linux文件夹的一个配置文件，这个文件主要保存个人的一些个性化设置，比如命名别名、路径等。</p></blockquote><h3 id="3-打开终端，修改路径"><a href="#3-打开终端，修改路径" class="headerlink" title="3.打开终端，修改路径"></a>3.打开终端，修改路径</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-symbol">wuyuxian@</span>wuyuxiandeMacBook-Pro ~ % vim ~/.zshrc<br></code></pre></td></tr></table></figure><p>最后一行加入</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">export PATH=<span class="hljs-regexp">/home/u</span>sername<span class="hljs-regexp">/anaconda/</span>bin:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220810114603506.png" alt="image-20220810114603506"></p><h3 id="4-使文件生效"><a href="#4-使文件生效" class="headerlink" title="4.使文件生效"></a>4.使文件生效</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></td></tr></table></figure><h3 id="5-检验生效"><a href="#5-检验生效" class="headerlink" title="5.检验生效"></a>5.检验生效</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">conda <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220806153923541.png" alt="image-20220806153923541"></p><h2 id="继续："><a href="#继续：" class="headerlink" title="继续："></a>继续：</h2><p>终端输入:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">conda</span> create -n EnvName python=<span class="hljs-number">3</span>.<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>中间的EnvName为环境名称，可以自己设置</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220806154153604.png" alt="image-20220806154153604"></p><p>然后激活这个环境：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">conda activate EnvName<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220806154212919.png" alt="image-20220806154212919"></p><h1 id="3-安装numpy"><a href="#3-安装numpy" class="headerlink" title="3.安装numpy"></a>3.安装<code>numpy</code></h1><p>第一步：由于我们需要自己编译numpy，所以先下载cython和pybind11</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">pip install cython pybind11<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220806154350218.png" alt="image-20220806154350218"></p><p>第二步：安装numpy</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">pip install --no-binary :all: --no-use-pep517 numpy<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220806154859018.png" alt="image-20220806154859018"></p><p>安装完成之后可以打开Python，import numpy as np后输入</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">np.show_config()<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220806155255881.png" alt="image-20220806155255881"></p><p>成功：</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220806155334825.png" alt="image-20220806155334825"></p><h1 id="4-安装scipy"><a href="#4-安装scipy" class="headerlink" title="4.安装scipy"></a>4.安装<code>scipy</code></h1><p>前提：安装<code>homebrew</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> pythran<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220806155807546.png" alt="image-20220806155807546"></p><p>然后再安装这两个package</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">brew install openblas gfortran<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220806161015913.png" alt="image-20220806161015913"></p><p>因为scipy是依赖fortran和BLAS/LACK的，因此我们要先安装上面两个</p><p>并且设置OPENBLAS的路径：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">export OPENBLAS=<span class="hljs-regexp">/opt/</span>homebrew<span class="hljs-regexp">/opt/</span>openblas<span class="hljs-regexp">/lib/</span><br></code></pre></td></tr></table></figure><p>这时就可以安装numpy了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 install --no-binary :all: --no-use-pep517 numpy<br></code></pre></td></tr></table></figure><p>然后就可以安装scipy了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 install --no-binary :all: --no-use-pep517 scipy<br></code></pre></td></tr></table></figure><p>以上寄掉，可以试试conda</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220806170404370.png" alt="image-20220806170404370"></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>numpy spicy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学规划</title>
    <link href="/2022/08/05/%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92/"/>
    <url>/2022/08/05/%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="数学规划模型"><a href="#数学规划模型" class="headerlink" title="数学规划模型"></a>数学规划模型</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="（1）什么是数学规划"><a href="#（1）什么是数学规划" class="headerlink" title="（1）什么是数学规划"></a>（1）什么是数学规划</h3><p>数学规划是运筹学 的 ⼀个 分⽀ , 其⽤来研究: 在 给定的条件 下 (约束条件),如何按照某 ⼀衡量指标 (⽬标函数) 来寻求计划、管理⼯作中的最优⽅案 。 </p><p>===&gt;求 ⽬标函数 在 ⼀定约束条件 下 的极值问题 。</p><p>​                    例⼦ : 数学⾼考试卷 中的 线性规划 ⼤题 </p><h3 id="2-数学规划的一般形式"><a href="#2-数学规划的一般形式" class="headerlink" title="(2) 数学规划的一般形式"></a>(2) 数学规划的一般形式</h3><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220805212036714.png" alt="image-20220805212036714"></p><h3 id="3-数学规划的分类"><a href="#3-数学规划的分类" class="headerlink" title="(3) 数学规划的分类"></a>(3) 数学规划的分类</h3><h4 id="①-线性规划-Liner-programming"><a href="#①-线性规划-Liner-programming" class="headerlink" title="① 线性规划 ( Liner programming)"></a>① 线性规划 ( Liner programming)</h4><p>如果<strong>⽬标函数</strong><script type="math/tex">f(x)</script>和<strong>约束条件</strong>均是决策变量的线性表达式 , 那么 此时的 数学规划问题就属于线性规划 。 </p><p>1947年 ,美国数学家丹⻬格 ( GB.Dantz.in)提出了求解线性规划的<strong>单纯形法</strong> ,奠定了这⻔学科的基础。</p><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220805212912821.png" alt="image-20220805212912821"></h3><h4 id="②-⾮线性规划-nonlinear-pogramming"><a href="#②-⾮线性规划-nonlinear-pogramming" class="headerlink" title="② ⾮线性规划 ( nonlinear pogramming)"></a>② ⾮线性规划 ( nonlinear pogramming)</h4><p>当⽬标函数和或者约束条件中有⼀个是<strong>决策变量ㄨ的⾮线性表达式</strong> , 那么此时的数学规划问题就属于<strong>⾮线性规划</strong> 。解决⾮线性规划要⽐线性规划困难得多,⽬前没有通⽤算法,⼤多数算法都是在选定决策变量的初始值后 ,通过一定的<strong>搜索⽅法</strong>寻求最优的决策变量 。</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220805213119482.png" alt="image-20220805213119482"></p><h4 id="③整数规划-integer-programming）"><a href="#③整数规划-integer-programming）" class="headerlink" title="③整数规划 ( integer programming）"></a>③整数规划 ( integer programming）</h4><p>整数规划是一类要求变量取整数值的数学规划</p><h5 id="线性整数规划（在线性规划模型中，有决策变量限定为整数"><a href="#线性整数规划（在线性规划模型中，有决策变量限定为整数" class="headerlink" title="线性整数规划（在线性规划模型中，有决策变量限定为整数)"></a>线性整数规划（在线性规划模型中，有决策变量限定为整数)</h5><h5 id="非线性整数规划"><a href="#非线性整数规划" class="headerlink" title="非线性整数规划"></a>非线性整数规划</h5><p>⽬前, 所流⾏的求解整数规划的算法往往只适⽤于线性整数规划</p><h4 id="④-0-1-规划-otngrammng"><a href="#④-0-1-规划-otngrammng" class="headerlink" title="④ 0- 1 规划 ( otngrammng) :"></a>④ 0- 1 规划 ( otngrammng) :</h4><p>整数规划的特例 ,整数变量的取值只能为 0 和 1 </p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Modeling</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第4章 Pod--Kubernetes的基本单位</title>
    <link href="/2022/07/30/%E7%AC%AC4%E7%AB%A0%20Pod--Kubernetes%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D/"/>
    <url>/2022/07/30/%E7%AC%AC4%E7%AB%A0%20Pod--Kubernetes%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Pod是Kubernetes中的==基本单位==。容器本身并不会直接分配到主机上，而会封装到名为Pod的对象中。</p><p>Pod通常表示<strong>单个应用程序</strong>，由一个或多个关系紧密的容器构成，这些容器拥有同样的生命周期，作为一个整体一起编排到Node上。</p><p>这些容器<strong>共享环境、存储卷（volume）和IP空间</strong>。尽管Pod基于一个或多个容器，但应将Pod视作一个单一的整体、单独的应用程序。Kubernetes以Pod为最小单位进行调度、伸缩并共享资源、管理生命周期。</p></blockquote><h1 id="1-Pod基本操作"><a href="#1-Pod基本操作" class="headerlink" title="1. Pod基本操作"></a>1. Pod基本操作</h1><h2 id="1-创建Pod"><a href="#1-创建Pod" class="headerlink" title="1. 创建Pod"></a>1. 创建Pod</h2><h3 id="部署Pod"><a href="#部署Pod" class="headerlink" title="部署Pod"></a>部署Pod</h3><p>定义模版文件：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">vim</span> examplepod.yml<br></code></pre></td></tr></table></figure><p>填入：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">apiVersion</span><span class="hljs-punctuation">:</span> <span class="hljs-string">v1</span><br><span class="hljs-attribute">kind</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attribute">metadata</span><span class="hljs-punctuation">:</span><br> <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">examplepod</span><br><span class="hljs-attribute">spec</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">containers</span><span class="hljs-punctuation">:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">name: examplepod-container</span><br><span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">busybox</span><br><span class="hljs-attribute">imagePullPolicy</span><span class="hljs-punctuation">:</span> <span class="hljs-string">IfNotPresent</span><br><span class="hljs-attribute">command</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[&#x27;sh&#x27;, &#x27;-c&#x27;]</span><br><span class="hljs-attribute">args</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[&#x27;echo &quot;Hello Kubernetes!&quot;; sleep 3600&#x27;]</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>apiVersion</strong>表示使用的<strong>API版本</strong>。v1表示使用Kubernetes API的稳定版本</p></li><li><p><strong>kind</strong>表示要创建的<strong>资源对象</strong>，这里使用关键字Pod。</p></li><li><p><strong>metadata</strong>表示该资源对象的元数据。一个资源对象可拥有多个元数据，其中一项是name，它表示当前资源的名称。</p></li><li><p><strong>spec</strong>表示该资源对象的具体设置。其中containers表示容器的集合，这里只设置了一个容器，该容器的属性如下。</p><ul><li><p>name：要创建的容器名称。</p></li><li><p>image：容器的镜像地址。</p></li><li><p>imagePullPolicy：镜像的下载策略，支持3种</p><p>imagePullPolicy，如下所示。</p><ul><li>Always：不管镜像是否存在都会进行一次拉取。</li><li>Never：不管镜像是否存在都不会进行拉取。</li><li>IfNotPresent：只有镜像不存在时，才会进行拉取。</li></ul></li><li><p>command：容器的启动命令列表（不配置的话，使用镜像内部的命令）。</p></li><li><p>args：启动参数列表（在本例中是输出文字“HelloKubernetes!”并休眠3600s）</p></li></ul></li></ul><p>运行以下命令，通过模板创建Pod。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">kubectl <span class="hljs-built_in">apply</span> -f examplepod.yml<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220804215147389.png" alt="image-20220804215147389"></p><hr><p><strong>*提示</strong>：apply是一种声明式对象配置命令。这里应用了之前创建的模板，-f参数表示使用文件名作为参数。相比命令式对象管理，apply既便于跟踪，又具备很好的可读性。本书将统一使用声明式对象配置来管理资源。*</p><hr><p>创建成功后，可通过以下命令查询当前运行的所有Pod。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">kubectl <span class="hljs-built_in">get</span> pod<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220804215230213.png" alt="image-20220804215230213"></p><h2 id="2-查询Pod"><a href="#2-查询Pod" class="headerlink" title="2. 查询Pod"></a>2. 查询Pod</h2><p>​    Pod创建后，最常用的功能就是查询。可以用以下命令<strong>查询Pod的状态</strong>。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">kubectl <span class="hljs-built_in">get</span> <span class="hljs-keyword">pod</span> &#123;Pod名称&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220804215302364.png" alt="image-20220804215302364"></p><p>还可以在查询命令中带上参数-w，以对Pod状态进行<strong>持续监控</strong>。</p><p>​        只要Pod发生了变化，就会在控制台中输出相应信息。命令如下。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">kubectl <span class="hljs-built_in">get</span> <span class="hljs-keyword">pod</span> &#123;Pod名称&#125; <span class="hljs-operator">-</span>w<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220804215324072.png" alt="image-20220804215324072"></p><p>​    另外，还可以在查询命令中带上-o wide参数，<strong>输出Pod的更多概要信息</strong>（如调度到哪台机器上，Pod本身的虚拟IP等信息）。命令如下。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">kubectl <span class="hljs-built_in">get</span> <span class="hljs-keyword">pod</span> &#123;Pod名称&#125; <span class="hljs-operator">-</span>o wide<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220804215453630.png" alt="image-20220804215453630"></p><p>​    get命令除了可以显示简要的运行信息外，还可以输出<strong>完整信息</strong>。它支持<strong>多种格式</strong>的输出，如可以用yaml和Json方式输出，命令如下。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">kubectl <span class="hljs-keyword">get</span> pod examplepod <span class="hljs-comment">--output yaml</span><br>kubectl <span class="hljs-keyword">get</span> pod examplepod <span class="hljs-comment">--output json</span><br></code></pre></td></tr></table></figure><p>一般情况下，如果要<strong>查询Pod更详细的信息</strong>（包括状态、生命周期和执行情况等），除了将其输出为yaml或json格式，还可以用<strong>describe命令</strong>查看详情，格式如下。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">kubectl describe pods </span><span class="hljs-template-variable">&#123;Pod名称&#125;</span><br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><code class="hljs dts">[root@iZbp1f3y0av6g5d4zhb3uoZ examplepod]<span class="hljs-meta"># kubectl get pod examplepod --output  yaml</span><br><span class="hljs-symbol">apiVersion:</span> v1<br><span class="hljs-symbol">kind:</span> Pod<br><span class="hljs-symbol">metadata:</span><br><span class="hljs-symbol">  annotations:</span><br>    kubectl.kubernetes.io/last-applied-configuration: |<br>      <span class="hljs-punctuation">&#123;</span><span class="hljs-string">&quot;apiVersion&quot;</span>:<span class="hljs-string">&quot;v1&quot;</span>,<span class="hljs-string">&quot;kind&quot;</span>:<span class="hljs-string">&quot;Pod&quot;</span>,<span class="hljs-string">&quot;metadata&quot;</span>:<span class="hljs-punctuation">&#123;</span><span class="hljs-string">&quot;annotations&quot;</span>:<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>,<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;examplepod&quot;</span>,<span class="hljs-string">&quot;namespace&quot;</span>:<span class="hljs-string">&quot;cert-manager&quot;</span><span class="hljs-punctuation">&#125;</span>,<span class="hljs-string">&quot;spec&quot;</span>:<span class="hljs-punctuation">&#123;</span><span class="hljs-string">&quot;containers&quot;</span>:[<span class="hljs-punctuation">&#123;</span><span class="hljs-string">&quot;args&quot;</span>:[<span class="hljs-string">&quot;echo \&quot;Hello Kubernetes!\&quot;; sleep 3600&quot;</span>],<span class="hljs-string">&quot;command&quot;</span>:[<span class="hljs-string">&quot;sh&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>],<span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;busybox&quot;</span>,<span class="hljs-string">&quot;imagePullPolicy&quot;</span>:<span class="hljs-string">&quot;IfNotPresent&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;examplepod-container&quot;</span><span class="hljs-punctuation">&#125;</span>]<span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">  creationTimestamp:</span> <span class="hljs-string">&quot;2022-08-04T13:32:13Z&quot;</span><br><span class="hljs-symbol">  managedFields:</span><br>  - apiVersion: v1<br><span class="hljs-symbol">    fieldsType:</span> FieldsV1<br><span class="hljs-symbol">    fieldsV1:</span><br><span class="hljs-symbol">      f:</span>metadata:<br><span class="hljs-symbol">        f:</span>annotations:<br>          .: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">          f:</span>kubectl.kubernetes.io/last-applied-configuration: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">      f:</span>spec:<br><span class="hljs-symbol">        f:</span>containers:<br><span class="hljs-symbol">          k:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;examplepod-container&quot;</span><span class="hljs-punctuation">&#125;</span>:<br>            .: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>args: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>command: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>image: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>imagePullPolicy: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>name: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>resources: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>terminationMessagePath: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>terminationMessagePolicy: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">        f:</span>dnsPolicy: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">        f:</span>enableServiceLinks: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">        f:</span>restartPolicy: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">        f:</span>schedulerName: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">        f:</span>securityContext: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">        f:</span>terminationGracePeriodSeconds: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">    manager:</span> kubectl-client-side-apply<br><span class="hljs-symbol">    operation:</span> Update<br><span class="hljs-symbol">    time:</span> <span class="hljs-string">&quot;2022-08-04T13:32:13Z&quot;</span><br>  - apiVersion: v1<br><span class="hljs-symbol">    fieldsType:</span> FieldsV1<br><span class="hljs-symbol">    fieldsV1:</span><br><span class="hljs-symbol">      f:</span>status:<br><span class="hljs-symbol">        f:</span>conditions:<br><span class="hljs-symbol">          k:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;ContainersReady&quot;</span><span class="hljs-punctuation">&#125;</span>:<br>            .: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>lastProbeTime: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>lastTransitionTime: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>status: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>type: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">          k:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;Initialized&quot;</span><span class="hljs-punctuation">&#125;</span>:<br>            .: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>lastProbeTime: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>lastTransitionTime: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>status: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>type: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">          k:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;Ready&quot;</span><span class="hljs-punctuation">&#125;</span>:<br>            .: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>lastProbeTime: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>lastTransitionTime: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>status: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>type: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">        f:</span>containerStatuses: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">        f:</span>hostIP: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">        f:</span>phase: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">        f:</span>podIP: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">        f:</span>podIPs:<br>          .: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">          k:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-string">&quot;ip&quot;</span>:<span class="hljs-string">&quot;10.42.2.25&quot;</span><span class="hljs-punctuation">&#125;</span>:<br>            .: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>ip: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">        f:</span>startTime: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">    manager:</span> k3s<br><span class="hljs-symbol">    operation:</span> Update<br><span class="hljs-symbol">    time:</span> <span class="hljs-string">&quot;2022-08-04T13:32:39Z&quot;</span><br><span class="hljs-symbol">  name:</span> examplepod<br><span class="hljs-symbol">  namespace:</span> cert-manager<br><span class="hljs-symbol">  resourceVersion:</span> <span class="hljs-string">&quot;82803826&quot;</span><br><span class="hljs-symbol">  uid:</span> be9afea5<span class="hljs-number">-2764</span><span class="hljs-number">-4</span>a01-ba9e<span class="hljs-number">-33</span>f13082e7d0<br><span class="hljs-symbol">spec:</span><br><span class="hljs-symbol">  containers:</span><br>  - args:<br>    - echo <span class="hljs-string">&quot;Hello Kubernetes!&quot;</span><span class="hljs-punctuation">;</span> sleep <span class="hljs-number">3600</span><br><span class="hljs-symbol">    command:</span><br>    - sh<br>    - -c<br><span class="hljs-symbol">    image:</span> busybox<br><span class="hljs-symbol">    imagePullPolicy:</span> IfNotPresent<br><span class="hljs-symbol">    name:</span> examplepod-container<br><span class="hljs-symbol">    resources:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">    terminationMessagePath:</span> <span class="hljs-keyword">/dev/</span>termination-log<br><span class="hljs-symbol">    terminationMessagePolicy:</span> File<br><span class="hljs-symbol">    volumeMounts:</span><br>    - mountPath: <span class="hljs-keyword">/var/</span>run<span class="hljs-keyword">/secrets/</span>kubernetes.io/serviceaccount<br><span class="hljs-symbol">      name:</span> default-token-kj5lt<br><span class="hljs-symbol">      readOnly:</span> true<br><span class="hljs-symbol">  dnsPolicy:</span> ClusterFirst<br><span class="hljs-symbol">  enableServiceLinks:</span> true<br><span class="hljs-symbol">  nodeName:</span> izbp113w9axywnhpyk1525z<br><span class="hljs-symbol">  preemptionPolicy:</span> PreemptLowerPriority<br><span class="hljs-symbol">  priority:</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">  restartPolicy:</span> Always<br><span class="hljs-symbol">  schedulerName:</span> default-scheduler<br><span class="hljs-symbol">  securityContext:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">  serviceAccount:</span> default<br><span class="hljs-symbol">  serviceAccountName:</span> default<br><span class="hljs-symbol">  terminationGracePeriodSeconds:</span> <span class="hljs-number">30</span><br><span class="hljs-symbol">  tolerations:</span><br>  - effect: NoExecute<br><span class="hljs-symbol">    key:</span> node.kubernetes.io/not-ready<br><span class="hljs-symbol">    operator:</span> Exists<br><span class="hljs-symbol">    tolerationSeconds:</span> <span class="hljs-number">300</span><br>  - effect: NoExecute<br><span class="hljs-symbol">    key:</span> node.kubernetes.io/unreachable<br><span class="hljs-symbol">    operator:</span> Exists<br><span class="hljs-symbol">    tolerationSeconds:</span> <span class="hljs-number">300</span><br><span class="hljs-symbol">  volumes:</span><br>  - name: default-token-kj5lt<br><span class="hljs-symbol">    secret:</span><br><span class="hljs-symbol">      defaultMode:</span> <span class="hljs-number">420</span><br><span class="hljs-symbol">      secretName:</span> default-token-kj5lt<br><span class="hljs-symbol">status:</span><br><span class="hljs-symbol">  conditions:</span><br>  - lastProbeTime: null<br><span class="hljs-symbol">    lastTransitionTime:</span> <span class="hljs-string">&quot;2022-08-04T13:32:13Z&quot;</span><br><span class="hljs-symbol">    status:</span> <span class="hljs-string">&quot;True&quot;</span><br><span class="hljs-symbol">    type:</span> Initialized<br>  - lastProbeTime: null<br><span class="hljs-symbol">    lastTransitionTime:</span> <span class="hljs-string">&quot;2022-08-04T13:32:39Z&quot;</span><br><span class="hljs-symbol">    status:</span> <span class="hljs-string">&quot;True&quot;</span><br><span class="hljs-symbol">    type:</span> Ready<br>  - lastProbeTime: null<br><span class="hljs-symbol">    lastTransitionTime:</span> <span class="hljs-string">&quot;2022-08-04T13:32:39Z&quot;</span><br><span class="hljs-symbol">    status:</span> <span class="hljs-string">&quot;True&quot;</span><br><span class="hljs-symbol">    type:</span> ContainersReady<br>  - lastProbeTime: null<br><span class="hljs-symbol">    lastTransitionTime:</span> <span class="hljs-string">&quot;2022-08-04T13:32:13Z&quot;</span><br><span class="hljs-symbol">    status:</span> <span class="hljs-string">&quot;True&quot;</span><br><span class="hljs-symbol">    type:</span> PodScheduled<br><span class="hljs-symbol">  containerStatuses:</span><br>  - containerID: containerd:<span class="hljs-comment">//7500b2e8b6f2e0932250d129685edaa17ed84e50aa575bfd5e34ff8203ce2b6f</span><br><span class="hljs-symbol">    image:</span> docker.io<span class="hljs-keyword">/library/</span>busybox:latest<br><span class="hljs-symbol">    imageID:</span> docker.io<span class="hljs-keyword">/library/</span>busybox@sha256:ef320ff10026a50cf5f0213d35537ce0041ac1d96e9b7800bafd8bc9eff6c693<br><span class="hljs-symbol">    lastState:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">    name:</span> examplepod-container<br><span class="hljs-symbol">    ready:</span> true<br><span class="hljs-symbol">    restartCount:</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">    started:</span> true<br><span class="hljs-symbol">    state:</span><br><span class="hljs-symbol">      running:</span><br><span class="hljs-symbol">        startedAt:</span> <span class="hljs-string">&quot;2022-08-04T13:32:38Z&quot;</span><br><span class="hljs-symbol">  hostIP:</span> <span class="hljs-number">172.19</span><span class="hljs-number">.230</span><span class="hljs-number">.67</span><br><span class="hljs-symbol">  phase:</span> Running<br><span class="hljs-symbol">  podIP:</span> <span class="hljs-number">10.42</span><span class="hljs-number">.2</span><span class="hljs-number">.25</span><br><span class="hljs-symbol">  podIPs:</span><br>  - ip: <span class="hljs-number">10.42</span><span class="hljs-number">.2</span><span class="hljs-number">.25</span><br><span class="hljs-symbol">  qosClass:</span> BestEffort<br><span class="hljs-symbol">  startTime:</span> <span class="hljs-string">&quot;2022-08-04T13:32:13Z&quot;</span><br></code></pre></td></tr></table></figure><p>该命令会输出<strong>比较全面</strong>的信息，包括资源的<u>基本信息、容器信息、准备情况、存储卷信息及相关的事件列表</u>。在资源部署时如果遇到问题，可以使用此命令查看详情，分析部署错误的原因。</p><p>如果要查询Pod本身输出的日志信息，还可以使用logs命令，格式如下。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">kubectl logs </span><span class="hljs-template-variable">&#123;Pod名称&#125;</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220804220238729.png" alt="image-20220804220238729"></p><h2 id="3-修改Pod"><a href="#3-修改Pod" class="headerlink" title="3. 修改Pod"></a>3. 修改Pod</h2><p>​    可以用replace命令来修改原先设置的Pod属性，命令格式如下:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">kubectl <span class="hljs-built_in">replace</span> -f &#123;pod模板路径&#125;<br></code></pre></td></tr></table></figure><p>修改之前示例中定义的Pod，使它输出“Hello Kubernetesreplaced!”。先打开examplepod.yml文件。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">vim</span> examplepod.yml<br></code></pre></td></tr></table></figure><p>在文件中填入如下内容并保存。</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">apiVersion</span><span class="hljs-punctuation">:</span> <span class="hljs-string">v1</span><br><span class="hljs-attribute">kind</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attribute">metadata</span><span class="hljs-punctuation">:</span><br> <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">examplepod</span><br><span class="hljs-attribute">spec</span><span class="hljs-punctuation">:</span><br> <span class="hljs-attribute">containers</span><span class="hljs-punctuation">:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">name: examplepod-container</span><br>  <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">busybox</span><br>   <span class="hljs-attribute">imagePullPolicy</span><span class="hljs-punctuation">:</span> <span class="hljs-string">IfNotPresent</span><br>   <span class="hljs-attribute">command</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[&#x27;sh&#x27;, &#x27;-c&#x27;]</span><br>   <span class="hljs-attribute">args</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[&#x27;echo &quot;Hello Kubernetes replaced!&quot;; sleep 3600&#x27;]</span><br></code></pre></td></tr></table></figure><hr><p><em>提示：Pod有很多属性无法修改，比如containers的image属性，spec下的activeDeadline Seconds、tolerations属性等。如果一定要修改，则需要加上—force参数，相当于重新创建Pod，命令如下。</em></p><hr><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">kubectl replace -f &#123;pod模板路径&#125; <span class="hljs-comment">--force</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220804221306895.png" alt="image-20220804221306895"></p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220804221403636.png" alt="image-20220804221403636"></p><h2 id="4-删除Pod"><a href="#4-删除Pod" class="headerlink" title="4. 删除Pod"></a>4. 删除Pod</h2><p>Pod的删除非常简单，只要执行以下命令即可</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">kubectl <span class="hljs-keyword">delete</span> pod &#123;Pod名称&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220804221552127.png" alt="image-20220804221552127"></p><p>另外，还可以基于模板文件删除资源，如以下命令所示:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">kubectl <span class="hljs-keyword">delete</span> -f &#123;模板文件名称&#125;<br></code></pre></td></tr></table></figure><h1 id="2-Pod模板详解"><a href="#2-Pod模板详解" class="headerlink" title="2. Pod模板详解"></a>2. Pod模板详解</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span> <span class="hljs-comment">#版本，必填，v1代表稳定版本</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">pod</span> <span class="hljs-comment">#类型，必填，Pod</span><br><span class="hljs-attr">metadata:</span> <span class="hljs-comment">#元数据，表示资源的标识信息</span><br> <span class="hljs-attr">name:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#元数据，必填，Pod的名字</span><br> <span class="hljs-attr">namespace:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#元数据，Pod的命名空间</span><br> <span class="hljs-attr">labels:</span> <span class="hljs-comment">#元数据，标签列表</span><br> <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">value</span> <span class="hljs-comment">#元数据，可定义多个标签的键/值对</span><br> <span class="hljs-attr">annotations:</span> <span class="hljs-comment">#元数据，自定义注解列表</span><br> <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">value</span> <span class="hljs-comment">#元数据，可定义多个注解的键/值对</span><br><span class="hljs-attr">spec:</span> <span class="hljs-comment">#Pod中容器的详细定义，必填</span><br> <span class="hljs-attr">containers:</span> <span class="hljs-comment">#Pod中的容器列表，必填，可以有多个容器</span><br> <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#容器名称，必填</span><br> <span class="hljs-attr">image:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#容器中的镜像地址，必填</span><br> <span class="hljs-attr">imagePullPolicy:</span> [<span class="hljs-string">Always|Never|IfNotPresent</span>]<span class="hljs-comment">#获取镜像的策略，Always表示下载镜像；</span><br> <span class="hljs-comment">#IfNotPresent表示优先使用本地镜像，否则下载镜像；Never表示仅使用本地镜像</span><br> <span class="hljs-attr">command:</span> [<span class="hljs-string">String</span>] <span class="hljs-comment">#容器的启动命令列表（不配置的话，使用镜像内部的命令）</span><br> <span class="hljs-attr">args:</span> [<span class="hljs-string">String</span>] <span class="hljs-comment">#启动命令参数列表</span><br> <span class="hljs-attr">workingDir:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#容器的工作目录</span><br> <span class="hljs-attr">volumeMounts:</span> <span class="hljs-comment">#挂载到容器内部的存储卷设置</span><br> <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#为了引用Pod定义的共享存储卷的名称，要用volumes[]部分定义的卷名</span><br> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#存储卷在容器内挂载的绝对路径，应少于512个字符</span><br> <span class="hljs-attr">readOnly:</span> <span class="hljs-string">boolean</span> <span class="hljs-comment">#是否为只读模式</span><br> <span class="hljs-attr">ports:</span> <span class="hljs-comment">#容器需要暴露的端口号列表</span><br> <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#端口名称</span><br> <span class="hljs-attr">containerPort:</span> <span class="hljs-string">int</span> <span class="hljs-comment">#容器要暴露的端口</span><br> <span class="hljs-attr">hostPort:</span> <span class="hljs-string">int</span> <span class="hljs-comment">#容器所在主机监听的端口（把容器暴露的端口映射到宿主机的端口）</span><br> <span class="hljs-attr">protocol:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#端口协议，支持TCP和UDP，默认为TCP</span><br> <span class="hljs-attr">env:</span> <span class="hljs-comment">#容器运行前要设置的环境变量列表</span><br> <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#环境变量名称</span><br> <span class="hljs-attr">value:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#环境变量值</span><br> <span class="hljs-attr">resources:</span> <span class="hljs-comment">#资源限制和请求的设置</span><br> <span class="hljs-attr">limits:</span> <span class="hljs-comment">#资源限制的设置</span><br> <span class="hljs-attr">cpu:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#CPU的限制，单位为CPU内核数。将用于docker run--cpu-quota 参数，</span><br> <span class="hljs-comment">#也可以使用小数，例如0.1，0.1等价于表达式100m，表示100milicpu</span><br> <span class="hljs-attr">memory:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#内存限制，单位可以为</span><br><span class="hljs-string">MiB/GiB/MB/GB（1MiB=1024×1024B，#1MB=1000×1000B），将用于docker</span> <span class="hljs-string">run</span> <span class="hljs-string">--memory参数</span> <span class="hljs-attr">requests:</span> <span class="hljs-comment">#资源请求的设置</span><br> <span class="hljs-attr">cpu:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#CPU请求，容器启动时的初始可用数量，将用于</span><br><span class="hljs-string">docker</span> <span class="hljs-string">run</span> <span class="hljs-string">--cpu-shares参数</span><br> <span class="hljs-attr">memory:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#内存请求，容器启动时的初始可用数量</span><br> <span class="hljs-attr">livenessProbe:</span> <span class="hljs-comment">#Pod内容器健康检查的设置，当探测几次无响应后将自动重启该容器，</span><br> <span class="hljs-comment">#检查方法有exec、httpGet和tcpSocket，对一个容器只要设置一种方法即可</span><br> <span class="hljs-attr">exec:</span> <span class="hljs-comment">#通过exec方式来检查Pod内各容器的健康状况</span><br> <span class="hljs-attr">command:</span> [<span class="hljs-string">String</span>] <span class="hljs-comment">#exec方式需要指定的命令或脚本</span><br> <span class="hljs-attr">httpGet:</span> <span class="hljs-comment">#通过httpGet方式来检查Pod中各容器的健康状况，需要指定path、port</span><br> <span class="hljs-attr">path:</span> <span class="hljs-string">String</span><br> <span class="hljs-attr">port:</span> <span class="hljs-string">number</span><br> <span class="hljs-attr">host:</span> <span class="hljs-string">String</span><br> <span class="hljs-attr">scheme:</span> <span class="hljs-string">String</span><br> <span class="hljs-attr">httpHeaders:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">String</span><br> <span class="hljs-attr">value:</span> <span class="hljs-string">String</span> <br> <span class="hljs-attr">tcpSocket:</span> <span class="hljs-comment">#通过tcpSocket检查Pod中各容器的健康状况</span><br> <span class="hljs-attr">port:</span> <span class="hljs-string">number</span><br> <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">0</span> <span class="hljs-comment">#容器启动完成后，首次探测的时间（单位为秒）</span><br> <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">0</span> <span class="hljs-comment">#对容器进行健康检查时探测等待响应的超时时间</span><br><span class="hljs-string">（单位为秒，默认为1s）</span><br> <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">0</span> <span class="hljs-comment">#对容器监控检查的定期探测时间设置（单位为秒），默认10s一次</span><br> <span class="hljs-attr">successThreshold:</span> <span class="hljs-number">0</span><br> <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">0</span><br> <span class="hljs-attr">securityContext:</span> <span class="hljs-comment">#安全配置</span><br> <span class="hljs-attr">privileged:</span> <span class="hljs-literal">false</span><br> <span class="hljs-attr">restartPolicy:</span> [<span class="hljs-string">Always|Never|OnFailure</span>]<span class="hljs-comment">#Pod的重启策略，Always表示不管以何种方式终止</span><br> <span class="hljs-comment">#运行，kubelet都将重启；OnFailure表示只有Pod以非0码退出才重启；Never表示不再重启该Pod</span><br> <span class="hljs-attr">nodeSelector:</span> <span class="hljs-string">object</span> <span class="hljs-comment">#节点选择，设置nodeSelector表示将该Pod调度到包含这个标签的</span><br> <span class="hljs-comment">#节点上，以key：value格式来指定</span><br> <span class="hljs-attr">imagePullSecrets:</span> <span class="hljs-comment">#拉取镜像时使用的secret名称，以key：</span><br><span class="hljs-string">secretkey格式指定</span><br> <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">String</span><br> <span class="hljs-attr">hostNetwork:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</span><br> <span class="hljs-attr">volumes:</span> <span class="hljs-comment">#在该Pod上定义共享存储卷列表</span><br> <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#共享存储卷名称</span><br> <span class="hljs-attr">emptyDir:</span> &#123;&#125; <span class="hljs-comment">#类型为emptyDir的存储卷，与Pod有相同生命周期的一个临时目录，为空值</span><br> <span class="hljs-attr">hostPath:</span> <span class="hljs-comment">#类型为hostPath的存储卷，将会挂载Pod所在宿主机的目录</span><br> <span class="hljs-attr">path:</span> <span class="hljs-string">string</span> <span class="hljs-comment">#Pod所在宿主机的目录，该目录将在容器中挂载</span><br> <span class="hljs-attr">secret:</span> <span class="hljs-comment">#类型为secret的存储卷，在容器内部挂载集群中</span><br><span class="hljs-string">预定义的secret对象</span><br> <span class="hljs-attr">secretName:</span> <span class="hljs-string">String</span><br> <span class="hljs-attr">items:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">String</span><br> <span class="hljs-attr">path:</span> <span class="hljs-string">String</span><br> <span class="hljs-attr">configMap:</span> <span class="hljs-comment">#类型为configMap的存储卷，挂载预定义的</span><br><span class="hljs-string">configMap对象到容器内部</span><br> <span class="hljs-attr">name:</span> <span class="hljs-string">String</span><br> <span class="hljs-attr">items:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">String</span><br> <span class="hljs-attr">path:</span> <span class="hljs-string">String</span><br></code></pre></td></tr></table></figure><p>还可以使用<code>$ kubectl explain pod</code>命令详细查看Pod资源所支持的所有字段的详细说明</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220804222023988.png" alt="image-20220804222023988"></p><p>可以看到图中列出了5个字段，分别是apiVersion、kind、metadata、spec、status。如果要进一步查看每个字段的详情，例如，对于spec字段可以使用命令<code>$ kubectl explainpod.spec</code>进行查看，</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220804222153635.png" alt="image-20220804222153635"></p><p>如果要了解一个正在运行的Pod的配置，可以通过以下命令来获取。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">kubectl <span class="hljs-built_in">get</span> <span class="hljs-keyword">pod</span> &#123;pod名称&#125; <span class="hljs-operator">-</span>o yaml<br></code></pre></td></tr></table></figure><h1 id="3-Pod与容器"><a href="#3-Pod与容器" class="headerlink" title="3. Pod与容器"></a>3. Pod与容器</h1><h2 id="1-Pod创建容器的方式"><a href="#1-Pod创建容器的方式" class="headerlink" title="1. Pod创建容器的方式"></a>1. Pod创建容器的方式</h2><p>之前描述的<strong>Pod模板</strong>和<strong>Docker-Compose</strong>配置非常相似，但Pod模板涉及其他部署参数的设定，相对更复杂。</p><p>先排除与容器无关的配置参数，在模板的<strong>Containers</strong>部分，<strong>指明容器的部署方式</strong>。在部署过程中，会转换成对应的容器运行时（containerruntime）命令，例如，对于Docker，会转换成类似于Docker run的命令。</p><p>​    在最开始的例子中，yml文件内容如下。</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">apiVersion</span><span class="hljs-punctuation">:</span> <span class="hljs-string">v1</span><br><span class="hljs-attribute">kind</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attribute">metadata</span><span class="hljs-punctuation">:</span><br> <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">examplepod</span><br><span class="hljs-attribute">spec</span><span class="hljs-punctuation">:</span><br> <span class="hljs-attribute">containers</span><span class="hljs-punctuation">:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">name: examplepod-container</span><br>  <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">busybox</span><br>   <span class="hljs-attribute">imagePullPolicy</span><span class="hljs-punctuation">:</span> <span class="hljs-string">IfNotPresent</span><br>   <span class="hljs-attribute">command</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[&#x27;sh&#x27;, &#x27;-c&#x27;]</span><br>   <span class="hljs-attribute">args</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[&#x27;echo &quot;Hello Kubernetes!&quot;; sleep 3600&#x27;]</span><br></code></pre></td></tr></table></figure><p>在Kubernetes将Pod调度到某个节点后，kubelet会调用容器运行时（本例中为Docker），执行如下所示的命令。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">docker <span class="hljs-keyword">run</span> --name examplepod-container busybox <span class="hljs-keyword">sh</span> -c &#x27;echo<span class="hljs-string">&quot;Hello Kubernetes!&quot;</span>; <span class="hljs-keyword">sleep</span> 3600&#x27;<br></code></pre></td></tr></table></figure><hr><p><em>提示：command和args设置会分别覆盖原Docker镜像中定义的EntryPoint与CMD，在使用时请务必注意以下规则。</em></p><hr><ul><li>如果没有在模板中提供command或args，则<u>使用Docker镜像中定义的默认值运行</u>。</li><li>如果在模板中提供了command，但未提供args，则仅使用提供的command。Docker镜像中定义的默认的EntryPoint和默认的命令都将被忽略。</li><li>如果只提供了args，则Docker镜像中定义的默认的EntryPoint将与所提供的args组合到一起运行。</li><li>如果只提供了args，则Docker镜像中定义的默认的EntryPoint将与所提供的args组合到一起运行。</li><li>如果同时提供了command和args，Docker镜像中定义的默认的EntryPoint和命令都将被忽略。所提供的command和args将会组合到一起运行。</li></ul><p>同样，在Pod模板的Container设置中的各项信息，在运行时都会转换为类似的容器命令来执行。Container的基础信息的设置如下所示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">containers: <span class="hljs-comment">#Pod中的容器列表，必填，可以有多个容器</span><br>- name: String <span class="hljs-comment">#容器的名称，必填</span><br> image: String <span class="hljs-comment">#容器中的镜像地址，必填</span><br> imagePullPolicy: [Always|Never|IfNotPresent]<span class="hljs-comment">#获取镜像的策略。</span><br>Always表示下载镜像；<br> <span class="hljs-comment">#IfNotPresent表示优先使用本地镜像，否则下载镜像；Never表示仅使用本地镜</span><br>像<br> <span class="hljs-built_in">command</span>: [String] <span class="hljs-comment">#容器的启动命令列表（不配置的话，使用镜像内部的</span><br>命令）<br> args: [String] <span class="hljs-comment">#启动命令参数列表</span><br> workingDir: String <span class="hljs-comment">#容器的工作目录</span><br> volumeMounts: <span class="hljs-comment">#挂载到容器内部的存储卷设置</span><br> - name: String <span class="hljs-comment">#为了引用Pod定义的共享存储卷的名称，要用</span><br>volumes[]部分定义的卷名<br> mountPath: String <span class="hljs-comment">#存储卷在容器内挂载的绝对路径，应少于512个字符</span><br> readOnly: boolean <span class="hljs-comment">#是否为只读模式</span><br> ports: <span class="hljs-comment">#容器需要暴露的端口号列表</span><br> - name: String <span class="hljs-comment">#端口名称</span><br> containerPort: int <span class="hljs-comment">#容器要暴露的端口</span><br> hostPort: int <span class="hljs-comment">#容器所在主机监听的端口（把容器暴露的端口映射到</span><br>宿主机的端口）<br> protocol: String <span class="hljs-comment">#端口协议，支持TCP和UDP，默认为TCP</span><br> <span class="hljs-built_in">env</span>: <span class="hljs-comment">#容器运行前要设置的环境变量列表</span><br> - name: String <span class="hljs-comment">#环境变量名称</span><br> value: String <span class="hljs-comment">#环境变量值</span><br></code></pre></td></tr></table></figure><h3 id="1-1．volumeMounts配置信息"><a href="#1-1．volumeMounts配置信息" class="headerlink" title="1.1．volumeMounts配置信息"></a>1.1．volumeMounts配置信息</h3><p>容器运行时通常会提供一些机制来将存储附加到容器上。例如，Docker有两种容器机制：一种是<strong>数据卷（data volume）</strong>，它可以<u>将容器内的文件或目录映射到宿主机上的文件或目录中</u>，其命令格式为</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$docker</span> run -v <span class="hljs-regexp">/&#123;主机的目录&#125;:/</span>&#123;映射到容器的目录&#125; &#123;镜像名称&#125;<br></code></pre></td></tr></table></figure><p>另一种是<strong>数据卷容器（data volume container）</strong>，不过其本质使用的还是数据卷，这种容器一般用在一组相关的容器中，<u>用于专门处理数据存储以供其他容器挂载</u>。</p><p>不管是数据卷还是数据卷容器，其<strong>存留时间通常超过其他容器的生命周期</strong>。由于生命周期不同步，因此实现起来非常<strong>缺乏灵活性</strong>。</p><p>为了解决这些问题，<strong>Kubernetes</strong>在数据卷的基础上，<u>又新增加了一套自己的存储卷（volume）抽象机制</u>。该机制不仅允许Pod中的所有容器方便地<strong>共享数据</strong>，还允许存储卷与Pod中的其他容器保持完全一致的生命周期</p><p>下面是一个简单的示例，说明如何对容器创建数据卷及存储卷，以实现数据共享。</p><ol><li>首先，创建examplepodforvolumemount.yml文件。</li></ol><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>vim examplepodforvolumemount.yml<br></code></pre></td></tr></table></figure><ol><li>填入以下内容</li></ol><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">apiVersion</span><span class="hljs-punctuation">:</span> <span class="hljs-string">v1</span><br><span class="hljs-attribute">kind</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attribute">metadata</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">examplepodforvolumemount</span><br><span class="hljs-attribute">spec</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">containers</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">name: containerforwrite</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attribute">imagePullPolicy</span><span class="hljs-punctuation">:</span> <span class="hljs-string">IfNotPresent</span><br>    <span class="hljs-attribute">command</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[&#x27;sh&#x27;, &#x27;-c&#x27;]</span><br>    <span class="hljs-attribute">args</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[&#x27;echo &quot;test data!&quot; &gt; /write_dir/data; sleep 3600&#x27;]</span><br>    <span class="hljs-attribute">volumeMounts</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">name: filedata</span><br>    <span class="hljs-attribute">mountPath</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/write_dir</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">name: containerforread</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attribute">imagePullPolicy</span><span class="hljs-punctuation">:</span> <span class="hljs-string">IfNotPresent</span><br>    <span class="hljs-attribute">command</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[&#x27;sh&#x27;, &#x27;-c&#x27;]</span><br>    <span class="hljs-attribute">args</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[&#x27;cat /read_dir/data; sleep 3600&#x27;]</span><br>    <span class="hljs-attribute">volumeMounts</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">name: filedata</span><br>    <span class="hljs-attribute">mountPath</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/read_dir</span><br>    <span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">name: filedata</span><br>    <span class="hljs-attribute">emptyDir</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#123;&#125;</span><br></code></pre></td></tr></table></figure><p>在本例中，我们创建了<strong>两个容器</strong>。一个是<code>containerforwrite</code>，它<u>向数据卷写入数据</u>，会向<code>/write_dir/data</code>文件写入<code>&quot;testdata!&quot;</code>文本。容器内的<strong>数据卷地址</strong>为<code>/write_dir</code>，它引用的<strong>存储卷</strong>为<code>filedata</code>。</p><p>另一个容器是<code>containerforread</code>，<code>TE</code>会从<code>/read_dir/data</code>文件中读取文本，并将其输出到控制台（后续可以通过日志查询方式读取输出到控制台的文本）。容器内的数据卷地址为<code>/read_dir</code>，它引用的存储卷为<code>filedata</code>。</p><p>本例中还创建了一个存储卷，其名称为<code>filedata</code>，这个名称会<u>被容器设置中的数据卷所引用</u>。</p><p>存储卷的类型是<code>emptyDir</code>它是最基础的类型，表示<strong>纯净的空目录</strong>，其生命周期和所属的<code>Pod</code>完全一致（后续章节会讲解更多的种类）。对于例子中的两个容器，虽然数据卷地址不同（一个是<code>/write_dir</code>，一个是<code>/read_dir</code>），但因为它们都是映射到同一个空目录下的，所以本质上仍在同一个文件夹内进行操作。</p><p>执行以下命令，创建Pod。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> kubectl apply <span class="hljs-operator">-f</span> examplepodforvolumemount.yml<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220812150036626.png" alt="image-20220812150036626"></p><p>通过以下命令，查看Pod的运行情况，READY 2/2表示两个容器都已成功运行。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ kubectl <span class="hljs-built_in">get</span> pods examplepodforvolumemount<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220812150142353.png" alt="image-20220812150142353"></p><p>此时可以通过logs命令，查看Pod中containerforread容器的日志</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>kubectl logs examplepodforvolumemount containerforread<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220812150253756.png" alt="image-20220812150253756"></p><p> 此处已经可以看到containerforwrite写入的数据内容了。</p><h3 id="1-2-ports配置信息"><a href="#1-2-ports配置信息" class="headerlink" title="1.2 ports配置信息"></a>1.2 ports配置信息</h3><p>容器运行时通常会提供一些机制<strong>以将容器端口暴露出来</strong>，并<strong>映射到主机的端口上</strong>，以便其他人能通过“主机IP:端口”访问容器所提供的服务，例如，Docker的命令<code>$ docker run -p &#123;宿主机端口&#125;:&#123;容器端口&#125; &#123;镜像名称&#125;</code>。同样，Pod模板中也提供了这个功能。为了通过例子进行演示，首先，创建<code>examplepodforport.yml</code>文件。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">$ vim examplepodfor<span class="hljs-keyword">port</span>.yml<br></code></pre></td></tr></table></figure><p>在文件中填入以下内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br> <span class="hljs-attr">name:</span> <span class="hljs-string">examplepodforport</span><br><span class="hljs-attr">spec:</span><br> <span class="hljs-attr">containers:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">containerfornginx</span><br>   <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>   <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>   <span class="hljs-attr">ports:</span> <br> <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">portfoxnginx</span><br>   <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span> <br>   <span class="hljs-attr">hostPort:</span> <span class="hljs-number">8081</span> <br>   <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br></code></pre></td></tr></table></figure><p>​    在本例中，<strong>Nginx镜像中默认定义的对外提供服务的端口为80</strong>。通过<strong>containerPort</strong>属性，我们将80端口暴露出来，再通过<strong>hostPort属性将其映射到宿主机的端口8081上</strong>，以便通过“主机IP:端口”访问容器所提供的服务，其中<strong>protocol为端口协议</strong>，<u>支持TCP和UDP</u>，默认为<strong>TCP</strong>。</p><p>​        执行以下命令，创建Pod。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">$ kubectl apply -f examplepodfor<span class="hljs-keyword">port</span>.yml<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220812163407488.png" alt="image-20220812163407488"></p><p>通过以下命令，查看Pod的运行情况，直到状态变为Running。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">$ kubectl get pods examplepodfor<span class="hljs-keyword">port</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220812163813405.png" alt="image-20220812163813405"></p><p>Pod创建完成后，执行以下命令，查看Pod具体被分配到哪台Node上</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">$ kubectl describe pods examplepodfor<span class="hljs-keyword">port</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220812164520644.png" alt="image-20220812164520644"></p><p>Pod被分配到了<code>izbp113w9axywnhpyk1525z/172.19.230.67</code>上</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">Node</span><span class="hljs-title">:         izbp113w9axywnhpyk1525z</span>/<span class="hljs-number">172.19</span>.<span class="hljs-number">230.67</span><br></code></pre></td></tr></table></figure><p>使用wget检验端口是否开通</p><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220812172604700.png" alt="image-20220812172604700"></p><hr><p><strong>注意：</strong>以上案例仅为了说明<code>Kubernetes</code>是如何创建容器的，<u>这种类似于Docker直接映射到主机端口的方式</u>，在Kubernetes中<strong>强烈不推荐</strong>。</p><p>Pod只是一个运行服务的实例，随时可能在一个Node上停止，而在另一个Node上以新的IP地址启动新的Pod，因此它不能以稳定的IP地址和端口号提供服务。若要稳定地提供服务，则需要服务发现和负载均衡能力。</p><hr><h3 id="3．env配置信息"><a href="#3．env配置信息" class="headerlink" title="3．env配置信息"></a>3．env配置信息</h3><p>容器运行时通常还会提供一些机制来输入<strong>可动态配置的一些环境变量</strong>，以供容器中的应用程序使用。如在Docker中，配置环境变量的命令为<code>$ docker run --env &#123;变量1&#125;=&#123;值1&#125; --env &#123;变量2&#125;=&#123;值2&#125; ... &#123;镜像名称&#125;</code>。同样，Pod模板中也提供了这个功能。</p><p>首先，创建examplepodforenv.yml文件。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>vim examplepodforenv.yml<br></code></pre></td></tr></table></figure><p>填入以下内容：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">apiVersion</span><span class="hljs-punctuation">:</span> <span class="hljs-string">v1</span><br><span class="hljs-attribute">kind</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attribute">metadata</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">examplepodforenv</span><br><span class="hljs-attribute">spec</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">containers</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">name: containerforenv</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attribute">imagePullPolicy</span><span class="hljs-punctuation">:</span> <span class="hljs-string">IfNotPresent</span><br>    <span class="hljs-attribute">env</span><span class="hljs-punctuation">: </span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">name: parameter1</span><br>      <span class="hljs-attribute">value</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;good morning!&quot; </span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">name: parameter2</span><br>      <span class="hljs-attribute">value</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;good night!&quot;</span><br>  <span class="hljs-attribute">command</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[&#x27;sh&#x27;,&#x27;-c&#x27;]</span><br><span class="hljs-attribute">args</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[&#x27;echo &quot;$&#123;parameter1&#125; $&#123;parameter2&#125;&quot;; sleep 3600&#x27;]</span><br></code></pre></td></tr></table></figure><p>在模板中定义了一个名为<code>containerforenv</code>的容器，向它传入了两个环境变量：其中一个名为<code>parameter1</code>，值为<code>goodmorning!</code>；另一个变量名为<code>parameter2</code>，值为<code>good night!</code>。在本例中，将通过在容器中执行命令的方式，<u>将传入的两个环境变量拼接到一起并输出到日志</u>。</p><p>执行以下命令，创建Pod</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> kubectl apply <span class="hljs-operator">-f</span> examplepodforenv.yml<br></code></pre></td></tr></table></figure><p>运行以下命令，查看Pod的运行情况，直到状态变为Running</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ kubectl <span class="hljs-built_in">get</span> pods examplepodforenv<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220812193426614.png" alt="image-20220812193426614"></p><p>通过以下命令，查看Pod中输出的日志。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>kubectl logs examplepodforenv<br></code></pre></td></tr></table></figure><p>可以看到两个环境变量的值成功拼接到一起并输出到日志中</p><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220812193508164.png" alt="image-20220812193508164"></p><h2 id="2-Pod组织容器的方式"><a href="#2-Pod组织容器的方式" class="headerlink" title="2. Pod组织容器的方式"></a>2. Pod组织容器的方式</h2><p>Pod的设计初衷在于同时运行<strong>多个共同协作</strong>的进程（作为容器来运行）。Pod中的各个容器总是作为一个整体，同时调度到某台Node上。容器之间可以共享资源、网络环境和依赖，并拥有相同的生命周期。</p><p>当然，在同一个Pod中同时运行和管理多个容器，是一种相对高级的用法，只在容器必须要紧密配合进行协作的时候才使用此模式。</p><h3 id="1-容器如何组成一个Pod"><a href="#1-容器如何组成一个Pod" class="headerlink" title="1. 容器如何组成一个Pod"></a>1. 容器如何组成一个Pod</h3><p>Pod只是一种抽象，并不是一个真正的物理实体，表示一组相关容器的<strong>逻辑划分</strong>。每个Pod都包含一个或一组密切相关的业务容器，除此之外，每个Pod都还有一个称为“<strong>根容器</strong>”的特殊<strong>Pause容器</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220812194430776.png" alt="image-20220812194430776"></p><p>Pause容器其实属于Kubernetes的一部分。在一组容器作为一个单位的情况下，很难对整个容器组进行判断，如一个容器挂载了能代表整个Pod都挂载了吗？</p><p>如果引入一个和业务无关的Pause容器，用它作为Pod的根容器，<strong>用它的状态代表整组容器的状态</strong>，便能解决该问题。</p><p>另外，Pod中的所有容器都<strong>共享Pause容器的IP地址及其挂载的存储卷</strong>，这样也<strong>简化了容器之间的通信和数据共享</strong>问题。另外，Pause容器还在Pod中担任<strong>Linux命名空间共享</strong>的基础，为各个容器启用<strong>pid命名空间</strong>，开启init进程。</p><p>例如，对于本章最开始的操作示例，<strong>创建Pod后可以登录对应的Node</strong>，使用以下命令查看创建的容器。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> docker <span class="hljs-built_in">ps</span><br></code></pre></td></tr></table></figure><p>Pod中的容器可以使用Pod所提供的两种共享资源——存储和网络。</p><h4 id="1-存储"><a href="#1-存储" class="headerlink" title="1) 存储"></a>1) 存储</h4><p>在Pod中，可以指定<strong>一个或多个共享存储卷</strong>。Pod中的所有容器都可以<strong>访问共享存储卷</strong>，从而让这些容器共享数据。存储卷也可以用来持久化Pod中的存储资源，以防容器重启后文件丢失。</p><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220812204444677.png" alt="image-20220812204444677"></p><h4 id="2）网络"><a href="#2）网络" class="headerlink" title="2）网络"></a>2）网络</h4><p>每个Pod都分配了<strong>唯一的IP地址</strong>。Pod中的每个容器都<strong>共享网络命名空间</strong>，包括<u>IP地址和网络端口</u>。Pod内部的容器可以使用<strong>localhost互相通信</strong>。当Pod中的容器与Pod外部进行通信时，还必须<strong>共享网络资源</strong>（如使用端口映射）。</p><p>Docker和Kubernetes在网络空间上的差异</p><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220812215352573.png" alt="image-20220812215352573"></p><p>要查看Pod的IP，可以使用以下命令</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ kubectl <span class="hljs-keyword">get</span> pod <span class="hljs-keyword">my</span>-app <span class="hljs-comment">--template=&#123;&#123;.status.podIP&#125;&#125;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220813111719382.png" alt="image-20220813111719382"></p><h3 id="2．Pod之间如何通信"><a href="#2．Pod之间如何通信" class="headerlink" title="2．Pod之间如何通信"></a>2．Pod之间如何通信</h3><p>Docker其实一开始没有考虑<strong>多主机互连的网络解决方案</strong>。在实际的业务场景中，组件之间的管理十分复杂，应用部署的<strong>粒度更加细小</strong>。Kubernetes使用其独有的网络模型去解决这些问题。</p><p>Pod之间的通信主要涉及两个方面:</p><h4 id="1）同一个Node上Pod之间的通信"><a href="#1）同一个Node上Pod之间的通信" class="headerlink" title="1）同一个Node上Pod之间的通信"></a>1）同一个Node上Pod之间的通信</h4><p>因为同一个Node上的Pod使用的都是<strong>相同的Docker网桥</strong>，所以它们天然支持通信。</p><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220813111911317.png" alt="image-20220813111911317"></p><p>每一个Pod都有一个<strong>全局IP地址</strong>，同一个Node内不同Pod之间可以<strong>直接采用对方Pod的IP地址通信</strong>，而且不需要使用其他发现机制。因为它们都是通过veth连接在<strong>同一个docker0网桥</strong>上的，其IP地址都是<strong>从docker0网桥上动态获取的，并关联在同一个docker0网桥上</strong>，<strong>地址段也相同</strong>，所以它们之间能直接通信。</p><h4 id="2）跨Node的Pod之间的通信"><a href="#2）跨Node的Pod之间的通信" class="headerlink" title="2）跨Node的Pod之间的通信"></a>2）跨Node的Pod之间的通信</h4><p>要实现跨Node的Pod之间的通信，首先需要保证的是<strong>Pod的IP地址</strong>在<strong>所有Node上</strong>都是<strong>全局唯一的</strong>。这其实并不复杂，因为Pod的IP地址是由<strong>Docker 网桥</strong>分配的，所以可以<strong>将不同Node机器上的Docker网桥配置成不同的IP网段</strong>来实现这个功能。</p><p>然后需要在<strong>容器集群中创建一个覆盖网络</strong>来连接各个机器。目前可以通过第三方网络插件来覆盖网络。</p><p>Flannel会配置Docker网桥（即docker0），通过修<strong>改Docker的启动参数bip</strong>来实现这一点。通过这种方式，集群中各台机器的Docker网桥就得到了全局唯一的IP网段，它所创建的容器自然也拥有全局唯一的IP。</p>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Swag</title>
    <link href="/2022/07/27/Swag/"/>
    <url>/2022/07/27/Swag/</url>
    
    <content type="html"><![CDATA[<h1 id="Swaggo"><a href="#Swaggo" class="headerlink" title="Swaggo"></a>Swaggo</h1><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/1-20220727141857667.png" alt="swaggo"></p><h2 id="1-1-1关于Swaggo"><a href="#1-1-1关于Swaggo" class="headerlink" title="1.1.1关于Swaggo"></a>1.1.1关于Swaggo</h2><p>目前swaggo主要实现了swagger 2.0 的以下部分功能：</p><ul><li>基本结构（Basic Structure）</li><li>API 地址与基本路径（API Host and Base Path）</li><li>路径与操作 （Paths and Operations）</li><li>参数描述（Describing Parameters）</li><li>请求参数描述（Describing Request Body）</li><li>返回描述（Describing Responses）</li><li>MIME 类型（MIME Types）</li><li>认证（Authentication）<ul><li>Basic Authentication</li><li>API Keys</li></ul></li><li>添加实例（Adding Examples）</li><li>文件上传（File Upload）</li><li>枚举（Enums）</li><li>按标签分组（Grouping Operations With Tags）</li><li>扩展（Swagger Extensions）</li></ul><p>下文内容均以gin-swaggo为例 <a href="https://github.com/razeencheng/demo-go/tree/master/swaggo-gin">这里是demo地址</a></p><h2 id="1-1-2-使用"><a href="#1-1-2-使用" class="headerlink" title="1.1.2. 使用"></a>1.1.2. 使用</h2><p>安装swag cli 及下载相关包</p><p>要使用swaggo,首先需要安装swag cli。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">go get -u github.com<span class="hljs-regexp">/swaggo/</span>swag<span class="hljs-regexp">/cmd/</span>swag<br></code></pre></td></tr></table></figure><p>然后我们还需要两个包。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># gin-swagger 中间件</span><br>go get github.com<span class="hljs-regexp">/swaggo/gi</span>n-swagger<br><span class="hljs-comment"># swagger 内置文件</span><br>go get github.com<span class="hljs-regexp">/swaggo/gi</span>n-swagger/swaggerFiles<br></code></pre></td></tr></table></figure><p>在main.go内添加注释</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net/http&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>    _ <span class="hljs-string">&quot;github.com/student/0509/docs&quot;</span><br>    ginSwagger <span class="hljs-string">&quot;github.com/swaggo/gin-swagger&quot;</span><br>    <span class="hljs-string">&quot;github.com/swaggo/gin-swagger/swaggerFiles&quot;</span><br>)<br><br><span class="hljs-comment">// @title Swagger Example API</span><br><span class="hljs-comment">// @version 1.0</span><br><span class="hljs-comment">// @description This is a sample server celler server.</span><br><span class="hljs-comment">// @termsOfService https://www.topgoer.com</span><br><br><span class="hljs-comment">// @contact.name www.topgoer.com</span><br><span class="hljs-comment">// @contact.url https://www.topgoer.com</span><br><span class="hljs-comment">// @contact.email me@razeen.me</span><br><br><span class="hljs-comment">// @license.name Apache 2.0</span><br><span class="hljs-comment">// @license.url http://www.apache.org/licenses/LICENSE-2.0.html</span><br><br><span class="hljs-comment">// @host 127.0.0.1:8080</span><br><span class="hljs-comment">// @BasePath /api/v1</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    r := gin.Default()<br><br>    r.GET(<span class="hljs-string">&quot;/swagger/*any&quot;</span>, ginSwagger.WrapHandler(swaggerFiles.Handler))<br><br>    v1 := r.Group(<span class="hljs-string">&quot;/api/v1&quot;</span>)<br>    &#123;<br>        v1.GET(<span class="hljs-string">&quot;/hello&quot;</span>, HandleHello)<br>        <span class="hljs-comment">// v1.POST(&quot;/login&quot;, HandleLogin)</span><br>        <span class="hljs-comment">// v1Auth := r.Use(HandleAuth)</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     v1Auth.POST(&quot;/upload&quot;, HandleUpload)</span><br>        <span class="hljs-comment">//     v1Auth.GET(&quot;/list&quot;, HandleList)</span><br>        <span class="hljs-comment">// &#125;</span><br>    &#125;<br><br>    r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>如上所示，我们需要导入</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ginSwagger</span> <span class="hljs-string">&quot;github.com/swaggo/gin-swagger&quot;</span><br><span class="hljs-string">&quot;github.com/swaggo/gin-swagger/swaggerFiles&quot;</span><br></code></pre></td></tr></table></figure><p>添加注释：</p><ul><li><code>title</code>：文档标题</li><li><code>version</code>：版本</li><li><code>description,termsOfService,contact...</code>这些都是一些声明，可以不写</li><li><code>license.name</code>：必须</li><li><code>host</code>,<code>BasePath</code>:</li><li><code>securityDefinitions.basic</code>,<code>securityDefinitions.apikey</code>等</li></ul><p>到这里，我们在<code>mian.go</code>同目录下执行<code>swag init</code>就可以自动生成文档，如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">E</span>:\goproject\src\github.com\topgoer&gt;swag init<br><span class="hljs-attribute">2020</span>/<span class="hljs-number">05</span>/<span class="hljs-number">13</span> <span class="hljs-number">16</span>:<span class="hljs-number">28</span>:<span class="hljs-number">02</span> Generate swagger docs....<br><span class="hljs-attribute">2020</span>/<span class="hljs-number">05</span>/<span class="hljs-number">13</span> <span class="hljs-number">16</span>:<span class="hljs-number">28</span>:<span class="hljs-number">02</span> Generate general API Info, search dir:./<br><span class="hljs-attribute">2020</span>/<span class="hljs-number">05</span>/<span class="hljs-number">13</span> <span class="hljs-number">16</span>:<span class="hljs-number">28</span>:<span class="hljs-number">02</span> create docs.go at  docs/docs.go<br><span class="hljs-attribute">2020</span>/<span class="hljs-number">05</span>/<span class="hljs-number">13</span> <span class="hljs-number">16</span>:<span class="hljs-number">28</span>:<span class="hljs-number">02</span> create swagger.json at  docs/swagger.json<br><span class="hljs-attribute">2020</span>/<span class="hljs-number">05</span>/<span class="hljs-number">13</span> <span class="hljs-number">16</span>:<span class="hljs-number">28</span>:<span class="hljs-number">02</span> create swagger.yaml at  docs/swagger.yaml<br></code></pre></td></tr></table></figure><p>然后我们在<code>main.go</code>导入这个自动生成的<code>docs</code>包，运行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>    ginSwagger <span class="hljs-string">&quot;github.com/swaggo/gin-swagger&quot;</span><br>    <span class="hljs-string">&quot;github.com/swaggo/gin-swagger/swaggerFiles&quot;</span><br><br>    _ <span class="hljs-string">&quot;github.com/razeencheng/demo-go/swaggo-gin/docs&quot;</span><br>)<br><br><span class="hljs-comment">// @title Swagger Example API</span><br><span class="hljs-comment">// @version 1.0</span><br><span class="hljs-comment">// ...</span><br>E:\goproject\src\github.com\topgoer&gt;<span class="hljs-keyword">go</span> run main.<span class="hljs-keyword">go</span><br>[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.<br><br>[GIN-debug] [WARNING] Running in <span class="hljs-string">&quot;debug&quot;</span> mode. Switch to <span class="hljs-string">&quot;release&quot;</span> mode in production.<br> - using env:   export GIN_MODE=release<br> - using code:  gin.SetMode(gin.ReleaseMode)<br><br>[GIN-debug] GET    /swagger<span class="hljs-comment">/*any             --&gt; github.com/swaggo/gin-swagger.CustomWrapHandler.func1 (3 handlers)</span><br><span class="hljs-comment">[GIN-debug] GET    /api/v1/hello             --&gt; main.HandleHello (3 handlers)</span><br><span class="hljs-comment">[GIN-debug] Listening and serving HTTP on :8080</span><br></code></pre></td></tr></table></figure><p>浏览器打开<a href="http://127.0.0.1:8080/swagger/index.html">http://127.0.0.1:8080/swagger/index.html</a>, 我们可以看到如下文档标题已经生成。<img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/2-20220727141858552.png" alt="swaggo"></p><h3 id="1-1-3-在Handle函数上添加注释"><a href="#1-1-3-在Handle函数上添加注释" class="headerlink" title="1.1.3. 在Handle函数上添加注释"></a>1.1.3. 在Handle函数上添加注释</h3><p>接下来，我们需要在每个路由处理函数上加上注释，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net/http&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>    _ <span class="hljs-string">&quot;github.com/student/0509/docs&quot;</span><br>    ginSwagger <span class="hljs-string">&quot;github.com/swaggo/gin-swagger&quot;</span><br>    <span class="hljs-string">&quot;github.com/swaggo/gin-swagger/swaggerFiles&quot;</span><br>)<br><br><span class="hljs-comment">// @title Swagger Example API</span><br><span class="hljs-comment">// @version 1.0</span><br><span class="hljs-comment">// @description This is a sample server celler server.</span><br><span class="hljs-comment">// @termsOfService https://www.topgoer.com</span><br><br><span class="hljs-comment">// @contact.name www.topgoer.com</span><br><span class="hljs-comment">// @contact.url https://www.topgoer.com</span><br><span class="hljs-comment">// @contact.email me@razeen.me</span><br><br><span class="hljs-comment">// @license.name Apache 2.0</span><br><span class="hljs-comment">// @license.url http://www.apache.org/licenses/LICENSE-2.0.html</span><br><br><span class="hljs-comment">// @host 127.0.0.1:8080</span><br><span class="hljs-comment">// @BasePath /api/v1</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    r := gin.Default()<br><br>    r.GET(<span class="hljs-string">&quot;/swagger/*any&quot;</span>, ginSwagger.WrapHandler(swaggerFiles.Handler))<br><br>    v1 := r.Group(<span class="hljs-string">&quot;/api/v1&quot;</span>)<br>    &#123;<br>        v1.GET(<span class="hljs-string">&quot;/hello&quot;</span>, HandleHello)<br>        <span class="hljs-comment">// v1.POST(&quot;/login&quot;, HandleLogin)</span><br>        <span class="hljs-comment">// v1Auth := r.Use(HandleAuth)</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     v1Auth.POST(&quot;/upload&quot;, HandleUpload)</span><br>        <span class="hljs-comment">//     v1Auth.GET(&quot;/list&quot;, HandleList)</span><br>        <span class="hljs-comment">// &#125;</span><br>    &#125;<br><br>    r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// @Summary 测试SayHello</span><br><span class="hljs-comment">// @Description 向你说Hello</span><br><span class="hljs-comment">// @Tags 测试</span><br><span class="hljs-comment">// @Accept json</span><br><span class="hljs-comment">// @Param who query string true &quot;人名&quot;</span><br><span class="hljs-comment">// @Success 200 &#123;string&#125; string &quot;&#123;&quot;msg&quot;: &quot;hello Razeen&quot;&#125;&quot;</span><br><span class="hljs-comment">// @Failure 400 &#123;string&#125; string &quot;&#123;&quot;msg&quot;: &quot;who are you&quot;&#125;&quot;</span><br><span class="hljs-comment">// @Router /hello [get]</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HandleHello</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>    who := c.Query(<span class="hljs-string">&quot;who&quot;</span>)<br><br>    <span class="hljs-keyword">if</span> who == <span class="hljs-string">&quot;&quot;</span> &#123;<br>        c.JSON(http.StatusBadRequest, gin.H&#123;<span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;who are u?&quot;</span>&#125;)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    c.JSON(http.StatusOK, gin.H&#123;<span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;hello &quot;</span> + who&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们再次<code>swag init</code>, 运行一下。<img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/3-20220727141859223.png" alt="swaggo"></p><p>此时，该API的相关描述已经生成了，我们点击<code>Try it out</code>还可以直接测试该API。<img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/4-20220727141859903.png" alt="swaggo"></p><p>是不是很好用，当然这并没有结束，这些注释字段，我们一个个解释。<img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/5-20220727141901469.png" alt="swaggo"></p><p>这些注释对应出现在API文档的位置，我在上图中已经标出，这里我们主要详细说说下面参数：</p><h4 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h4><p>Tags 是用来给API分组的。</p><h4 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h4><p>接收的参数类型，支持表单(<code>mpfd</code>) 和 JSON(<code>json</code>)</p><h4 id="Produce"><a href="#Produce" class="headerlink" title="Produce"></a>Produce</h4><p>返回的数据结构，一般都是<code>json</code>, 其他支持如下表：</p><div class="table-container"><table><thead><tr><th>Mime Type</th><th>声明</th></tr></thead><tbody><tr><td>application/json</td><td>json</td></tr><tr><td>text/xml</td><td>xml</td></tr><tr><td>text/plain</td><td>plain</td></tr><tr><td>html</td><td>html</td></tr><tr><td>multipart/form-data</td><td>mpfd</td></tr><tr><td>application/x-www-form-urlencoded</td><td>x-www-form-urlencoded</td></tr><tr><td>application/vnd.api+json</td><td>json-api</td></tr><tr><td>application/x-json-stream</td><td>json-stream</td></tr><tr><td>application/octet-stream</td><td>octet-stream</td></tr><tr><td>image/png</td><td>png</td></tr><tr><td>image/jpeg</td><td>jpeg</td></tr><tr><td>image/gif</td><td>gif</td></tr></tbody></table></div><h4 id="Param"><a href="#Param" class="headerlink" title="Param"></a>Param</h4><p>参数，从前往后分别是：</p><blockquote><p>@Param <code>1.参数名</code> <code>2.参数类型</code> <code>3.参数数据类型</code> <code>4.是否必须</code> <code>5.参数描述``6.其他属性</code></p></blockquote><ul><li><p>1.参数名</p><p>参数名就是我们解释参数的名字。</p></li><li><p>2.参数类型</p><p>参数类型主要有三种：</p><ul><li><p><code>path</code> 该类型参数直接拼接在URL中，如<a href="https://github.com/razeencheng/demo-go/blob/master/swaggo-gin/handle.go">Demo</a>中<code>HandleGetFile</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">// @Param <span class="hljs-built_in">id</span> path <span class="hljs-built_in">integer</span> <span class="hljs-literal">true</span> <span class="hljs-string">&quot;文件ID&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><code>query</code> 该类型参数一般是组合在URL中的，如<a href="https://github.com/razeencheng/demo-go/blob/master/swaggo-gin/handle.go">Demo</a>中<code>HandleHello</code></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">// <span class="hljs-symbol">@Param</span> who query <span class="hljs-built_in">string</span> <span class="hljs-literal">true</span> <span class="hljs-string">&quot;人名&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><code>formData</code> 该类型参数一般是<code>POST,PUT</code>方法所用，如<a href="https://github.com/razeencheng/demo-go/blob/master/swaggo-gin/handle.go">Demo</a>中<code>HandleLogin</code></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">// @Param <span class="hljs-keyword">user</span> <span class="hljs-title">formData</span> <span class="hljs-keyword">string</span> <span class="hljs-literal">true</span> <span class="hljs-string">&quot;用户名&quot;</span> default(admin)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>3.参数数据类型</p><p>数据类型主要支持一下几种：</p><ul><li>string (string)</li><li>integer (int, uint, uint32, uint64)</li><li>number (float32)</li><li>boolean (bool)</li></ul><p>注意，如果你是上传文件可以使用<code>file</code>, 但参数类型一定是<code>formData</code>, 如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">// @Param <span class="hljs-keyword">file</span> formData <span class="hljs-keyword">file</span> <span class="hljs-keyword">true</span> <span class="hljs-string">&quot;文件&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>4.是否是必须</p><p>表明该参数是否是必须需要的，必须的在文档中会黑体标出，测试时必须填写。</p></li><li><p>5.参数描述</p><p>就是参数的一些说明</p></li><li><p>6.其他属性</p><p>除了上面这些属性外，我们还可以为该参数填写一些额外的属性，如枚举，默认值，值范围等。如下：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs autoit">枚举<br>// <span class="hljs-symbol">@Param</span> enumstring query <span class="hljs-built_in">string</span> <span class="hljs-literal">false</span> <span class="hljs-string">&quot;string enums&quot;</span> Enums(A, B, C)<br>// <span class="hljs-symbol">@Param</span> enumint query <span class="hljs-built_in">int</span> <span class="hljs-literal">false</span> <span class="hljs-string">&quot;int enums&quot;</span> Enums(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>// <span class="hljs-symbol">@Param</span> enumnumber query <span class="hljs-built_in">number</span> <span class="hljs-literal">false</span> <span class="hljs-string">&quot;int enums&quot;</span> Enums(<span class="hljs-number">1.1</span>, <span class="hljs-number">1.2</span>, <span class="hljs-number">1.3</span>)<br><br>值添加范围<br>// <span class="hljs-symbol">@Param</span> <span class="hljs-built_in">string</span> query <span class="hljs-built_in">string</span> <span class="hljs-literal">false</span> <span class="hljs-string">&quot;string valid&quot;</span> minlength(<span class="hljs-number">5</span>) maxlength(<span class="hljs-number">10</span>)<br>// <span class="hljs-symbol">@Param</span> <span class="hljs-built_in">int</span> query <span class="hljs-built_in">int</span> <span class="hljs-literal">false</span> <span class="hljs-string">&quot;int valid&quot;</span> mininum(<span class="hljs-number">1</span>) maxinum(<span class="hljs-number">10</span>)<br><br>设置默认值<br>// <span class="hljs-symbol">@Param</span> <span class="hljs-literal">default</span> query <span class="hljs-built_in">string</span> <span class="hljs-literal">false</span> <span class="hljs-string">&quot;string default&quot;</span> <span class="hljs-literal">default</span>(A)<br></code></pre></td></tr></table></figure><p>而且这些参数是可以组合使用的，如：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">// <span class="hljs-symbol">@Param</span> enumstring query <span class="hljs-built_in">string</span> <span class="hljs-literal">false</span> <span class="hljs-string">&quot;string enums&quot;</span> Enums(A, B, C) <span class="hljs-literal">default</span>(A)<br></code></pre></td></tr></table></figure><h4 id="Success"><a href="#Success" class="headerlink" title="Success"></a>Success</h4></li></ul><p>指定成功响应的数据。格式为：</p><blockquote><p>// @Success <code>1.HTTP响应码</code> <code>&#123;2.响应参数类型&#125;</code> <code>3.响应数据类型</code> <code>4.其他描述</code></p></blockquote><ul><li><p>1.HTTP响应码</p><p>也就是200，400，500那些。</p></li><li><p>2.响应参数类型 / 3.响应数据类型</p><p>返回的数据类型，可以是自定义类型，可以是json。</p><ul><li>自定义类型</li></ul><p>在平常的使用中，我都会返回一些指定的模型序列化JSON的数据，这时，就可以这么写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">// <span class="hljs-keyword">@Success</span> <span class="hljs-number">200</span> &#123;<span class="hljs-selector-tag">object</span>&#125; <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.File</span><br></code></pre></td></tr></table></figure><p>其中，模型直接用<code>包名.模型</code>即可。你会说，假如我返回模型数组怎么办？这时你可以这么写：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> @Success <span class="hljs-number">200</span> &#123;anrry&#125; main.File<br></code></pre></td></tr></table></figure><ul><li>json</li></ul><p>将如你只是返回其他的json数据可如下写：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">// <span class="hljs-symbol">@Success</span> <span class="hljs-number">200</span> &#123;<span class="hljs-built_in">string</span>&#125; json <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>4.其他描述</p><p>可以添加一些说明。</p></li></ul><h4 id="Failure"><a href="#Failure" class="headerlink" title="Failure"></a>Failure</h4><p> 同Success。</p><h4 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h4><p> 指定路由与HTTP方法。格式为：</p><blockquote><p>// @Router <code>/path/to/handle</code> [<code>HTTP方法</code>]</p></blockquote><p> 不用加基础路径哦。</p><h3 id="1-1-4-生成文档与测试"><a href="#1-1-4-生成文档与测试" class="headerlink" title="1.1.4. 生成文档与测试"></a>1.1.4. 生成文档与测试</h3><p>其实上面已经穿插的介绍了。</p><p>在<code>main.go</code>下运行<code>swag init</code>即可生成和更新文档。</p><p>点击文档中的<code>Try it out</code>即可测试。 如果部分API需要登陆，可以Try登陆接口即可。</p><h3 id="1-1-5-优化"><a href="#1-1-5-优化" class="headerlink" title="1.1.5. 优化"></a>1.1.5. 优化</h3><p>看到这里，基本可以使用了。但文档一般只是我们测试的时候需要，当我的产品上线后，接口文档是不应该给用户的，而且带有接口文档的包也会大很多（swaggo是直接build到二进制里的）。</p><p>想要处理这种情况，我们可以在编译的时候优化一下，如利用<code>build tag</code>来控制是否编译文档。</p><p>在<code>main.go</code>声明<code>swagHandler</code>,并在该参数不为空时才加入路由：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">var</span> swagHandler gin.HandlerFunc<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-keyword">if</span> swagHandler != <span class="hljs-literal">nil</span> &#123;<br>            r.GET(<span class="hljs-string">&quot;/swagger/*any&quot;</span>, swagHandler)<br>        &#125;<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同时,我们将该参数在另外加了<code>build tag</code>的包中初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// +build doc</span><br><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    _ <span class="hljs-string">&quot;github.com/razeencheng/demo-go/swaggo-gin/docs&quot;</span><br><br>    ginSwagger <span class="hljs-string">&quot;github.com/swaggo/gin-swagger&quot;</span><br>    <span class="hljs-string">&quot;github.com/swaggo/gin-swagger/swaggerFiles&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    swagHandler = ginSwagger.WrapHandler(swaggerFiles.Handler)<br>&#125;<br></code></pre></td></tr></table></figure><p>之后我们就可以使用<code>go build -tags &quot;doc&quot;</code>来打包带文档的包，直接<code>go build</code>来打包不带文档的包。</p><p>你会发现，即使我这么小的Demo,编译后的大小也要相差19M !</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">➜  <span class="hljs-keyword">swaggo-gin </span>git:(master) ✗ go <span class="hljs-keyword">build</span><br><span class="hljs-keyword"></span>➜  <span class="hljs-keyword">swaggo-gin </span>git:(master) ✗ <span class="hljs-keyword">ll </span><span class="hljs-keyword">swaggo-gin</span><br><span class="hljs-keyword"></span>-rwxr-xr-x  <span class="hljs-number">1</span> xxx  staff    <span class="hljs-number">15</span>M <span class="hljs-keyword">Jan </span><span class="hljs-number">13</span> <span class="hljs-number">00</span>:<span class="hljs-number">23</span> <span class="hljs-keyword">swaggo-gin</span><br><span class="hljs-keyword"></span>➜  <span class="hljs-keyword">swaggo-gin </span>git:(master) ✗ go <span class="hljs-keyword">build </span>-tags <span class="hljs-string">&quot;doc&quot;</span><br>➜  <span class="hljs-keyword">swaggo-gin </span>git:(master) ✗ <span class="hljs-keyword">ll </span><span class="hljs-keyword">swaggo-gin</span><br><span class="hljs-keyword"></span>-rwxr-xr-x  <span class="hljs-number">1</span> xxx  staff    <span class="hljs-number">34</span>M <span class="hljs-keyword">Jan </span><span class="hljs-number">13</span> <span class="hljs-number">00</span>:<span class="hljs-number">24</span> <span class="hljs-keyword">swaggo-gin</span><br></code></pre></td></tr></table></figure><p>文章到这里也就结束了，完整的<a href="https://github.com/razeencheng/demo-go/tree/master/swaggo-gin">Demo地址在这里</a>。</p><h3 id="1-1-6-使用token"><a href="#1-1-6-使用token" class="headerlink" title="1.1.6. 使用token"></a>1.1.6. 使用token</h3><p>如果你的程序中使用了token中间键，只需要添加下面两行注释即可</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">// <span class="hljs-title">@Security</span> <span class="hljs-keyword">x</span>-token<br>// <span class="hljs-title">@param</span> <span class="hljs-keyword">x</span>-token header string <span class="hljs-keyword">true</span> <span class="hljs-string">&quot;Authorization&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Swaggo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第3章 Kubernetes的安装与部署</title>
    <link href="/2022/07/17/%E7%AC%AC3%E7%AB%A0-Kubernetes%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/"/>
    <url>/2022/07/17/%E7%AC%AC3%E7%AB%A0-Kubernetes%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<p>在虚拟机上部署Kubernetes运行环境，集群构成如下</p><div class="table-container"><table><thead><tr><th>节点类型</th><th>节点名称</th><th>IP地址</th></tr></thead><tbody><tr><td>Master</td><td>k8smaster</td><td>192.168.100.100</td></tr><tr><td>Node</td><td>k8snode1</td><td>192.168.100.101</td></tr><tr><td>Node</td><td>k8snode2</td><td>192.168.100.102</td></tr><tr><td>Node</td><td>k8snode3</td><td>192.168.100.103</td></tr></tbody></table></div><p>​    给Master分配更多的内存和CPU，以减少异常的产生。</p><p>​    在开始安装之前，请先在各台机器上配置好相应的主机，以便各台机器之间可通过机器名称相互访问。可通过如下命令编辑hosts文件。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vi <span class="hljs-regexp">/etc/</span>hosts<br></code></pre></td></tr></table></figure><p>​    hosts的配置如下。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.100.100</span> k8smaster<br><span class="hljs-number">192.168.100.101</span> k8snode1<br><span class="hljs-number">192.168.100.102</span> k8snode2<br><span class="hljs-number">192.168.100.103</span> k8snode3<br></code></pre></td></tr></table></figure><h1 id="1-Master与Node都要安装的基础组件"><a href="#1-Master与Node都要安装的基础组件" class="headerlink" title="1. Master与Node都要安装的基础组件"></a>1. Master与Node都要安装的基础组件</h1><h2 id="1-在CentOS以及RHEL和Fedora系统上安装基础组件"><a href="#1-在CentOS以及RHEL和Fedora系统上安装基础组件" class="headerlink" title="1. 在CentOS以及RHEL和Fedora系统上安装基础组件"></a>1. 在CentOS以及RHEL和Fedora系统上安装基础组件</h2><p>首先安装并启动docker</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">[root@iZbp1f3y0av6g5d4zhb3uoZ ~]# yum-config-manager --<span class="hljs-built_in">add</span>-repo http://mirrors.aliyun.<span class="hljs-keyword">com</span>/docker-<span class="hljs-keyword">ce</span>/linux/centos/docker-<span class="hljs-keyword">ce</span>.repo<br>-bash: yum-config-manager: 未找到命令<br></code></pre></td></tr></table></figure><p>um-config-manager: command not found，这个是因为系统默认没有安装这个命令，这个命令在yum-utils 包里。安装命令：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum -y <span class="hljs-keyword">install</span> yum-utils<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs subunit">[root@iZbp1f3y0av6g5d4zhb3uoZ ~]# yum -y install yum-utils<br>已加载插件：fastestmirror<br>Determining fastest mirrors<br>base                                                                                                                                                                          | 3.6 kB  00:00:00<br>epel                                                                                                                                                                          | 4.7 kB  00:00:00<br>extras                                                                                                                                                                        | 2.9 kB  00:00:00<br>updates                                                                                                                                                                       | 2.9 kB  00:00:00<br>(1/4): extras/7/x86_64/primary_db                                                                                                                                             | 247 kB  00:00:00<br>(2/4): epel/x86_64/primary_db                                                                                                                                                 | 7.0 MB  00:00:00<br>(3/4): epel/x86_64/updateinfo                                                                                                                                                 | 1.1 MB  00:00:00<br>(4/4): updates/7/x86_64/primary_db                                                                                                                                            |  16 MB  00:00:00<br>正在解决依赖关系<br>--&gt; 正在检查事务<br>---&gt; 软件包 yum-utils.noarch.0.1.1.31<span class="hljs-string">-54</span>.el7_8 将被 安装<br>--&gt; 正在处理依赖关系 python-kitchen，它被软件包 yum-utils<span class="hljs-string">-1</span>.1.31<span class="hljs-string">-54</span>.el7_8.noarch 需要<br>--&gt; 正在处理依赖关系 libxml2-python，它被软件包 yum-utils<span class="hljs-string">-1</span>.1.31<span class="hljs-string">-54</span>.el7_8.noarch 需要<br>--&gt; 正在检查事务<br>---&gt; 软件包 libxml2-python.x86_64.0.2.9.1<span class="hljs-string">-6</span>.el7_9.6 将被 安装<br>--&gt; 正在处理依赖关系 libxml2 = 2.9.1<span class="hljs-string">-6</span>.el7_9.6，它被软件包 libxml2-python<span class="hljs-string">-2</span>.9.1<span class="hljs-string">-6</span>.el7_9.6.x86_64 需要<br>---&gt; 软件包 python-kitchen.noarch.0.1.1.1<span class="hljs-string">-5</span>.el7 将被 安装<br>--&gt; 正在处理依赖关系 python-chardet，它被软件包 python-kitchen<span class="hljs-string">-1</span>.1.1<span class="hljs-string">-5</span>.el7.noarch 需要<br>--&gt; 正在检查事务<br>---&gt; 软件包 libxml2.x86_64.0.2.9.1<span class="hljs-string">-6</span>.el7_2.3 将被 升级<br>---&gt; 软件包 libxml2.x86_64.0.2.9.1<span class="hljs-string">-6</span>.el7_9.6 将被 更新<br>---&gt; 软件包 python-chardet.noarch.0.2.2.1<span class="hljs-string">-3</span>.el7 将被 安装<br>--&gt; 解决依赖关系完成<br><br>依赖关系解决<br><br>=====================================================================================================================================================================================================<br> Package                                            架构                                       版本                                                源                                           大小<br>=====================================================================================================================================================================================================<br>正在安装:<br> yum-utils                                          noarch                                     1.1.31<span class="hljs-string">-54</span>.el7_8                                     base                                        122 k<br>为依赖而安装:<br> libxml2-python                                     x86_64                                     2.9.1<span class="hljs-string">-6</span>.el7_9.6                                     updates                                     247 k<br> python-chardet                                     noarch                                     2.2.1<span class="hljs-string">-3</span>.el7                                         base                                        227 k<br> python-kitchen                                     noarch                                     1.1.1<span class="hljs-string">-5</span>.el7                                         base                                        267 k<br>为依赖而更新:<br> libxml2                                            x86_64                                     2.9.1<span class="hljs-string">-6</span>.el7_9.6                                     updates                                     668 k<br><br>事务概要<br>=====================================================================================================================================================================================================<br>安装  1 软件包 (<span class="hljs-string">+3</span> 依赖软件包)<br>升级           ( 1 依赖软件包)<br><br>总下载量：1.5 M<br>Downloading packages:<br>Delta RPMs disabled because /usr/bin/applydeltarpm not installed.<br>(1/5): libxml2-python<span class="hljs-string">-2</span>.9.1<span class="hljs-string">-6</span>.el7_9.6.x86_64.rpm                                                                                                                              | 247 kB  00:00:00<br>(2/5): python-kitchen<span class="hljs-string">-1</span>.1.1<span class="hljs-string">-5</span>.el7.noarch.rpm                                                                                                                                  | 267 kB  00:00:00<br>(3/5): python-chardet<span class="hljs-string">-2</span>.2.1<span class="hljs-string">-3</span>.el7.noarch.rpm                                                                                                                                  | 227 kB  00:00:00<br>(4/5): yum-utils<span class="hljs-string">-1</span>.1.31<span class="hljs-string">-54</span>.el7_8.noarch.rpm                                                                                                                                   | 122 kB  00:00:00<br>(5/5): libxml2<span class="hljs-string">-2</span>.9.1<span class="hljs-string">-6</span>.el7_9.6.x86_64.rpm                                                                                                                                     | 668 kB  00:00:00<br>-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------<br>总计                                                                                                                                                                 2.7 MB/s | 1.5 MB  00:00:00<br>Running transaction check<br>Running transaction test<br>Transaction test succeeded<br>Running transaction<br>  正在更新    : libxml2<span class="hljs-string">-2</span>.9.1<span class="hljs-string">-6</span>.el7_9.6.x86_64                                                                                                                                                   1/6<br>  正在安装    : libxml2-python<span class="hljs-string">-2</span>.9.1<span class="hljs-string">-6</span>.el7_9.6.x86_64                                                                                                                                            2/6<br>  正在安装    : python-chardet<span class="hljs-string">-2</span>.2.1<span class="hljs-string">-3</span>.el7.noarch                                                                                                                                                3/6<br>  正在安装    : python-kitchen<span class="hljs-string">-1</span>.1.1<span class="hljs-string">-5</span>.el7.noarch                                                                                                                                                4/6<br>  正在安装    : yum-utils<span class="hljs-string">-1</span>.1.31<span class="hljs-string">-54</span>.el7_8.noarch                                                                                                                                                 5/6<br>  清理        : libxml2<span class="hljs-string">-2</span>.9.1<span class="hljs-string">-6</span>.el7_2.3.x86_64                                                                                                                                                   6/6<br>  验证中      : python-chardet<span class="hljs-string">-2</span>.2.1<span class="hljs-string">-3</span>.el7.noarch                                                                                                                                                1/6<br>  验证中      : libxml2<span class="hljs-string">-2</span>.9.1<span class="hljs-string">-6</span>.el7_9.6.x86_64                                                                                                                                                   2/6<br>  验证中      : libxml2-python<span class="hljs-string">-2</span>.9.1<span class="hljs-string">-6</span>.el7_9.6.x86_64                                                                                                                                            3/6<br>  验证中      : python-kitchen<span class="hljs-string">-1</span>.1.1<span class="hljs-string">-5</span>.el7.noarch                                                                                                                                                4/6<br>  验证中      : yum-utils<span class="hljs-string">-1</span>.1.31<span class="hljs-string">-54</span>.el7_8.noarch                                                                                                                                                 5/6<br>  验证中      : libxml2<span class="hljs-string">-2</span>.9.1<span class="hljs-string">-6</span>.el7_2.3.x86_64                                                                                                                                                   6/6<br><br>已安装:<br>  yum-utils.noarch 0:1.1.31<span class="hljs-string">-54</span>.el7_8<br><br>作为依赖被安装:<br>  libxml2-python.x86_64 0:2.9.1<span class="hljs-string">-6</span>.el7_9.6                             python-chardet.noarch 0:2.2.1<span class="hljs-string">-3</span>.el7                             python-kitchen.noarch 0:1.1.1<span class="hljs-string">-5</span>.el7<br><br>作为依赖被升级:<br>  libxml2.x86_64 0:2.9.1<span class="hljs-string">-6</span>.el7_9.6<br><br>完毕！<br></code></pre></td></tr></table></figure><p>然后继续：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> yum makecache fast<br><span class="hljs-variable">$</span> yum <span class="hljs-literal">-y</span> install docker<span class="hljs-literal">-ce</span><br><span class="hljs-variable">$</span> systemctl <span class="hljs-built_in">start</span> docker<br></code></pre></td></tr></table></figure><p>安装完成，测试命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> hello-world<br></code></pre></td></tr></table></figure><p>然后安装K8S关键组件</p><p>配置安装源地址</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/yum</span>.repos.d/Kubernetes.repo<br></code></pre></td></tr></table></figure><p>修改内容：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">[Kubernetes]<br>name=Kubernetes<br>baseurl=https:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/Kubernetes/yum</span><span class="hljs-regexp">/repos/</span>Kubernetes<br>-el7-x86_64/<br>enabled=<span class="hljs-number">1</span><br>gpgcheck=<span class="hljs-number">1</span><br>repo_gpgcheck=<span class="hljs-number">1</span><br>gpgkey=https:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/Kubernetes/yum</span><span class="hljs-regexp">/doc/yum</span>-key.gpg <br>https:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/Kubernetes/yum</span><span class="hljs-regexp">/doc/</span>rpm-package-key.gpg<br></code></pre></td></tr></table></figure><p>安装K8S关键组件：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> setenforce <span class="hljs-number">0</span><br><span class="hljs-variable">$</span> yum install <span class="hljs-literal">-y</span> kubelet kubeadm kubectl<br><span class="hljs-variable">$</span> systemctl enable kubelet &amp;&amp; systemctl <span class="hljs-built_in">start</span> kubelet<br></code></pre></td></tr></table></figure><p><img src="/Users/wuyuxian/Library/Application%20Support/typora-user-images/image-20220730160742043.png" alt=""></p><p>……</p><p>太烦了，不想装了，直接用团队现成的吧</p><h2 id="2-Master安装与配置"><a href="#2-Master安装与配置" class="headerlink" title="2. Master安装与配置"></a>2. Master安装与配置</h2><p>跳过…</p><h2 id="3-Node安装与配置"><a href="#3-Node安装与配置" class="headerlink" title="3.Node安装与配置"></a>3.Node安装与配置</h2><p>跳过</p>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第2章 K8S的核心概念</title>
    <link href="/2022/07/17/%E7%AC%AC2%E7%AB%A0-K8S%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
    <url>/2022/07/17/%E7%AC%AC2%E7%AB%A0-K8S%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<blockquote><p>容器有效管理需要考虑：</p><ul><li>组件复制；</li><li>自动缩放；</li><li>负载均衡；</li><li>滚动更新；</li><li>组件记录；</li><li>监测和健康检查；</li><li>服务发现；</li><li>认证。</li></ul><p>由Google内部的Brog演变而来的Kubernetes完美地解决了这一问题</p></blockquote><h1 id="2-1-Kubernetes的设计架构"><a href="#2-1-Kubernetes的设计架构" class="headerlink" title="2.1 Kubernetes的设计架构"></a>2.1 Kubernetes的设计架构</h1><h2 id="Master和Node"><a href="#Master和Node" class="headerlink" title="Master和Node"></a>Master和Node</h2><p>K8S集群之中，由Master和Node两种角色，Master管理Node，Node管理容器</p><h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><p>Master主要负责整个集群的管理控制，相当于整个Kubernetes集 群的首脑。它用于监控、编排、调度集群中的各个工作节点。通常 Master会占用一台独立的服务器，基于高可用原因，也有可能是多台。</p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Node则是Kubernetes集群中的各个工作节点。Node由Master管理，提供运行容器所需的各种环境，对容器进行实际的控制，而这些容器会提供实际的应用服务。</p><h4 id="Kubernetes的整体架构"><a href="#Kubernetes的整体架构" class="headerlink" title="Kubernetes的整体架构"></a>Kubernetes的整体架构</h4><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/image-20220717070231850.png" alt="Kubernetes的整体架构"></p><h2 id="2-1-1-Master"><a href="#2-1-1-Master" class="headerlink" title="2.1.1 Master"></a>2.1.1 Master</h2><h3 id="1-API-Server进程"><a href="#1-API-Server进程" class="headerlink" title="1.API Server进程"></a>1.API Server进程</h3><p>API Server（kube-apiserver）进程为Kubernetes中各类资源对象提供了==增删改查等HTTP REST接口==。对于资源的任何操作，都需要经过API Server进程来处理。除此之外，API Server进程还提供了一系列==认证授权机制==。</p><h4 id="访问API-Server进程"><a href="#访问API-Server进程" class="headerlink" title="访问API Server进程"></a>访问API Server进程</h4><h4 id="Master组成"><a href="#Master组成" class="headerlink" title="Master组成"></a>Master组成</h4><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/image-20220717070601701.png" alt="image-20220717070601701"></p><h4 id="三种访问API-Server进程的方式"><a href="#三种访问API-Server进程的方式" class="headerlink" title="三种访问API Server进程的方式"></a>三种访问API Server进程的方式</h4><ul><li><p>直接通过REST Request</p></li><li><p>通过官方提供的客户端库文件来访问，本质上，通过编程方式，转换为对API Server进程的REST API调用。</p></li><li><p>通过命令行工具kubectl客户端来访问。kubectl客户端将把命令</p><p>行转换为对API Server进程的REST API调用。</p></li></ul><h3 id="2-etcd"><a href="#2-etcd" class="headerlink" title="2.etcd"></a>2.etcd</h3><p>etcd项目是一种轻量级的分布式键值存储，由CoreOS团队开发，可以在单台Master服务器上配置，也可以配置到多台服务器。</p><p>可以将etcd理解为Kubernetes的“==数据库==”，用于保存集群中所有的配置和各个对象的状态信息。</p><p>只有API Server进程才能直接访问和操作etcd。</p><h3 id="3-调度器"><a href="#3-调度器" class="headerlink" title="3.调度器"></a>3.调度器</h3><p>调度器（kube-scheduler）是Pod资源的调度器。它用于监听最近创建但还未分配Node的Pod资源，会为Pod自动分配相应的Node。</p><p>调度器所执行的各项操作均是==基于API Server进程==的。如调度器会通过API Server进程的Watch接口监听新建的Pod，并搜索所有满足Pod需求的Node列表，再执行Pod调度逻辑。调度成功后会将Pod绑定到目标Node上。</p><h3 id="4-控制器管理器（kube-controller-manager）"><a href="#4-控制器管理器（kube-controller-manager）" class="headerlink" title="4.控制器管理器（kube-controller-manager）"></a>4.控制器管理器（kube-controller-manager）</h3><p>Kubernetes集群的大部分功能是由控制器执行的。</p><p>每个控制器都是一个独立进程，为了降低复杂度，都被编译、合并到单个文件夹中，并在单个进程中进行。</p><ul><li>Node 控制器：负责在Node出现故障时做出响应。</li><li>Replication控制器：负责对系统中的每个</li><li>ReplicationController对象维护正确数量的Pod。</li><li>Endpoint 控制器：负责生成和维护所有Endpoint对象的控制器。</li><li>Endpoint控制器用于监听Service和对应的Pod副本的变化。</li><li>ServiceAccount及Token 控制器：为新的命名空间创建默认账户和API访问令牌。</li></ul><p>kube-controller-manager所执行的各项操作也是基于API Server进程的。例如，Node控制器会通过API Server进程提供的Watch接口，实时监控Node的信息并进行相应处理。</p><h2 id="2-1-2-Node"><a href="#2-1-2-Node" class="headerlink" title="2.1.2 Node"></a>2.1.2 Node</h2><p>Node主要由3个部分组成，分别是kubelet、kube-proxy和容器运行时（container runtime）</p><h3 id="Node的组成"><a href="#Node的组成" class="headerlink" title="Node的组成"></a>Node的组成</h3><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/image-20220717072049811.png" alt="image-20220717072049811"></p><h3 id="1-kubelet"><a href="#1-kubelet" class="headerlink" title="1.kubelet"></a>1.kubelet</h3><p>​    kubelet是在每个Node上都运行的==主要代理进程==。kubelet以<strong>PodSpec</strong>为单位来运行任务，<strong>PodSpec是一种描述Pod的YAML或JSON对象。</strong><u>kubelet会运行由各种机制提供（主要通过API Server）的一系列PodSpec，并确保这些PodSpec中描述的容器健康运行。</u>不是Kubernetes创建的容器将不属于kubelet的管理范围。<strong>kubelet负责维护容器的生命周期，同时也负责存储卷（volume）等资源的管理。</strong></p><p>​    每个Node上的kubelet会<strong>定期调用</strong>Master节点上API Server进程的<strong>REST接口</strong>，报告自身状态。API Server进程接收这些信息后，<u>会将Node的状态信息更新到etcd中</u>。kubelet也通过API Server进程的<strong>Watch接口</strong>监听Pod信息，从而对Node上的Pod进行管理。</p><h3 id="2-kube-proxy"><a href="#2-kube-proxy" class="headerlink" title="2.kube-proxy"></a>2.kube-proxy</h3><p>kube-proxy主要用于<u>管理Service的访问入口</u>，包括从集群内的其他Pod到Service的访问，以及从集群外访问Service。</p><h3 id="3-容器运行时"><a href="#3-容器运行时" class="headerlink" title="3.容器运行时"></a>3.容器运行时</h3><p>容器运行时是负责运行容器的软件。Kubernetes支持多种运行时，包括Docker、containerd、cri-o、rktlet以及任何基于<strong>Kubernetes CRI（容器运行时接口）</strong>的实现。</p><h2 id="2-1-3-组件间的基本交互流程"><a href="#2-1-3-组件间的基本交互流程" class="headerlink" title="2.1.3 组件间的基本交互流程"></a>2.1.3 组件间的基本交互流程</h2><h3 id="kubectl创建Pod"><a href="#kubectl创建Pod" class="headerlink" title="kubectl创建Pod"></a>kubectl创建Pod</h3><p>当使用kubectl创建Pod时，会相继发生以下事件。</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/image-20220717072958350.png" alt="image-20220717072958350"></p><h4 id="具体发生事件"><a href="#具体发生事件" class="headerlink" title="具体发生事件"></a>具体发生事件</h4><p>（1）kubectl命令将转换为对API Server的调用。</p><p>（2）API Server验证请求并将其保存到etcd中。</p><p>（3）etcd通知API Server。</p><p>（4）API Server调用调度器。</p><p>（5）调度器决定在哪个节点运行Pod，并将其返回给APIServer。</p><p>（6）API Server将对应节点保存到etcd中。</p><p>（7）etcd通知API Server。</p><p>（8）API Server在相应的节点中调用kubelet。</p><p>（9）kubelet与容器运行时API发生交互，与容器守护进程通信以创建容器。</p><p>（10）kubelet将Pod状态更新到API Server中。</p><p>（11）API Server把最新的状态保存到etcd中。</p><h1 id="2-2-Kubernetes的核心对象"><a href="#2-2-Kubernetes的核心对象" class="headerlink" title="2.2 Kubernetes的核心对象"></a>2.2 Kubernetes的核心对象</h1><p>虽然应用程序部署的底层机制是容器，但Kubernetes在容器接口上使用了<strong>额外的抽象层</strong>，以支持<strong>弹性伸缩和生命周期管理的功能</strong>。用户并不是直接管理容器的，而是<u>定义由Kubernetes对象模型提供的各种基本类型的实例</u>，并与这些实例进行交互。</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/image-20220717073401326.png" alt="image-20220717073401326"></p><h2 id="2-2-1-Pod"><a href="#2-2-1-Pod" class="headerlink" title="2.2.1 Pod"></a>2.2.1 Pod</h2><blockquote><p> Pod是Kubernetes处理的最基本单元。容器本身并不会直接分配到主机上，而是会封装到名为Pod的对象中。</p></blockquote><p>​    Pod通常表示单个应用程序，由一个或多个关系紧密的容器构成。</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/image-20220717073548873.png" alt="image-20220717073548873"></p><p>​    <u>这些容器拥有同样的生命周期，作为一个整体一起编排到Node上。</u>这些容器共享环境、存储卷和IP空间。尽管Pod基于一个或多个容器，但应将Pod视作<strong>单一的整体、单独的应用程序</strong>。<u>Kubernetes以Pod为最小单位进行调度、伸缩并共享资源、管理生命周期。</u></p><p>​    一般来说，用户不应自行管理Pod，因为Pod并没有提供应用程序通常会用到的一些特性，如复杂的生命周期管理及动态伸缩。建议用户使用将Pod或Pod模板作为基本组件的更高级别对象，这些对象会拥有更多的特性。</p><h2 id="2-2-2-控制器"><a href="#2-2-2-控制器" class="headerlink" title="2.2.2 控制器"></a>2.2.2 控制器</h2><p>​    一般来说，用户不会直接创建Pod，而是<strong>创建控制器</strong>，<u>让控制器来管理Pod</u>。在控制器中定义Pod的部署方式（如有多少个副本、需要在哪种Node上运行等），根据不同的业务场景，Kubernetes提供了多种控制器。</p><h3 id="1．ReplicationController和ReplicaSet控制器"><a href="#1．ReplicationController和ReplicaSet控制器" class="headerlink" title="1．ReplicationController和ReplicaSet控制器"></a>1．ReplicationController和ReplicaSet控制器</h3><p>​    在使用Kubernetes时，<u>通常要管理的是由多个相同Pod组成的Pod集合，而不是单个Pod。</u></p><p>例如，ReplicationController或ReplicaSet控制器基于Pod模板进行创建，能够很好地支持<strong>水平伸缩</strong>。</p><p>​    <strong>ReplicationController可定义Pod模板</strong>，<u>并可以设置相应控制参数以实现水平伸缩</u>，以调节正在运行的相同的Pod数。这是在Kubernetes中<strong>调节负载并增强可用性</strong>的简单方式。</p><p>​    ReplicationController能根据需要自动创建新的Pod，在ReplicationController的配置中<strong>拥有和Pod定义非常相似的模板。</strong></p><p>​    ReplicationController<u>负责保证在集群中部署的Pod数量与配置中的Pod数量一致</u>。如果Pod或主机出现故障，ReplicationController会自动<strong>启用新的Pod进行补充</strong>。如果ReplicationController<u>配置中的副本数量发生改变</u>，则会<strong>启动或终止一些Pod来匹配设定好的数量</strong>。ReplicationController还可以<strong>执行滚动更新</strong>，将一组Pod逐个切换到</p><p>最新版本，从而最大限度地减少对应用程序可用性的影响。</p><p>​    <strong>ReplicaSet控制器</strong>可以看作ReplicationController的另一种版本，其Pod识别功能使它在Pod管理上更具灵活性。由于ReplicaSet控制器具有<strong>副本筛选功能</strong>，因此ReplicaSet控制器才有逐渐取代ReplicationController的趋势，但ReplicaSet控制器<strong>无法实现滚动更新</strong>，无法像ReplicationController那样在后端轮流切换到最新版本。</p><p>​    与Pod一样，ReplicationController和ReplicaSet控制器都是很少直接使用的对象。虽然它们都是基于Pod而设计的，增加了水平伸缩功能，提高了可靠性，但它们缺少一些在其他复杂对象中具有的更细粒度的生命周期管理功能。</p><h3 id="2-Deployment控制器"><a href="#2-Deployment控制器" class="headerlink" title="2.Deployment控制器"></a>2.Deployment控制器</h3><p>​    <strong>Deployment控制器可能是最常用的工作负载对象之一。</strong>Deployment控制器以<u><strong>ReplicaSet控制器</strong>为基础</u>，是更高级的概念，<u>增加了更灵活的生命周期管理功能</u>。</p><p>​    虽然Deployment控制器是<strong>基于ReplicaSet控制器</strong>的，<u>但仍有部分功能和ReplicationController相似</u>Deployment控制器解决了之前在滚动更新上存在的诸多难点。如果用ReplicationController来更新应用程序，用户需要提交一个<u>新的ReplicationController计划，以替换当前的控制器</u>。因此，对于历史记录跟踪、更新出现网络故障时的恢复以及回滚错误修改等任务，ReplicationController要么做起来非常艰难，要么需要用户自理。</p><p>​    <strong>Deployment控制器是一种高级对象</strong>，<strong>旨在简化Pod的生命周期管理</strong>。<u>只要简单更改Deployment控制器的配置文件，Kubernetes就会自动调节ReplicaSet控制器，管理应用程序不同版本之间的切换，还可以实现自动维护事件历史记录及自动撤销功能</u>，如图所示。正是由于这些强大的功能，Deployment控制器可能是使用频率最高的对象。</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/image-20220717081533254.png" alt="image-20220717081533254"></p><h3 id="3-StatefulSet控制器"><a href="#3-StatefulSet控制器" class="headerlink" title="3. StatefulSet控制器"></a>3. StatefulSet控制器</h3><p>​    <strong>StatefulSet控制器是一种提供了排序和唯一性保证的特殊Pod控制器。</strong>当有与部署顺序、持久数据或固定网络等相关的特殊需求时，可以使用StatefulSet控制器来进行更细粒度的控制。StatefulSet控制器主要用于有状态的应用，例如，StatefulSet控制器通常与面向数据的应用程序（比如数据库）相关联。即使StatefulSet控制器被重新分配到一个新的节点上，还需要访问同一个存储卷。</p><p>​    <strong>StatefulSet控制器为每个Pod创建唯一的、基于数字的名称，从而提供稳定的网络标识符。</strong>即使要将Pod转移到另一个节点，该名称也将持续存在。同样，<strong>当需要重新调度时，可以通过Pod转移持久性数据卷</strong>。即使删除了Pod，这些卷也依然存在，以防止数据意外丢失。</p><p>​    每当部署或进行伸缩调节时，StatefulSet控制器会根据名称中的<strong>标识符</strong>执行操作，这使得对执行顺序有了更大的<strong>可预测性和控制能力</strong>，它在某些情况下很有用。</p><p>​    Deployment控制器下的每一个Pod都毫无区别地提供服务，但StatefulSet控制器下的Pod则不同。虽然各个Pod的定义是一样的，但是因为其数据的不同，所以<strong>提供的服务是有差异的</strong>。比如分布式存储系统适合使用StatefulSet控制器，由Pod A存储一部分数据并提供相关服务，Pod B又存储另一部分数据并提供相关服务。又比如有些服务会临时保存客户请求的数据，例如，使用服务端会话方式存放部分信息的业务网站，由于会话的不同，Pod A和Pod B能提供的服务也不尽相同，这种场景也适合使用StatefulSet控制器。</p><h3 id="4-DaemonSet"><a href="#4-DaemonSet" class="headerlink" title="4.DaemonSet"></a>4.DaemonSet</h3><p>​    <strong>DaemonSet控制器是另一种特殊的Pod控制器，它会在集群的各个节点上运行单一的Pod副本</strong>。<strong>DaemonSet控制器非常适合部署那些为节点本身提供服务或执行维护的Pod。</strong></p><p>​    例如，日志收集和转发、监控以及运行以增加节点本身功能为目的的服务，常设置为DaemonSet控制器。因为DaemonSet控制器通常是用于提供基本服务的，并且每个节点都需要，所以它们可以绕过某些用于阻止控制器将Pod分配给某些主机的调度限制。<u>因为DaemonSet控制器独特的职责，原本Master服务器不可用于常规的Pod调度，但DaemonSet控制器可以越过基于Pod的限制，确保基础服务的运行。</u></p><h3 id="5-Job控制器和CronJob控制器"><a href="#5-Job控制器和CronJob控制器" class="headerlink" title="5.Job控制器和CronJob控制器"></a>5.Job控制器和CronJob控制器</h3><p>​    上述的各类工作负载对象都是长期运行的，拥有服务级的生命周期。Kubernetes中还有一种叫作Job控制器的工作负载对象，它基于特定任务而运行。当运行任务的容器完成工作后，Job就会成功退出。<strong>如果需要执行一次性的任务，而非提供连续的服务，Job控制器非常适合。</strong></p><p>​    CronJob控制器其实在Job控制器的基础上增加了<strong>时间调度</strong>，可以在给定的时间点运行一个任务，也可以周期性地在给定时间点运行一个任务。CronJob控制器实际上和Linux系统中的Crontab控制器非常类似。</p><h2 id="2-2-3-服务与存储"><a href="#2-2-3-服务与存储" class="headerlink" title="2.2.3 服务与存储"></a>2.2.3 服务与存储</h2><h3 id="1-Service组件和Ingress"><a href="#1-Service组件和Ingress" class="headerlink" title="1. Service组件和Ingress"></a>1. Service组件和Ingress</h3><p>​    在Kubernetes中，<strong>Service是内部负载均衡器中的一种组件</strong>，<strong>会将相同功能的Pod在逻辑上组合到一起，让它们表现得如同一个单一的实体。</strong></p><p>​    之前介绍的各个工作负载对象只保证了支撑服务的微服务Pod的数量，但是没有解决如何访问这些服务的问题。Pod只是一个运行的应用示例，随时可能在一个节点上停止，并在另一个节点使用新的IP地址启动新的Pod，因此<strong>Pod根本无法以固定的IP地址和端口号提供服务</strong>。</p><p>​    <strong>通过Service组件可以发布服务，可以跟踪并路由到所有指定类型的后端容器。</strong><u>内部使用者只需要知道Service组件提供的稳定端点即可进行访问。</u>另外，Service组件抽象可以根据需要来伸缩或替换后端的工作单元，无论Service组件具体路由到哪个Pod，其IP地址都保持稳定。通过Service组件，可以轻松获得服务发现的能力，如图。</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/image-20220717084013464.png" alt="image-20220717084013464"></p><p>​    <u>每当需要给另一个应用程序或外部用户提供某些Pod的访问权限时，就可以配置一个Service组件。</u>比如，假设需要从外网访问Pod上运行的应用程序，就需要提供必要的Service组件抽象。同样，如果应用程序需要存储或查询数据，则可能还需要配置一个内部Service组件抽象，使应用程序能访问数据库Pod。</p><p>​    <u>虽然在默认情况下只有Kubernetes集群内的机器（Master和Node）以及Pod应用可以访问Service组件，但通过某些策略，可以在集群之外使用Service组件。</u>例如，通过配置NodePort，可以在各个节点的外部网络接口上打开一个静态端口。该外部端口的流量将会通过内部集群IP服务自动路由到相应的Pod。</p><p>​    还可以<strong>通过Ingress来整合Service组件</strong>。Ingress并不是某种服务类型，可以充当多个Service组件的统一入口。Ingress支持将路由规则合并到单个资源中，可以通过同一域名或IP地址下不同的路径来访问不同的Service组件，如图所示，实现在同一域名或IP地址下发布多个服务。</p><p>​    <img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/image-20220717084449753.png" alt="image-20220717084449753"></p><h3 id="2-存储卷和持久存储卷"><a href="#2-存储卷和持久存储卷" class="headerlink" title="2.存储卷和持久存储卷"></a>2.存储卷和持久存储卷</h3><p>​    容器运行时通常会提供一些机制来将存储附加到容器上，以此实现共享数据并保证这些数据在容器重启的间隙始终是可用的，这类容器的存留时间超过其他容器的生命周期，但实现起来通常缺乏灵活性</p><p>​    为了解决这些问题，<strong>Kubernetes定义了自己的存储卷（volume）抽象，允许Pod中的所有容器共享数据，并在Pod终止之前一直保持可用</strong>，如图所示。</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/image-20220717085104634.png" alt="image-20220717085104634"></p><p>​    这意味着紧密耦合的Pod可以轻松共享文件而不需要复杂的外部机制，Pod中的容器故障不会影响对共享文件的访问。Pod终止后，共享的存储卷会被销毁，因此对于真正需要持久化的数据来说，这并非一个好的解决方案。</p><p>​    <strong>持久存储卷（persistent volume）是一种更健壮的抽象机制</strong>，<strong>不依赖于Pod的生命周期</strong>。<u>持久存储卷允许管理员为集群配置存储资源，用户可以为正在运行的Pod请求和声明存储资源。</u>带有持久存储卷的Pod一旦使用完毕，存储卷的回收策略将决定是保留存储卷（直到手动删除），还是立即删除数据。持久性数据可预防节点级的故障，并分配比本地更多的可用存储空间。</p><h2 id="2-2-4-资源划分"><a href="#2-2-4-资源划分" class="headerlink" title="2.2.4 资源划分"></a>2.2.4 资源划分</h2><h3 id="1-命名空间"><a href="#1-命名空间" class="headerlink" title="1. 命名空间"></a>1. 命名空间</h3><p>​    命名空间（namespace）的主要作用是对Kubernetes集群资源进行划分。这种划分并非物理划分而是逻辑划分，用于实现多租户的资源隔离。</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/image-20220717092408558.png" alt="image-20220717092408558"></p><h3 id="2-标签和注解"><a href="#2-标签和注解" class="headerlink" title="2. 标签和注解"></a>2. 标签和注解</h3><p>​    Kubernetes中的标签（label）是一种<strong>语义化标记</strong>，<u>可以附加到Kubernetes对象上，对它们进行标记或划</u>分。如果要针对不同的实例进行管理或路由，可以用标签来进行选择。例如，每种基于控制器的对象都可以使用标签来识别需要操作的Pod。Service组件也可以使用标签来确定应该将请求路由到哪些后端Pod，如图所示。</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/image-20220717092719027.png" alt="image-20220717092719027"></p><p>​    <strong>标签的形式是键值对，每个单元可以拥有多个标签，但每个单元对于每个键只能拥有一个值。</strong>通常来说，相对于当作标识符的name属性，标签的使用更像是对资源进行划分细类，可以用开发阶段、可访问性级别、应用程序版本等标准对各个对象进行分类。</p><p>​    <strong>注解（annotation）也是一种类似的机制，用于将任意键值信息附加到某一对象中。</strong>相对于标签，注解更灵活，可以包含少量结构化数据。一般来说，注解只是向对象添加更多元数据的一种方式，但并不用于筛选。</p><h1 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h1><h2 id="要点如下："><a href="#要点如下：" class="headerlink" title="要点如下："></a>要点如下：</h2><ul><li>Kubernetes集群主要由Master和Node组成。Master管理Node，Node管理容器。</li><li>Master的主要组件分别为kube-apiserver（负责实际操作）、etcd（负责存储）、kube-scheduler（负责Pod调度）、kubecontroller-manager（负责对象管理）。</li><li>Node的主要组件分别为kubelet（值守进程）、kube-proxy（负责服务发现）和容器运行时（负责操作容器）。</li><li>Kubernetes以Pod为最小单位进行调度、伸缩并共享资源、管理生命周期。</li><li>控制器中定义了Pod的部署方式，如有多少个副本、需要在哪种Node上运行等。根据不同的业务场景，Kubernetes提供了多种控制器，如ReplicationController、ReplicaSet控制器、Deployment控制器、StatefulSet控制器、DaemonSet控制器、Job控制器和CronJob控制器。</li><li>Service是内部负载均衡器中的一种组件，会将相同功能的Pod在逻辑上组合到一起，让它们表现得如同一个单一的实体。</li><li>Kubernetes定义了自己的存储卷抽象，允许Pod中的所有容器共享数据，在Pod终止之前一直保持可用。而持久存储卷是一种更健壮的抽象机制，不依赖于Pod的生命周期。</li><li>Label是一种语义化标签，可以附加到Kubernetes对象上，对它们进行标记或划分。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>K8S</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker快速入门</title>
    <link href="/2022/07/13/Docker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2022/07/13/Docker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Docker简介和安装"><a href="#1-Docker简介和安装" class="headerlink" title="1.Docker简介和安装"></a>1.Docker简介和安装</h1><blockquote><p>Docker是一个打包、分发、部署的工具</p><p>轻量虚拟机，只虚拟需要的运行环境</p></blockquote><h2 id="跟普通虚拟机的对比"><a href="#跟普通虚拟机的对比" class="headerlink" title="跟普通虚拟机的对比"></a>跟普通虚拟机的对比</h2><div class="table-container"><table><thead><tr><th>特性</th><th>普通虚拟机</th><th>Docker</th></tr></thead><tbody><tr><td>跨平台</td><td>通常只能在桌面级系统运行，例如 Windows/Mac，无法在不带图形界面的服务器上运行</td><td>支持的系统非常多，各类 windows 和 Linux 都支持</td></tr><tr><td>性能</td><td>性能损耗大，内存占用高，因为是把整个完整系统都虚拟出来了</td><td>性能好，只虚拟软件所需运行环境，最大化减少没用的配置</td></tr><tr><td>自动化</td><td>需要手动安装所有东西</td><td>一个命令就可以自动部署好所需环境</td></tr><tr><td>稳定性</td><td>稳定性不高，不同系统差异大</td><td>稳定性好，不同系统都一样部署方式</td></tr></tbody></table></div><h2 id="打包、分发、部署"><a href="#打包、分发、部署" class="headerlink" title="打包、分发、部署"></a>打包、分发、部署</h2><p><strong>打包</strong>：把软件运行所需的依赖、第三方库、软件打包到一起，变成一个安装包</p><p><strong>分发</strong>：将打包好的“安装包”上传镜像仓库，方便他人获取安装</p><p><strong>部署</strong>：拿着“安装包”就可以一个命令运行应用，自动模拟出一样的运行环境，不管是何种操作系统。</p><h2 id="Docker部署的优势"><a href="#Docker部署的优势" class="headerlink" title="Docker部署的优势"></a>Docker部署的优势</h2><p><strong>常规应用开发部署方式</strong>：自己在Windows上开发、测试——&gt;到Linux服务器配置运行环境部署</p><blockquote><p>问题：我机器上跑都没问题，怎么到服务器就各种问题了</p></blockquote><p><strong>Docker部署</strong>：Windows开发、测试 ——&gt;打包为Docker镜像 ——&gt;各种服务器上只需要一个命令部署好</p><blockquote><p>优点：确保了不同机器上跑都是一致的运行环境，不会出现我机器上跑正常，你机器跑就有问题的情况。</p></blockquote><h2 id="Docker-通常用来做什么"><a href="#Docker-通常用来做什么" class="headerlink" title="Docker 通常用来做什么"></a>Docker 通常用来做什么</h2><ul><li>应用分发、部署，方便传播给他人安装。特别是开源软件和提供私有部署的应用</li><li>快速安装测试/学习软件，用完就丢（类似小程序），不把时间浪费在安装软件上。例如 Redis / MongoDB / ElasticSearch / ELK</li><li>多个版本软件共存，不污染系统，例如 Python2、Python3，Redis4.0，Redis5.0</li><li>Windows 上体验/学习各种 Linux 系统</li></ul><h2 id="重要概念：镜像、容器"><a href="#重要概念：镜像、容器" class="headerlink" title="重要概念：镜像、容器"></a>重要概念：镜像、容器</h2><p><strong>镜像</strong>：可以理解为软件安装包，可以方便的进行传播和安装。<br><strong>容器</strong>：软件安装后的状态，每个软件运行环境都是独立的、隔离的，称之为容器。</p><h2 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h2><h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a><a href="https://docs.docker.com/get-docker/">Docker安装</a></h3><h3 id="镜像加速源"><a href="#镜像加速源" class="headerlink" title="镜像加速源"></a>镜像加速源</h3><div class="table-container"><table><thead><tr><th>镜像加速器</th><th>镜像加速器地址</th></tr></thead><tbody><tr><td>Docker 中国官方镜像</td><td><a href="https://registry.docker-cn.com">https://registry.docker-cn.com</a></td></tr><tr><td>DaoCloud 镜像站</td><td><a href="http://f1361db2.m.daocloud.io">http://f1361db2.m.daocloud.io</a></td></tr><tr><td>Azure 中国镜像</td><td><a href="https://dockerhub.azk8s.cn">https://dockerhub.azk8s.cn</a></td></tr><tr><td>科大镜像站</td><td><a href="https://docker.mirrors.ustc.edu.cn">https://docker.mirrors.ustc.edu.cn</a></td></tr><tr><td>阿里云</td><td>https://<your_code>.mirror.aliyuncs.com</td></tr><tr><td>七牛云</td><td><a href="https://reg-mirror.qiniu.com">https://reg-mirror.qiniu.com</a></td></tr><tr><td>网易云</td><td><a href="https://hub-mirror.c.163.com">https://hub-mirror.c.163.com</a></td></tr><tr><td>腾讯云</td><td><a href="https://mirror.ccs.tencentyun.com">https://mirror.ccs.tencentyun.com</a></td></tr></tbody></table></div><h1 id="2-Docker快速安装软件"><a href="#2-Docker快速安装软件" class="headerlink" title="2.Docker快速安装软件"></a>2.Docker快速安装软件</h1><h2 id="直接安装的缺点"><a href="#直接安装的缺点" class="headerlink" title="直接安装的缺点"></a>直接安装的缺点</h2><ul><li>安装麻烦，可能有<strong>各种依赖</strong>，运行报错。例如：WordPress，ElasticSearch，Redis，ELK</li><li>可能对 <strong>Windows 并不友好</strong>，运行有各种<strong>兼容问题</strong>，软件只支持 Linux 上跑</li><li><strong>不方便安装多版本软件</strong>，不能共存。</li><li>电脑安装了一堆软件，拖慢电脑速度。</li><li>不同系统和硬件，安装方式不一样</li></ul><h2 id="Docker-安装的优点"><a href="#Docker-安装的优点" class="headerlink" title="Docker 安装的优点"></a>Docker 安装的优点</h2><ul><li><strong>一个命令</strong>就可以安装好，快速方便</li><li>有大量的<strong>镜像</strong>，可直接使用</li><li>没有<strong>系统兼容</strong>问题，Linux 专享软件也照样跑</li><li>支持软件<strong>多版本共存</strong></li><li>用完就丢，不拖慢电脑速度</li><li>不同系统和硬件，只要安装好 Docker 其他都一样了，一个命令搞定所有</li></ul><h2 id="Docker安装Redis"><a href="#Docker安装Redis" class="headerlink" title="Docker安装Redis"></a>Docker安装Redis</h2><p>Redis 官网：<a href="https://redis.io/">https://redis.io/</a></p><blockquote><p>官网下载安装教程只有源码安装方式，没有 Windows 版本。想要自己安装 windows 版本需要去找别人编译好的安装包。</p></blockquote><p>Docker官方镜像仓库查找Redis：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><p><img src="https://sjwx.easydoc.xyz/46901064/files/kv8zs4qr.png" alt="img"></p><p>一个命令跑起来：<code>docker run -d -p 6379:6379 --name redis redis:latest</code><br>命令参考：<a href="https://docs.docker.com/engine/reference/commandline/run/">https://docs.docker.com/engine/reference/commandline/run/</a></p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/pictureimage-20220715172116860.png" alt="image-20220715172116860"></p><h3 id="运行日志"><a href="#运行日志" class="headerlink" title="运行日志"></a>运行日志</h3><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/pictureimage-20220715172221689.png" style="zoom:80%;" /></p><h1 id="3-制作自己的镜像"><a href="#3-制作自己的镜像" class="headerlink" title="3.制作自己的镜像"></a>3.制作自己的镜像</h1><h3 id="为自己的-Web-项目构建镜像"><a href="#为自己的-Web-项目构建镜像" class="headerlink" title="为自己的 Web 项目构建镜像"></a>为自己的 Web 项目构建镜像</h3><p>示例项目代码：<a href="https://github.com/gzyunke/test-docker">https://github.com/gzyunke/test-docker</a><br>这是一个 Nodejs + Koa2 写的 Web 项目，提供了简单的两个演示页面。<br>软件依赖：<a href="https://nodejs.org/zh-cn/">nodejs</a><br>项目依赖库：koa、log4js、koa-router</p><blockquote><p>本文档课件配套 <a href="https://www.bilibili.com/video/BV11L411g7U1?p=3">视频教程</a></p></blockquote><h3 id="编写-Dockerfile"><a href="#编写-Dockerfile" class="headerlink" title="编写 Dockerfile"></a>编写 Dockerfile</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">11</span><br><span class="hljs-keyword">MAINTAINER</span> easydoc.net<br><br><span class="hljs-comment"># 复制代码</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> . /app</span><br><br><span class="hljs-comment"># 设置容器启动后的默认运行目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><br><span class="hljs-comment"># 运行命令，安装依赖</span><br><span class="hljs-comment"># RUN 命令可以有多个，但是可以用 &amp;&amp; 连接多个命令来减少层级。</span><br><span class="hljs-comment"># 例如 RUN npm install &amp;&amp; cd /app &amp;&amp; mkdir logs</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> npm install --registry=https://registry.npm.taobao.org</span><br><br><span class="hljs-comment"># CMD 指令只能一个，是容器启动后执行的命令，算是程序的入口。</span><br><span class="hljs-comment"># 如果还需要运行其他命令可以用 &amp;&amp; 连接，也可以写成一个shell脚本去执行。</span><br><span class="hljs-comment"># 例如 CMD cd /app &amp;&amp; ./start.sh</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> node app.js</span><br></code></pre></td></tr></table></figure><p><a href="https://docs.docker.com/engine/reference/builder/#run">Dockerfile文档</a></p><blockquote><p>实用技巧：<br>如果你写 Dockerfile 时经常遇到一些运行错误，依赖错误等，你可以直接运行一个依赖的底，然后进入终端进行配置环境，成功后再把做过的步骤命令写道 Dockerfile 文件中，这样编写调试会快很多。<br>例如上面的底是<code>node:11</code>，我们可以运行<code>docker run -it -d node:11 bash</code>，跑起来后进入容器终端配置依赖的软件，然后尝试跑起来自己的软件，最后把所有做过的步骤写入到 Dockerfile 就好了。<br>掌握好这个技巧，你的 Dockerfile 文件编写起来就非常的得心应手了。</p></blockquote><h3 id="Build-为镜像（安装包）和运行"><a href="#Build-为镜像（安装包）和运行" class="headerlink" title="Build 为镜像（安装包）和运行"></a>Build 为镜像（安装包）和运行</h3><p>编译 <code>docker build -t test:v1 .</code></p><blockquote><p><code>-t</code> 设置镜像名字和版本号<br>命令参考：<a href="https://docs.docker.com/engine/reference/commandline/build/">https://docs.docker.com/engine/reference/commandline/build/</a></p></blockquote><p>运行 <code>docker run -p 8080:8080 --name test-hello test:v1</code></p><blockquote><p><code>-p</code> 映射容器内端口到宿主机<br><code>--name</code> 容器名字<br><code>-d</code> 后台运行<br>命令参考文档：<a href="https://docs.docker.com/engine/reference/run/">https://docs.docker.com/engine/reference/run/</a></p></blockquote><h3 id="更多相关命令"><a href="#更多相关命令" class="headerlink" title="更多相关命令"></a>更多相关命令</h3><p><code>docker ps</code> 查看当前运行中的容器<br><code>docker images</code> 查看镜像列表<br><code>docker rm container-id</code> 删除指定 id 的容器<br><code>docker stop/start container-id</code> 停止/启动指定 id 的容器<br><code>docker rmi image-id</code> 删除指定 id 的镜像<br><code>docker volume ls</code> 查看 volume 列表<br><code>docker network ls</code> 查看网络列表</p><h1 id="4-目录挂载"><a href="#4-目录挂载" class="headerlink" title="4.目录挂载"></a>4.目录挂载</h1><h2 id="现存问题"><a href="#现存问题" class="headerlink" title="现存问题"></a>现存问题</h2><ul><li>使用 Docker 运行后，我们改了项目代码不会立刻生效，需要重新<code>build</code>和<code>run</code>，很是麻烦。</li><li>容器里面产生的数据，例如 log 文件，数据库备份文件，容器删除后就丢失了。</li></ul><blockquote><p>目录挂载解决以上问题</p><p>本文档课件配套 <a href="https://www.bilibili.com/video/BV11L411g7U1?p=4">视频教程</a></p></blockquote><h2 id="几种挂载方式"><a href="#几种挂载方式" class="headerlink" title="几种挂载方式"></a>几种挂载方式</h2><ul><li><code>bind mount</code> 直接把宿主机目录映射到容器内，适合挂代码目录和配置文件。可挂到多个容器上</li><li><code>volume</code> 由容器创建和管理，创建在宿主机，所以删除容器不会丢失，官方推荐，更高效，Linux 文件系统，适合存储数据库数据。可挂到多个容器上</li><li><code>tmpfs mount</code> 适合存储临时文件，存宿主机内存中。不可多容器共享。</li></ul><p>文档参考：<a href="https://docs.docker.com/storage/">https://docs.docker.com/storage/</a></p><p><img src="https://sjwx.easydoc.xyz/46901064/files/kv96dc4q.png" alt=""></p><h2 id="挂载演示"><a href="#挂载演示" class="headerlink" title="挂载演示"></a>挂载演示</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">bind mount<span class="hljs-string">` 方式用绝对路径 `</span>-v D:<span class="hljs-regexp">/code:/</span>app<br>volume<span class="hljs-string">` 方式，只需要一个名字 `</span>-v db-data:/app<br></code></pre></td></tr></table></figure><p>示例：<br><code>docker run -p 8080:8080 --name test-hello -v D:/code:/app -d test:v1</code></p><blockquote><p>注意！<br>因为挂载后，容器里的代码就会替换为你本机的代码了，如果你代码目录没有<code>node_modules</code>目录，你需要在代码目录执行下<code>npm install --registry=https://registry.npm.taobao.org</code>确保依赖库都已经安装，否则可能会提示“Error: Cannot find module ‘koa’”<br>如果你的电脑没有安装 <a href="https://nodejs.org/en/">nodejs</a>，你需要安装一下才能执行上面的命令。</p></blockquote><h1 id="5-多容器通信"><a href="#5-多容器通信" class="headerlink" title="5.多容器通信"></a>5.多容器通信</h1><h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><p>项目往往都不是独立运行的，需要数据库、缓存这些东西配合运作。<br>这节我们把前面的 Web 项目增加一个 Redis 依赖，多跑一个 Redis 容器，演示如何多容器之间的通信。</p><h2 id="创建虚拟网络"><a href="#创建虚拟网络" class="headerlink" title="创建虚拟网络"></a>创建虚拟网络</h2><p>要想多容器之间互通，从 Web 容器访问 Redis 容器，我们只需要把他们放到同个网络中就可以了。</p><p>文档参考：<a href="https://docs.docker.com/engine/reference/commandline/network/">https://docs.docker.com/engine/reference/commandline/network/</a></p><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><h5 id="创建一个名为test-net的网络："><a href="#创建一个名为test-net的网络：" class="headerlink" title="创建一个名为test-net的网络："></a>创建一个名为<code>test-net</code>的网络：</h5><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">docker network create <span class="hljs-keyword">test</span>-<span class="hljs-keyword">net</span><br></code></pre></td></tr></table></figure><h5 id="运行-Redis-在-test-net-网络中，别名redis"><a href="#运行-Redis-在-test-net-网络中，别名redis" class="headerlink" title="运行 Redis 在 test-net 网络中，别名redis"></a>运行 Redis 在 <code>test-net</code> 网络中，别名<code>redis</code></h5><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">docker run</span> <span class="hljs-literal">-</span><span class="hljs-comment">d</span> <span class="hljs-literal">--</span><span class="hljs-comment">name redis</span> <span class="hljs-literal">--</span><span class="hljs-comment">network test</span><span class="hljs-literal">-</span><span class="hljs-comment">net</span> <span class="hljs-literal">--</span><span class="hljs-comment">network</span><span class="hljs-literal">-</span><span class="hljs-comment">alias redis redis:latest</span><br></code></pre></td></tr></table></figure><h5 id="修改代码中访问redis的地址为网络别名"><a href="#修改代码中访问redis的地址为网络别名" class="headerlink" title="修改代码中访问redis的地址为网络别名"></a>修改代码中访问<code>redis</code>的地址为网络别名</h5><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/kv98rfvb.png" alt=""></p><h5 id="运行-Web-项目，使用同个网络"><a href="#运行-Web-项目，使用同个网络" class="headerlink" title="运行 Web 项目，使用同个网络"></a>运行 Web 项目，使用同个网络</h5><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">docker <span class="hljs-keyword">run</span> -p 8080:8080 --name <span class="hljs-keyword">test</span> -v <span class="hljs-keyword">D</span>:/<span class="hljs-keyword">test</span>:/<span class="hljs-keyword">app</span> --network <span class="hljs-keyword">test</span>-<span class="hljs-keyword">net</span> -<span class="hljs-keyword">d</span> <span class="hljs-keyword">test</span>:v1<br></code></pre></td></tr></table></figure><h5 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h5><p><code>http://localhost:8080/redis</code><br>容器终端查看数据是否一致</p><h2 id="更多相关命令-1"><a href="#更多相关命令-1" class="headerlink" title="更多相关命令"></a>更多相关命令</h2><p><code>docker ps</code> 查看当前运行中的容器<br><code>docker images</code> 查看镜像列表<br><code>docker rm container-id</code> 删除指定 id 的容器<br><code>docker stop/start container-id</code> 停止/启动指定 id 的容器<br><code>docker rmi image-id</code> 删除指定 id 的镜像<br><code>docker volume ls</code> 查看 volume 列表<br><code>docker network ls</code> 查看网络列表</p><h1 id="6-Docker-Compose"><a href="#6-Docker-Compose" class="headerlink" title="6.Docker-Compose"></a>6.Docker-Compose</h1><h2 id="现存问题-1"><a href="#现存问题-1" class="headerlink" title="现存问题"></a>现存问题</h2><p>在上节，我们运行了两个容器：Web 项目 + Redis<br>如果项目依赖更多的第三方软件，我们需要管理的容器就更加多，每个都要单独配置运行，指定网络。<br>这节，我们使用 docker-compose 把项目的多个服务集合到一起，一键运行。</p><h2 id="安装-Docker-Compose"><a href="#安装-Docker-Compose" class="headerlink" title="安装 Docker Compose"></a>安装 Docker Compose</h2><ul><li>如果你是安装的桌面版 Docker，不需要额外安装，已经包含了。</li><li>如果是没图形界面的服务器版 Docker，你需要单独安装 <a href="https://docs.docker.com/compose/install/#install-compose-on-linux-systems">安装文档</a></li><li>运行<code>docker-compose</code>检查是否安装成功</li></ul><h2 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h2><p>要把项目依赖的多个服务集合到一起，我们需要编写一个<code>docker-compose.yml</code>文件，描述依赖哪些服务<br>参考文档：<a href="https://docs.docker.com/compose/">https://docs.docker.com/compose/</a></p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">version</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3.7&quot;</span><br><br><span class="hljs-attribute">services</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">app</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">build</span><span class="hljs-punctuation">:</span> <span class="hljs-string">./</span><br>    <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">80:8080</span><br>    <span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./:/app</span><br>    <span class="hljs-attribute">environment</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TZ=Asia/Shanghai</span><br>  <span class="hljs-attribute">redis</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">redis:5.0.13</span><br>    <span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">redis:/data</span><br>    <span class="hljs-attribute">environment</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TZ=Asia/Shanghai</span><br><br><span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">redis</span><span class="hljs-punctuation">:</span><br></code></pre></td></tr></table></figure><blockquote><p>容器默认时间不是北京时间，增加 TZ=Asia/Shanghai 可以改为北京时间</p></blockquote><h2 id="跑起来"><a href="#跑起来" class="headerlink" title="跑起来"></a>跑起来</h2><p>在<code>docker-compose.yml</code> 文件所在目录，执行：<code>docker-compose up</code>就可以跑起来了。<br>命令参考：<a href="https://docs.docker.com/compose/reference/up/">https://docs.docker.com/compose/reference/up/</a></p><p>在后台运行只需要加一个 -d 参数<code>docker-compose up -d</code><br>查看运行状态：<code>docker-compose ps</code><br>停止运行：<code>docker-compose stop</code><br>重启：<code>docker-compose restart</code><br>重启单个服务：<code>docker-compose restart service-name</code><br>进入容器命令行：<code>docker-compose exec service-name sh</code><br>查看容器运行log：<code>docker-compose logs [service-name]</code></p><h1 id="7-发布和部署"><a href="#7-发布和部署" class="headerlink" title="7.发布和部署"></a>7.发布和部署</h1><h2 id="镜像仓库介绍"><a href="#镜像仓库介绍" class="headerlink" title="镜像仓库介绍"></a>镜像仓库介绍</h2><p>镜像仓库用来存储我们 build 出来的“安装包”，Docker 官方提供了一个 <a href="https://hub.docker.com/">镜像库</a>，里面包含了大量镜像，基本各种软件所需依赖都有，要什么直接上去搜索。</p><p>我们也可以把自己 build 出来的镜像上传到 docker 提供的镜像库中，方便传播。<br>当然你也可以搭建自己的私有镜像库，或者使用国内各种大厂提供的镜像托管服务，例如：阿里云、腾讯云</p><blockquote><p>本文档课件配套 <a href="https://www.bilibili.com/video/BV11L411g7U1?p=7">视频教程</a></p></blockquote><h2 id="上传我们的镜像"><a href="#上传我们的镜像" class="headerlink" title="上传我们的镜像"></a>上传我们的镜像</h2><ul><li>首先你要先 <a href="https://hub.docker.com/">注册一个账号</a></li><li>创建一个镜像库<br><img src="https://sjwx.easydoc.xyz/46901064/files/kv9a2wty.png" alt="image.png"></li><li>命令行登录账号：<br><code>docker login -u username</code></li><li>新建一个tag，名字必须跟你注册账号一样<br><code>docker tag test:v1 username/test:v1</code></li><li>推上去<br><code>docker push username/test:v1</code></li><li>部署试下<br><code>docker run -dp 8080:8080 username/test:v1</code></li></ul><h5 id="docker-compose-中也可以直接用这个镜像了"><a href="#docker-compose-中也可以直接用这个镜像了" class="headerlink" title="docker-compose 中也可以直接用这个镜像了"></a>docker-compose 中也可以直接用这个镜像了</h5><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">version</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3.7&quot;</span><br><br><span class="hljs-attribute">services</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">app</span><span class="hljs-punctuation">:</span><br><span class="hljs-comment">#    build: ./</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">helloguguji/test:v1</span><br>    <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">80:8080</span><br>    <span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./:/app</span><br>    <span class="hljs-attribute">environment</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TZ=Asia/Shanghai</span><br>  <span class="hljs-attribute">redis</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">redis:5.0.13</span><br>    <span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">redis:/data</span><br>    <span class="hljs-attribute">environment</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TZ=Asia/Shanghai</span><br><br><span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">redis</span><span class="hljs-punctuation">:</span><br></code></pre></td></tr></table></figure><h2 id="阿里云容器托管"><a href="#阿里云容器托管" class="headerlink" title="阿里云容器托管"></a>阿里云容器托管</h2><p>docker 官方的镜像托管有时候上传和下载都太慢了，如果你想要更快的速度，可以使用阿里云的免费镜像托管<br>登录 <a href="https://www.aliyun.com/">阿里云</a></p><p><img src="https://sjwx.easydoc.xyz/46901064/files/kv9dqxuo.png" alt="image.png"></p><h1 id="8-备份和迁移数据"><a href="#8-备份和迁移数据" class="headerlink" title="8.备份和迁移数据"></a>8.备份和迁移数据</h1><h2 id="迁移方式介绍"><a href="#迁移方式介绍" class="headerlink" title="迁移方式介绍"></a>迁移方式介绍</h2><p>容器中的数据，如果没有用挂载目录，删除容器后就会丢失数据。</p><p>如果你是用<code>bind mount</code>直接把宿主机的目录挂进去容器，那迁移数据很方便，直接复制目录就好了<br>如果你是用<code>volume</code>方式挂载的，由于数据是由容器创建和管理的，需要用特殊的方式把数据弄出来。</p><h2 id="备份和导入-Volume-的流程"><a href="#备份和导入-Volume-的流程" class="headerlink" title="备份和导入 Volume 的流程"></a>备份和导入 Volume 的流程</h2><p>备份：</p><ul><li>运行一个 ubuntu 的容器，挂载需要备份的 volume 到容器，并且挂载宿主机目录到容器里的备份目录。</li><li>运行 tar 命令把数据压缩为一个文件</li><li>把备份文件复制到需要导入的机器</li></ul><p>导入：</p><ul><li>运行 ubuntu 容器，挂载容器的 volume，并且挂载宿主机备份文件所在目录到容器里</li><li>运行 tar 命令解压备份文件到指定目录</li></ul><h2 id="备份-MongoDB-数据演示"><a href="#备份-MongoDB-数据演示" class="headerlink" title="备份 MongoDB 数据演示"></a>备份 MongoDB 数据演示</h2><ul><li>运行一个 mongodb，创建一个名叫<code>mongo-data</code>的 volume 指向容器的 /data 目录<br><code>docker run -p 27018:27017 --name mongo -v mongo-data:/data -d mongo:4.4</code></li><li>运行一个 Ubuntu 的容器，挂载<code>mongo</code>容器的所有 volume，映射宿主机的 backup 目录到容器里面的 /backup 目录，然后运行 tar 命令把数据压缩打包<br><code>docker run --rm --volumes-from mongo -v d:/backup:/backup ubuntu tar cvf /backup/backup.tar /data/</code></li></ul><p>最后你就可以拿着这个 backup.tar 文件去其他地方导入了。</p><h2 id="恢复-Volume-数据演示"><a href="#恢复-Volume-数据演示" class="headerlink" title="恢复 Volume 数据演示"></a>恢复 Volume 数据演示</h2><ul><li>运行一个 ubuntu 容器，挂载 mongo 容器的所有 volumes，然后读取 /backup 目录中的备份文件，解压到 /data/ 目录<br><code>docker run --rm --volumes-from mongo -v d:/backup:/backup ubuntu bash -c &quot;cd /data/ &amp;&amp; tar xvf /backup/backup.tar --strip 1&quot;</code></li></ul><blockquote><p>注意，volumes-from 指定的是容器名字<br>strip 1 表示解压时去掉前面1层目录，因为压缩时包含了绝对路径</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K8S极速入门</title>
    <link href="/2022/07/13/K8S%E6%9E%81%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2022/07/13/K8S%E6%9E%81%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Kubenetes简介"><a href="#1-Kubenetes简介" class="headerlink" title="1.Kubenetes简介"></a>1.Kubenetes简介</h1>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Go Redis</title>
    <link href="/2022/07/10/Go-Redis/"/>
    <url>/2022/07/10/Go-Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1.快速入门"></a>1.快速入门</h1><h2 id="1-安装依赖包"><a href="#1-安装依赖包" class="headerlink" title="1.安装依赖包"></a>1.安装依赖包</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> -<span class="hljs-keyword">u</span> github.<span class="hljs-keyword">com</span>/<span class="hljs-keyword">go</span>-redis/redis<br></code></pre></td></tr></table></figure><h2 id="2-golang连接redis"><a href="#2-golang连接redis" class="headerlink" title="2.golang连接redis"></a>2.golang连接redis</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 根据redis配置初始化一个客户端</span><br>client := redis.NewClient(&amp;redis.Options&#123;<br>Addr:     <span class="hljs-string">&quot;localhost:6379&quot;</span>, <span class="hljs-comment">// redis地址</span><br>Password: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// redis密码，没有则留空</span><br>DB:       <span class="hljs-number">0</span>,  <span class="hljs-comment">// 默认数据库，默认是0</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="3-简单的例子"><a href="#3-简单的例子" class="headerlink" title="3.简单的例子"></a>3.简单的例子</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 设置一个key，过期时间为0，意思就是永远不过期</span><br>err := client.Set(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-number">0</span>).Err()<br><br><span class="hljs-comment">// 检测设置是否成功</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-comment">// 根据key查询缓存，通过Result函数返回两个值</span><br><span class="hljs-comment">//  第一个代表key的值，第二个代表查询错误信息</span><br>val, err := client.Get(<span class="hljs-string">&quot;key&quot;</span>).Result()<br><br><span class="hljs-comment">// 检测，查询是否出错</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;key&quot;</span>, val)<br></code></pre></td></tr></table></figure><h2 id="2-连接设置"><a href="#2-连接设置" class="headerlink" title="2.连接设置"></a>2.连接设置</h2><h2 id="1-golang连接redis"><a href="#1-golang连接redis" class="headerlink" title="1.golang连接redis"></a>1.golang连接redis</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 初始化一个新的redis client</span><br>client := redis.NewClient(&amp;redis.Options&#123;<br>Addr:     <span class="hljs-string">&quot;localhost:6379&quot;</span>, <span class="hljs-comment">// redis地址</span><br>Password: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// redis没密码，没有设置，则留空</span><br>DB:       <span class="hljs-number">0</span>,  <span class="hljs-comment">// 使用默认数据库</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>通过例子，我们知道主要通过Options配置redis的连接参数，下面对Options参数进行详细说明。</p><blockquote><p>提示：go-redis包自带了连接池，会自动维护redis连接，因此创建一次client即可，不要查询一次redis就关闭client。</p></blockquote><h1 id="2-Options参数详解"><a href="#2-Options参数详解" class="headerlink" title="2.Options参数详解"></a>2.Options参数详解</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Options <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 网络类型 tcp 或者 unix.</span><br><span class="hljs-comment">// 默认是 tcp.</span><br>Network <span class="hljs-type">string</span><br><span class="hljs-comment">// redis地址，格式 host:port</span><br>Addr <span class="hljs-type">string</span><br><br><span class="hljs-comment">// 新建一个redis连接的时候，会回调这个函数</span><br>OnConnect <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Conn)</span></span> <span class="hljs-type">error</span><br><br><span class="hljs-comment">// redis密码，redis server没有设置可以为空。</span><br>Password <span class="hljs-type">string</span><br><br><span class="hljs-comment">// redis数据库，序号从0开始，默认是0，可以不用设置</span><br>DB <span class="hljs-type">int</span><br><br><span class="hljs-comment">// redis操作失败最大重试次数，默认不重试。</span><br>MaxRetries <span class="hljs-type">int</span><br><br><span class="hljs-comment">// 最小重试时间间隔.</span><br><span class="hljs-comment">// 默认是 8ms ; -1 表示关闭.</span><br>MinRetryBackoff time.Duration<br><br><span class="hljs-comment">// 最大重试时间间隔</span><br><span class="hljs-comment">// 默认是 512ms; -1 表示关闭.</span><br>MaxRetryBackoff time.Duration<br><br><span class="hljs-comment">// redis连接超时时间.</span><br><span class="hljs-comment">// 默认是 5 秒.</span><br>DialTimeout time.Duration<br><br><span class="hljs-comment">// socket读取超时时间</span><br><span class="hljs-comment">// 默认 3 秒.</span><br>ReadTimeout time.Duration<br><br><span class="hljs-comment">// socket写超时时间</span><br>WriteTimeout time.Duration<br><br><span class="hljs-comment">// redis连接池的最大连接数.</span><br><span class="hljs-comment">// 默认连接池大小等于 cpu个数 * 10</span><br>PoolSize <span class="hljs-type">int</span><br><br><span class="hljs-comment">// redis连接池最小空闲连接数.</span><br>MinIdleConns <span class="hljs-type">int</span><br><span class="hljs-comment">// redis连接最大的存活时间，默认不会关闭过时的连接.</span><br>MaxConnAge time.Duration<br><br><span class="hljs-comment">// 当你从redis连接池获取一个连接之后，连接池最多等待这个拿出去的连接多长时间。</span><br><span class="hljs-comment">// 默认是等待 ReadTimeout + 1 秒.</span><br>PoolTimeout time.Duration<br><span class="hljs-comment">// redis连接池多久会关闭一个空闲连接.</span><br><span class="hljs-comment">// 默认是 5 分钟. -1 则表示关闭这个配置项</span><br>IdleTimeout time.Duration<br><span class="hljs-comment">// 多长时间检测一下，空闲连接</span><br><span class="hljs-comment">// 默认是 1 分钟. -1 表示关闭空闲连接检测</span><br>IdleCheckFrequency time.Duration<br><br><span class="hljs-comment">// 只读设置，如果设置为true， redis只能查询缓存不能更新。</span><br>readOnly <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-基本键值操作"><a href="#3-基本键值操作" class="headerlink" title="3.基本键值操作"></a>3.基本键值操作</h1><p>redis基本的key/value操作，指的是针对value值的类型为字符串或者数字类型的读写操作。</p><p>golang redis常用函数列表：</p><ul><li>Set - 设置一个key的值</li><li>Get - 查询key的值</li><li>GetSet - 设置一个key的值，并返回这个key的旧值</li><li>SetNX - 如果key不存在，则设置这个key的值</li><li>MGet - 批量查询key的值</li><li>MSet - 批量设置key的值</li><li>Incr,IncrBy,IncrByFloat - 针对一个key的数值进行递增操作</li><li>Decr,DecrBy - 针对一个key的数值进行递减操作</li><li>Del - 删除key操作，可以批量删除</li><li>Expire - 设置key的过期时间</li></ul><h2 id="1-Set"><a href="#1-Set" class="headerlink" title="1.Set"></a>1.<code>Set</code></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 第三个参数为过期时间，0为永不过期</span><br>err := client.Set(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;value&quot;</span>,<span class="hljs-number">0</span>).Err()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span>&#123;<br>  <span class="hljs-built_in">panic</span>(err)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-Get"><a href="#2-Get" class="headerlink" title="2.Get"></a>2.<code>Get</code></h2><p>查询key的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Result函数返回两个值，第一个是key的值，第二个是错误信息</span><br>val, err := client.Get(<span class="hljs-string">&quot;key&quot;</span>).Result()<br><span class="hljs-comment">// 判断查询是否出错</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;key&quot;</span>, val)<br></code></pre></td></tr></table></figure><h2 id="3-GetSet"><a href="#3-GetSet" class="headerlink" title="3.GetSet"></a>3.<code>GetSet</code></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Result函数返回两个值，第一个是key的值，第二个是错误信息</span><br>oldVal, err := client.GetSet(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;new value&quot;</span>).Result()<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-comment">// 打印key的旧值</span><br>fmt.Println(<span class="hljs-string">&quot;key&quot;</span>, oldVal)<br></code></pre></td></tr></table></figure><h2 id="4-SetNX"><a href="#4-SetNX" class="headerlink" title="4.SetNX"></a>4.<code>SetNX</code></h2><p>如果key不存在，则设置这个key的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 第三个参数代表key的过期时间，0代表不会过期。</span><br>err := client.SetNX(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-number">0</span>).Err()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-MGet"><a href="#5-MGet" class="headerlink" title="5.MGet"></a>5.<code>MGet</code></h2><p>批量查询key的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// MGet函数可以传入任意个key，一次性返回多个值。</span><br><span class="hljs-comment">// 这里Result返回两个值，第一个值是一个数组，第二个值是错误信息</span><br>vals, err := client.MGet(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;key3&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(vals)<br></code></pre></td></tr></table></figure><h2 id="6-MSet"><a href="#6-MSet" class="headerlink" title="6.MSet"></a>6.<code>MSet</code></h2><p>批量设置key的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">err := client.MSet(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>, <span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>, <span class="hljs-string">&quot;key3&quot;</span>, <span class="hljs-string">&quot;value3&quot;</span>).Err()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-built_in">panic</span>(err)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-Incr-、IncrBy、IncrByFloat"><a href="#7-Incr-、IncrBy、IncrByFloat" class="headerlink" title="7.Incr 、IncrBy、IncrByFloat"></a>7.<code>Incr</code> 、<code>IncrBy</code>、<code>IncrByFloat</code></h2><p>针对一个key的值进行递增操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Incr函数每次加一</span><br>val, err := client.Incr(<span class="hljs-string">&quot;key&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;最新值&quot;</span>, val)<br><br><span class="hljs-comment">// IncrBy函数，可以指定每次递增多少</span><br>val, err := client.IncrBy(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">2</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;最新值&quot;</span>, val)<br><br><span class="hljs-comment">// IncrByFloat函数，可以指定每次递增多少，跟IncrBy的区别是累加的是浮点数</span><br>val, err := client.IncrByFloat(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">2</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;最新值&quot;</span>, val)<br><br></code></pre></td></tr></table></figure><h2 id="8-Decr、DecrBy"><a href="#8-Decr、DecrBy" class="headerlink" title="8.Decr、DecrBy"></a>8.<code>Decr</code>、<code>DecrBy</code></h2><p>针对一个key的值进行递减操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Decr函数每次减一</span><br>val, err := client.Decr(<span class="hljs-string">&quot;key&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;最新值&quot;</span>, val)<br><br><span class="hljs-comment">// DecrBy函数，可以指定每次递减多少</span><br>val, err := client.DecrBy(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">2</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;最新值&quot;</span>, val)<br></code></pre></td></tr></table></figure><h2 id="9-Del"><a href="#9-Del" class="headerlink" title="9.Del"></a>9.<code>Del</code></h2><p>删除key操作，支持批量删除</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">/ 删除key<br>client.Del(<span class="hljs-string">&quot;key&quot;</span>)<br><br><span class="hljs-comment">// 删除多个key, Del函数支持删除多个key</span><br>err := client.Del(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;key3&quot;</span>).Err()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-Expire"><a href="#10-Expire" class="headerlink" title="10.Expire"></a>10.<code>Expire</code></h2><p>设置key的过期时间，单位为<strong>秒</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">client.Expire(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h1 id="4-hash用法"><a href="#4-hash用法" class="headerlink" title="4.hash用法"></a>4.hash用法</h1><p>golang redis hash类型数据操作。</p><p>如果你希望key/value的值也能作为hash结构进行操作，可以选择redis hash类型。</p><p>使用场景举例：<br>如果我们希望缓存一条用户信息(包括用户id、用户名、email字段)，希望能够做到局部读写用户信息（例如：读写用户名），也能够读取整条用户信息，那么hash类型就支持这些操作。</p><p>redis hash操作主要有2-3个元素组成：</p><ul><li>key - redis key 唯一标识</li><li>field - hash数据的字段名</li><li>value - 值，有些操作不需要值</li></ul><p><strong>go redis hash数据常用函数：</strong></p><ul><li>HSet - 根据key和field字段设置，field字段的值</li><li>HGet - 根据key和field字段，查询field字段的值</li><li>HGetAll - 根据key查询所有字段和值</li><li>HIncrBy - 根据key和field字段，累加数值。</li><li>HKeys - 根据key返回所有字段名</li><li>HLen - 根据key，查询hash的字段数量</li><li>HMGet - 根据key和多个字段名，批量查询多个hash字段值</li><li>HMSet - 根据key和多个字段名和字段值，批量设置hash字段值</li><li>HSetNX - 如果field字段不存在，则设置hash字段值</li><li>HDel - 根据key和字段名，删除hash字段，支持批量删除hash字段</li><li>HExists - 检测hash字段名是否存在。</li></ul><blockquote><p>提示：不管我们选择redis什么类型的数据，操作的时候都必须要有一个==唯一的Key, 用来唯一标识一个数据。==</p></blockquote><h2 id="1-HSet"><a href="#1-HSet" class="headerlink" title="1.HSet"></a>1.<code>HSet</code></h2><p>根据key和field字段设置，field字段的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// user_1 是hash key，username 是字段名, tizi365是字段值</span><br>err := client.HSet(<span class="hljs-string">&quot;user_1&quot;</span>, <span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;tizi365&quot;</span>).Err()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-HGet"><a href="#2-HGet" class="headerlink" title="2.HGet"></a>2.<code>HGet</code></h2><p>根据<code>key</code>和<code>field</code>字段，查询<code>field</code>字段的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// user_1 是hash key，username是字段名</span><br>username, err := client.HGet(<span class="hljs-string">&quot;user_1&quot;</span>, <span class="hljs-string">&quot;username&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(username)<br></code></pre></td></tr></table></figure><h2 id="3-HGetAll"><a href="#3-HGetAll" class="headerlink" title="3.HGetAll"></a>3.<code>HGetAll</code></h2><p>根据<code>key</code>查询所有字段和值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 一次性返回key=user_1的所有hash字段和值</span><br>data, err := client.HGetAll(<span class="hljs-string">&quot;user_1&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-comment">// data是一个map类型，这里使用使用循环迭代输出</span><br><span class="hljs-keyword">for</span> field, val := <span class="hljs-keyword">range</span> data &#123;<br>fmt.Println(field,val)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-HIncrBy"><a href="#4-HIncrBy" class="headerlink" title="4.HIncrBy"></a>4.<code>HIncrBy</code></h2><p>根据key和field字段，累加字段的数值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 累加count字段的值，一次性累加2， user_1为hash key</span><br>count, err := client.HIncrBy(<span class="hljs-string">&quot;user_1&quot;</span>, <span class="hljs-string">&quot;count&quot;</span>, <span class="hljs-number">2</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>fmt.Println(count)<br></code></pre></td></tr></table></figure><h2 id="5-HKeys"><a href="#5-HKeys" class="headerlink" title="5.HKeys"></a>5.<code>HKeys</code></h2><p>根据<code>Key</code>返回所有字段名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// keys是一个string数组</span><br>keys, err := client.HKeys(<span class="hljs-string">&quot;user_1&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>fmt.Println(keys)<br></code></pre></td></tr></table></figure><h2 id="6-HLen"><a href="#6-HLen" class="headerlink" title="6.HLen"></a>6.<code>HLen</code></h2><p>根据key，查询hash的字段数量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">size, err := client.HLen(<span class="hljs-string">&quot;key&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>fmt.Println(size)<br></code></pre></td></tr></table></figure><h2 id="7-HMGet"><a href="#7-HMGet" class="headerlink" title="7.HMGet"></a>7.<code>HMGet</code></h2><p>根据key和多个字段名，批量查询多个hash字段值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">size, err := client.HLen(<span class="hljs-string">&quot;key&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>fmt.Println(size)<br></code></pre></td></tr></table></figure><h2 id="8-HMSet"><a href="#8-HMSet" class="headerlink" title="8.HMSet"></a>8.<code>HMSet</code></h2><p>根据key和多个字段名和字段值，批量设置hash字段值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 初始化hash数据的多个字段值</span><br>data := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)<br>data[<span class="hljs-string">&quot;id&quot;</span>] = <span class="hljs-number">1</span><br>data[<span class="hljs-string">&quot;username&quot;</span>] = <span class="hljs-string">&quot;tizi&quot;</span><br><br><span class="hljs-comment">// 一次性保存多个hash字段值</span><br>err := client.HMSet(<span class="hljs-string">&quot;key&quot;</span>, data).Err()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-HSetNX"><a href="#9-HSetNX" class="headerlink" title="9.HSetNX"></a>9.<code>HSetNX</code></h2><p>如果hash不存在，则设置hash字段值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">err := client.HSetNX(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">100</span>).Err()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-HDel"><a href="#10-HDel" class="headerlink" title="10.HDel"></a>10.<code>HDel</code></h2><p>根据key和字段名，删除hash字段，支持批量删除hash字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 删除一个字段id</span><br>client.HDel(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;id&quot;</span>)<br><br><span class="hljs-comment">// 删除多个字段</span><br>client.HDel(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;username&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="11-HExists"><a href="#11-HExists" class="headerlink" title="11.HExists"></a>11.<code>HExists</code></h2><p>检查hash字段名是否存在</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 检测id字段是否存在</span><br>err := client.HExists(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;id&quot;</span>).Err()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-List用法"><a href="#5-List用法" class="headerlink" title="5.List用法"></a>5.List用法</h1><p>Redis列表是简单的字符串列表，列表是有序的，列表中的元素可以重复。</p><p>可以添加一个元素到列表的头部（左边）或者尾部（右边）</p><p><strong>golang redis list数据操作常用函数：</strong></p><ul><li>LPush - 从列表左边插入数据</li><li>LPushX - 跟LPush的区别是，仅当列表存在的时候才插入数据</li><li>RPop - 从列表的右边删除第一个数据，并返回删除的数据</li><li>RPush - 从列表右边插入数据</li><li>RPushX - 跟RPush的区别是，仅当列表存在的时候才插入数据</li><li>LPop - 从列表左边删除第一个数据，并返回删除的数据</li><li>LLen - 返回列表的大小</li><li>LRange - 返回列表的一个范围内的数据，也可以返回全部数据</li><li>LRem - 删除列表中的数据</li><li>LIndex - 根据索引坐标，查询列表中的数据</li><li>LInsert - 在指定位置插入数据</li></ul><h2 id="1-LPush"><a href="#1-LPush" class="headerlink" title="1.LPush"></a>1.<code>LPush</code></h2><p>从列表左边插入数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 插入一个数据</span><br>client.LPush(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;data1&quot;</span>)<br><br><span class="hljs-comment">// LPush支持一次插入任意个数据</span><br>err := client.LPush(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>).Err()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-LPushX"><a href="#2-LPushX" class="headerlink" title="2.LPushX"></a>2.<code>LPushX</code></h2><p>跟LPush的区别是，仅当列表存在的时候才插入数据,用法完全一样。</p><h2 id="3-RPop"><a href="#3-RPop" class="headerlink" title="3.RPop"></a>3.<code>RPop</code></h2><p>从列表的右边删除第一个数据，并返回删除的数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">val, err := client.RPop(<span class="hljs-string">&quot;key&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>fmt.Println(val)<br></code></pre></td></tr></table></figure><h2 id="4-RPush"><a href="#4-RPush" class="headerlink" title="4.RPush"></a>4.<code>RPush</code></h2><p>从列表右边插入数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 插入一个数据</span><br>client.RPush(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;data1&quot;</span>)<br><br><span class="hljs-comment">// 支持一次插入任意个数据</span><br>err := client.RPush(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>).Err()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-RPushX"><a href="#5-RPushX" class="headerlink" title="5.RPushX"></a>5.<code>RPushX</code></h2><p>跟RPush的区别是，仅当列表存在的时候才插入数据, 他们用法一样</p><h2 id="6-LPop"><a href="#6-LPop" class="headerlink" title="6.LPop"></a>6.<code>LPop</code></h2><p>从列表左边删除第一个数据，并返回删除的数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">val, err := client.LPop(<span class="hljs-string">&quot;key&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>fmt.Println(val)<br></code></pre></td></tr></table></figure><h2 id="7-LLen"><a href="#7-LLen" class="headerlink" title="7.LLen"></a>7.<code>LLen</code></h2><p>返回列表的大小</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">val, err := client.LLen(<span class="hljs-string">&quot;key&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>fmt.Println(val)<br></code></pre></td></tr></table></figure><h2 id="8-LRange"><a href="#8-LRange" class="headerlink" title="8.LRange"></a>8.<code>LRange</code></h2><p>返回列表的一个范围内的数据，也可以返回全部数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 返回从0开始到-1位置之间的数据，意思就是返回全部数据</span><br>vals, err := client.LRange(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(vals)<br></code></pre></td></tr></table></figure><h2 id="9-LRem"><a href="#9-LRem" class="headerlink" title="9.LRem"></a>9.<code>LRem</code></h2><p>删除列表中的数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 从列表左边开始，删除100， 如果出现重复元素，仅删除1次，也就是删除第一个</span><br>dels, err := client.LRem(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-comment">// 如果存在多个100，则从列表左边开始删除2个100</span><br>client.LRem(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">100</span>)<br><br><br><span class="hljs-comment">// 如果存在多个100，则从列表右边开始删除2个100</span><br><span class="hljs-comment">// 第二个参数负数表示从右边开始删除几个等于100的元素</span><br>client.LRem(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">100</span>)<br><br><span class="hljs-comment">// 如果存在多个100，第二个参数为0，表示删除所有元素等于100的数据</span><br>client.LRem(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><h2 id="10-LIndex"><a href="#10-LIndex" class="headerlink" title="10.LIndex"></a>10.<code>LIndex</code></h2><p>根据索引坐标，查询列表中的数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 列表索引从0开始计算，这里返回第6个元素</span><br>val, err := client.LIndex(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-number">5</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>fmt.Println(val)<br></code></pre></td></tr></table></figure><h2 id="11-LInsert"><a href="#11-LInsert" class="headerlink" title="11.LInsert"></a>11.<code>LInsert</code></h2><p>在指定位置插入数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 在列表中5的前面插入4</span><br><span class="hljs-comment">// before是之前的意思</span><br>err := client.LInsert(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;before&quot;</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>).Err()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-comment">// 在列表中 tizi365 元素的前面插入 欢迎你</span><br>client.LInsert(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;before&quot;</span>, <span class="hljs-string">&quot;tizi365&quot;</span>, <span class="hljs-string">&quot;欢迎你&quot;</span>)<br><br><span class="hljs-comment">// 在列表中 tizi365 元素的后面插入 2019</span><br>client.LInsert(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;after&quot;</span>, <span class="hljs-string">&quot;tizi365&quot;</span>, <span class="hljs-string">&quot;2019&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="6-集合"><a href="#6-集合" class="headerlink" title="6.集合"></a>6.集合</h1><p>redis的set类型（集合）是string类型数值的无序集合，并且集合元素唯一。</p><p>下面介绍go redis的集合用法。</p><p><strong>go redis 集合（set）常用函数列表</strong>：</p><ul><li>SAdd - 添加集合元素</li><li>SCard - 获取集合元素个数</li><li>SIsMember - 判断元素是否在集合中</li><li>SMembers - 获取集合中所有的元素</li><li>SRem - 删除集合元素</li><li>SPop,SPopN - 随机返回集合中的元素，并且删除返回的元素</li></ul><h2 id="1-SAdd"><a href="#1-SAdd" class="headerlink" title="1.SAdd"></a>1.<code>SAdd</code></h2><p>添加集合元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 添加100到集合中</span><br>err := client.SAdd(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-number">100</span>).Err()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-comment">// 将100,200,300添加到集合中</span><br>client.SAdd(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>)<br></code></pre></td></tr></table></figure><h2 id="2-SCard"><a href="#2-SCard" class="headerlink" title="2.SCard"></a>2.<code>SCard</code></h2><p>获取集合元素个数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">size, err := client.SCard(<span class="hljs-string">&quot;key&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(size)<br></code></pre></td></tr></table></figure><h2 id="3-SIsMember"><a href="#3-SIsMember" class="headerlink" title="3.SIsMember"></a>3.<code>SIsMember</code></h2><p>判断元素是否在集合中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 检测100是否包含在集合中</span><br>ok, _ := client.SIsMember(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">100</span>).Result()<br><span class="hljs-keyword">if</span> ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;集合包含指定元素&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-SMembers"><a href="#4-SMembers" class="headerlink" title="4.SMembers"></a>4.<code>SMembers</code></h2><p>获取集合中所有的元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">es, _ := client.SMembers(<span class="hljs-string">&quot;key&quot;</span>).Result()<br><span class="hljs-comment">// 返回的es是string数组</span><br>fmt.Println(es)<br></code></pre></td></tr></table></figure><h2 id="5-SRem"><a href="#5-SRem" class="headerlink" title="5.SRem"></a>5.<code>SRem</code></h2><p>删除集合元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 删除集合中的元素100</span><br>client.SRem(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">100</span>)<br><br><span class="hljs-comment">// 删除集合中的元素tizi和2019</span><br>client.SRem(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;tizi&quot;</span>, <span class="hljs-string">&quot;2019&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="6-SPop-SPopN"><a href="#6-SPop-SPopN" class="headerlink" title="6.SPop,SPopN"></a>6.<code>SPop,SPopN</code></h2><p>随机返回集合中的元素，并且删除返回的元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 随机返回集合中的一个元素，并且删除这个元素</span><br>val, _ := client.SPop(<span class="hljs-string">&quot;key&quot;</span>).Result()<br>fmt.Println(val)<br><br><span class="hljs-comment">// 随机返回集合中的5个元素，并且删除这些元素</span><br>vals, _ := client.SPopN(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">5</span>).Result()<br>fmt.Println(vals)<br></code></pre></td></tr></table></figure><h1 id="7-有序集合"><a href="#7-有序集合" class="headerlink" title="7.有序集合"></a>7.有序集合</h1><p>Redis 有序集合（sorted set）和集合一样也是string类型元素的集合,且不允许重复的成员，不同的是每个元素都会关联一个double类型的分数，这个分数主要用于集合元素排序。</p><p>下面介绍golang redis 有序集合的用法</p><p><strong>go redis有序集合常用函数:</strong></p><ul><li>ZAdd - 添加一个或者多个元素到集合，如果元素已经存在则更新分数</li><li>ZCard - 返回集合元素个数</li><li>ZCount - 统计某个分数范围内的元素个数</li><li>ZIncrBy - 增加元素的分数</li><li>ZRange,ZRevRange - 返回集合中某个索引范围的元素，根据分数从小到大排序</li><li>ZRangeByScore,ZRevRangeByScore - 根据分数范围返回集合元素，元素根据分数从小到大排序，支持分页。</li><li>ZRem - 删除集合元素</li><li>ZRemRangeByRank - 根据索引范围删除元素</li><li>ZRemRangeByScore - 根据分数范围删除元素</li><li>ZScore - 查询元素对应的分数</li><li>ZRank, ZRevRank - 查询元素的排名</li></ul><h2 id="1-ZAdd"><a href="#1-ZAdd" class="headerlink" title="1.ZAdd"></a>1.<code>ZAdd</code></h2><p>添加一个或者多个元素到集合，如果元素已经存在则更新分数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 添加一个集合元素到集合中， 这个元素的分数是2.5，元素名是tizi</span><br>err := client.ZAdd(<span class="hljs-string">&quot;key&quot;</span>, redis.Z&#123;<span class="hljs-number">2.5</span>,<span class="hljs-string">&quot;tizi&quot;</span>&#125;).Err()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是redis.Z结构体说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Z <span class="hljs-keyword">struct</span> &#123;<br>Score  <span class="hljs-type">float64</span> <span class="hljs-comment">// 分数</span><br>Member <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// 元素名</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-ZCard"><a href="#2-ZCard" class="headerlink" title="2.ZCard"></a>2.<code>ZCard</code></h2><p>返回集合元素个数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">size, err := client.ZCard(<span class="hljs-string">&quot;key&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(size)<br></code></pre></td></tr></table></figure><h2 id="3-ZCount"><a href="#3-ZCount" class="headerlink" title="3.ZCount"></a>3.<code>ZCount</code></h2><p>统计某个分数范围内的元素个数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 返回： 1&lt;=分数&lt;=5 的元素个数, 注意：&quot;1&quot;, &quot;5&quot;两个参数是字符串</span><br>size, err := client.ZCount(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(size)<br><br><span class="hljs-comment">// 返回： 1&lt;分数&lt;=5 的元素个数</span><br><span class="hljs-comment">// 说明：默认第二，第三个参数是大于等于和小于等于的关系。</span><br><span class="hljs-comment">// 如果加上（ 则表示大于或者小于，相当于去掉了等于关系。</span><br>size, err := client.ZCount(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;(1&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>).Result()<br></code></pre></td></tr></table></figure><h2 id="4-ZIncrBy"><a href="#4-ZIncrBy" class="headerlink" title="4.ZIncrBy"></a>4.<code>ZIncrBy</code></h2><p>增加元素的分数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 给元素5，加上2分</span><br>client.ZIncrBy(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">2</span>,<span class="hljs-string">&quot;5&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="5-ZRange-ZRevRange"><a href="#5-ZRange-ZRevRange" class="headerlink" title="5.ZRange,ZRevRange"></a>5.<code>ZRange,ZRevRange</code></h2><p>返回集合中某个索引范围的元素，根据分数从小到大排序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 返回从0到-1位置的集合元素， 元素按分数从小到大排序</span><br><span class="hljs-comment">// 0到-1代表则返回全部数据</span><br>vals, err := client.ZRange(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">0</span>,<span class="hljs-number">-1</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> vals &#123;<br>fmt.Println(val)<br>&#125;<br></code></pre></td></tr></table></figure><p>ZRevRange用法跟ZRange一样，区别是ZRevRange的结果是按分数从大到小排序。</p><h2 id="6-ZRangeByScore"><a href="#6-ZRangeByScore" class="headerlink" title="6.ZRangeByScore"></a>6.<code>ZRangeByScore</code></h2><p>根据分数范围返回集合元素，元素根据分数从小到大排序，支持分页。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 初始化查询条件， Offset和Count用于分页</span><br>op := redis.ZRangeBy&#123;<br>Min:<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-comment">// 最小分数</span><br>Max:<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-comment">// 最大分数</span><br>Offset:<span class="hljs-number">0</span>, <span class="hljs-comment">// 类似sql的limit, 表示开始偏移量</span><br>Count:<span class="hljs-number">5</span>, <span class="hljs-comment">// 一次返回多少数据</span><br>&#125;<br><br>vals, err := client.ZRangeByScore(<span class="hljs-string">&quot;key&quot;</span>, op).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> vals &#123;<br>fmt.Println(val)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-ZRevRangeByScore"><a href="#7-ZRevRangeByScore" class="headerlink" title="7.ZRevRangeByScore"></a>7.<code>ZRevRangeByScore</code></h2><p>用法类似ZRangeByScore，区别是元素根据分数从大到小排序。</p><h2 id="8-ZRangeByScoreWithScores"><a href="#8-ZRangeByScoreWithScores" class="headerlink" title="8.ZRangeByScoreWithScores"></a>8.<code>ZRangeByScoreWithScores</code></h2><p>用法跟ZRangeByScore一样，区别是除了返回集合元素，同时也返回元素对应的分数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 初始化查询条件， Offset和Count用于分页</span><br>op := redis.ZRangeBy&#123;<br>Min:<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-comment">// 最小分数</span><br>Max:<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-comment">// 最大分数</span><br>Offset:<span class="hljs-number">0</span>, <span class="hljs-comment">// 类似sql的limit, 表示开始偏移量</span><br>Count:<span class="hljs-number">5</span>, <span class="hljs-comment">// 一次返回多少数据</span><br>&#125;<br><br>vals, err := client.ZRangeByScoreWithScores(<span class="hljs-string">&quot;key&quot;</span>, op).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> vals &#123;<br>fmt.Println(val.Member) <span class="hljs-comment">// 集合元素</span><br>fmt.Println(val.Score) <span class="hljs-comment">// 分数</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-ZRem"><a href="#8-ZRem" class="headerlink" title="8.ZRem"></a>8.<code>ZRem</code></h2><p>删除集合元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 删除集合中的元素tizi</span><br>client.ZRem(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;tizi&quot;</span>)<br><br><span class="hljs-comment">// 删除集合中的元素tizi和xiaoli</span><br><span class="hljs-comment">// 支持一次删除多个元素</span><br>client.ZRem(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;tizi&quot;</span>, <span class="hljs-string">&quot;xiaoli&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="9-ZRemRangeByRank"><a href="#9-ZRemRangeByRank" class="headerlink" title="9.ZRemRangeByRank"></a>9.<code>ZRemRangeByRank</code></h2><p>根据索引范围删除元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 集合元素按分数排序，从最低分到高分，删除第0个元素到第5个元素。</span><br><span class="hljs-comment">// 这里相当于删除最低分的几个元素</span><br>client.ZRemRangeByRank(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>)<br><br><span class="hljs-comment">// 位置参数写成负数，代表从高分开始删除。</span><br><span class="hljs-comment">// 这个例子，删除最高分数的两个元素，-1代表最高分数的位置，-2第二高分，以此类推。</span><br>client.ZRemRangeByRank(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>)<br></code></pre></td></tr></table></figure><h2 id="10-ZRemRangeByScore"><a href="#10-ZRemRangeByScore" class="headerlink" title="10.ZRemRangeByScore"></a>10.<code>ZRemRangeByScore</code></h2><p>根据分数范围删除元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 删除范围： 2&lt;=分数&lt;=5 的元素</span><br>client.ZRemRangeByScore(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>)<br><br><span class="hljs-comment">// 删除范围： 2&lt;=分数&lt;5 的元素</span><br>client.ZRemRangeByScore(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;(5&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="11-ZScore"><a href="#11-ZScore" class="headerlink" title="11.ZScore"></a>11.<code>ZScore</code></h2><p>查询元素对应的分数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 查询集合元素tizi的分数</span><br>score, _ := client.ZScore(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;tizi&quot;</span>).Result()<br>fmt.Println(score)<br></code></pre></td></tr></table></figure><h2 id="12-ZRank"><a href="#12-ZRank" class="headerlink" title="12.ZRank"></a>12.<code>ZRank</code></h2><p>根据元素名，查询集合元素在集合中的排名，从0开始算，集合元素按分数从小到大排序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">rk, _ := client.ZRank(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;tizi&quot;</span>).Result()<br>fmt.Println(rk)<br></code></pre></td></tr></table></figure><p>ZRevRank的作用跟ZRank一样，区别是ZRevRank是按分数从大到小排序。</p><h1 id="7-发布订阅"><a href="#7-发布订阅" class="headerlink" title="7.发布订阅"></a>7.发布订阅</h1><p>Redis提供了发布订阅功能，可以用于消息的传输，Redis的发布订阅机制包括三个部分，发布者，订阅者和Channel。</p><p>发布订阅架构图：</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/pictureredis-pubsub-20220713145951000.jpg" alt="img"></p><p>发布者和订阅者都是Redis客户端，Channel则为Redis服务器端，发布者将消息发送到某个的频道，订阅了这个频道的订阅者就能接收到这条消息。Redis的这种发布订阅机制与基于主题的发布订阅类似，Channel相当于主题。</p><p>下面介绍golang如何使用redis的发布订阅功能。</p><p><strong>go redis发布订阅常用函数：</strong></p><ul><li>Subscribe - 订阅channel</li><li>PSubscribe - 订阅channel支持通配符匹配</li><li>Publish - 将信息发送到指定的channel。</li><li>PubSubChannels - 查询活跃的channel</li><li>PubSubNumSub - 查询指定的channel有多少个订阅者</li></ul><h2 id="1-Subscribe"><a href="#1-Subscribe" class="headerlink" title="1.Subscribe"></a>1.<code>Subscribe</code></h2><p>订阅channel</p><p>例子1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 订阅channel1这个channel</span><br>sub := client.Subscribe(<span class="hljs-string">&quot;channel1&quot;</span>)<br><br><span class="hljs-comment">// 读取channel消息</span><br>iface, err := sub.Receive()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// handle error</span><br>&#125;<br><br><span class="hljs-comment">// 检测收到的消息类型</span><br><span class="hljs-keyword">switch</span> iface.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> *redis.Subscription:<br>    <span class="hljs-comment">// 订阅成功</span><br><span class="hljs-keyword">case</span> *redis.Message:<br>    <span class="hljs-comment">// 处理收到的消息</span><br>    <span class="hljs-comment">// 这里需要做一下类型转换</span><br>    m := iface.(redis.Message)<br>    <span class="hljs-comment">// 打印收到的小</span><br>fmt.Println(m.Payload)<br><span class="hljs-keyword">case</span> *redis.Pong:<br>    <span class="hljs-comment">// 收到Pong消息</span><br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// handle error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>例子2：<br>使用golang channel的方式处理消息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 订阅channel1这个channel</span><br>sub := client.Subscribe(<span class="hljs-string">&quot;channel1&quot;</span>)<br><br><span class="hljs-comment">// sub.Channel() 返回go channel，可以循环读取redis服务器发过来的消息</span><br><span class="hljs-keyword">for</span> msg := <span class="hljs-keyword">range</span> sub.Channel() &#123;<br><span class="hljs-comment">// 打印收到的消息</span><br>fmt.Println(msg.Channel)<br>fmt.Println(msg.Payload)<br>&#125;<br></code></pre></td></tr></table></figure><p>例子3：<br>取消订阅</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 订阅channel1这个channel</span><br>sub := client.Subscribe(<span class="hljs-string">&quot;channel1&quot;</span>)<br><br><span class="hljs-comment">// 忽略其他处理逻辑</span><br> <br><span class="hljs-comment">// 取消订阅</span><br>sub.Unsubscribe(<span class="hljs-string">&quot;channel1&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="2-PSubscribe"><a href="#2-PSubscribe" class="headerlink" title="2.PSubscribe"></a>2.<code>PSubscribe</code></h2><p>用法跟Subscribe一样，区别是PSubscribe订阅通道(channel)支持模式匹配。</p><p>例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 订阅channel1这个channel</span><br>sub := client.PSubscribe(<span class="hljs-string">&quot;ch_user_*&quot;</span>)<br><span class="hljs-comment">// 可以匹配ch_user_开头的任意channel</span><br></code></pre></td></tr></table></figure><h2 id="3-Publish"><a href="#3-Publish" class="headerlink" title="3.Publish"></a>3.<code>Publish</code></h2><p>将消息发送到指定的channel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 将&quot;message&quot;消息发送到channel1这个通道上</span><br>client.Publish(<span class="hljs-string">&quot;channel1&quot;</span>,<span class="hljs-string">&quot;message&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="4-PubSubChannels"><a href="#4-PubSubChannels" class="headerlink" title="4.PubSubChannels"></a>4.<code>PubSubChannels</code></h2><p>查询活跃的channel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 没有指定查询channel的匹配模式，则返回所有的channel</span><br>chs, _ := client.PubSubChannels(<span class="hljs-string">&quot;&quot;</span>).Result()<br><span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> chs &#123;<br>fmt.Println(ch)<br>&#125;<br><br><span class="hljs-comment">// 匹配user_开头的channel</span><br>chs, _ := client.PubSubChannels(<span class="hljs-string">&quot;user_*&quot;</span>).Result()<br></code></pre></td></tr></table></figure><h2 id="5-PubSubNumSub"><a href="#5-PubSubNumSub" class="headerlink" title="5.PubSubNumSub"></a>5.<code>PubSubNumSub</code></h2><p>查询指定的channel有多少个订阅者</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 查询channel1，channel2两个通道的订阅者数量</span><br>chs, _ := client.PubSubNumSub(<span class="hljs-string">&quot;channel1&quot;</span>, <span class="hljs-string">&quot;channel2&quot;</span>).Result()<br><span class="hljs-keyword">for</span> ch, count := <span class="hljs-keyword">range</span> chs &#123;<br>fmt.Println(ch) <span class="hljs-comment">// channel名字</span><br>fmt.Println(count) <span class="hljs-comment">// channel的订阅者数量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>redis事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p><ul><li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li><li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li></ul><h1 id="8-事务"><a href="#8-事务" class="headerlink" title="8.事务"></a>8.事务</h1><p>下面介绍golang redis事务用法。</p><p><strong>go redis事务常用函数：</strong></p><ul><li>TxPipeline - 以Pipeline的方式操作事务</li><li>Watch - redis乐观锁支持</li></ul><h2 id="1-TxPipeline"><a href="#1-TxPipeline" class="headerlink" title="1.TxPipeline"></a>1.<code>TxPipeline</code></h2><p>以Pipeline的方式操作事务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 开启一个TxPipeline事务</span><br>pipe := client.TxPipeline()<br><br><span class="hljs-comment">// 执行事务操作，可以通过pipe读写redis</span><br>incr := pipe.Incr(<span class="hljs-string">&quot;tx_pipeline_counter&quot;</span>)<br>pipe.Expire(<span class="hljs-string">&quot;tx_pipeline_counter&quot;</span>, time.Hour)<br><br><span class="hljs-comment">// 上面代码等同于执行下面redis命令</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//     MULTI</span><br><span class="hljs-comment">//     INCR pipeline_counter</span><br><span class="hljs-comment">//     EXPIRE pipeline_counts 3600</span><br><span class="hljs-comment">//     EXEC</span><br><br><span class="hljs-comment">// 通过Exec函数提交redis事务</span><br>_, err := pipe.Exec()<br><br><span class="hljs-comment">// 提交事务后，我们可以查询事务操作的结果</span><br><span class="hljs-comment">// 前面执行Incr函数，在没有执行exec函数之前，实际上还没开始运行。</span><br>fmt.Println(incr.Val(), err)<br></code></pre></td></tr></table></figure><h2 id="2-watch"><a href="#2-watch" class="headerlink" title="2.watch"></a>2.<code>watch</code></h2><p>redis乐观锁支持，可以通过watch监听一些Key, 如果这些key的值没有被其他人改变的话，才可以提交事务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义一个回调函数，用于处理事务逻辑</span><br>fn := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(tx *redis.Tx)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 先查询下当前watch监听的key的值</span><br>v, err := tx.Get(<span class="hljs-string">&quot;key&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &amp;&amp; err != redis.Nil &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">// 这里可以处理业务</span><br>fmt.Println(v)<br><br><span class="hljs-comment">// 如果key的值没有改变的话，Pipelined函数才会调用成功</span><br>_, err = tx.Pipelined(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(pipe redis.Pipeliner)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 在这里给key设置最新值</span><br>pipe.Set(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;new value&quot;</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">// 使用Watch监听一些Key, 同时绑定一个回调函数fn, 监听Key后的逻辑写在fn这个回调函数里面</span><br><span class="hljs-comment">// 如果想监听多个key，可以这么写：client.Watch(fn, &quot;key1&quot;, &quot;key2&quot;, &quot;key3&quot;)</span><br>client.Watch(fn, <span class="hljs-string">&quot;key&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习笔记</title>
    <link href="/2022/07/09/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/09/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL学习笔记"><a href="#MySQL学习笔记" class="headerlink" title="MySQL学习笔记"></a>MySQL学习笔记</h1><h2 id="一、登录MySQL"><a href="#一、登录MySQL" class="headerlink" title="一、登录MySQL"></a>一、登录MySQL</h2><p>当 MySQL 服务已经运行时, 我们可以通过 MySQL 自带的客户端工具登录到 MySQL 数据库中, 首先打开命令提示符, 输入以下格式的命名:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql -h 主机名 -u 用户名 -<span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><strong>-h</strong> : 指定客户端所要登录的 MySQL 主机名, 登录本机(localhost 或 127.0.0.1)该参数可以省略;</li><li><strong>-u</strong> : 登录的用户名;</li><li><strong>-p</strong> : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。</li></ul><p>如果我们要登录本机的 MySQL 数据库，只需要输入以下命令即可：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql -u root -<span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure><p>按回车确认, 如果安装正确且 MySQL 正在运行, 会得到以下响应:</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Enter</span> <span class="hljs-variable">password</span><span class="hljs-operator">:</span><br></code></pre></td></tr></table></figure><p>若密码存在, 输入密码登录, 不存在则直接按回车登录。登录成功后你将会看到 Welcome to the MySQL monitor… 的提示语。</p><p>然后命令提示符会一直以 <strong>mysq&gt;</strong> 加一个闪烁的光标等待命令的输入, 输入 <strong>exit</strong> 或 <strong>quit</strong> 退出登录。</p><h2 id="二、MySQL管理"><a href="#二、MySQL管理" class="headerlink" title="二、MySQL管理"></a>二、MySQL管理</h2><h3 id="启动及关闭MySQL服务器"><a href="#启动及关闭MySQL服务器" class="headerlink" title="启动及关闭MySQL服务器"></a>启动及关闭MySQL服务器</h3><h4 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h4><p>首先我们通过命令检查MySQL服务器是否启动</p><p><code>ps -ef | grep mysqld</code></p><p>如果MySql已经启动，以上命令将输出mysql进程列表， 如果mysql未启动，你可以使用以下命令来启动mysql服务器:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">root@host# </span><span class="language-bash"><span class="hljs-built_in">cd</span> /usr/bin</span><br>./mysqld_safe &amp;<br></code></pre></td></tr></table></figure><p>如果你想关闭目前运行的 MySQL 服务器, 你可以执行以下命令:</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit">root<span class="hljs-symbol">@host</span><span class="hljs-meta"># cd /usr/bin</span><br>./mysqladmin -u root -p <span class="hljs-built_in">shutdown</span><br>Enter password: ******<br></code></pre></td></tr></table></figure><h3 id="MySQL-用户设置"><a href="#MySQL-用户设置" class="headerlink" title="MySQL 用户设置"></a>MySQL 用户设置</h3><p>如果你需要添加 MySQL 用户，你只需要在 mysql 数据库中的 user 表添加新用户即可。</p><p>以下为添加用户的的实例，用户名为guest，密码为guest123，并授权用户可进行 SELECT, INSERT 和 UPDATE操作权限：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">root@host# mysql -u root -p<br>Enter <span class="hljs-keyword">password</span>:*******<br>mysql&gt; use mysql;<br><span class="hljs-keyword">Database</span> changed<br><br>mysql&gt; <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> <br>          (host, <span class="hljs-keyword">user</span>, <span class="hljs-keyword">password</span>, <br>           select_priv, insert_priv, update_priv) <br>           <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-string">&#x27;guest&#x27;</span>, <br>           <span class="hljs-keyword">PASSWORD</span>(<span class="hljs-string">&#x27;guest123&#x27;</span>), <span class="hljs-string">&#x27;Y&#x27;</span>, <span class="hljs-string">&#x27;Y&#x27;</span>, <span class="hljs-string">&#x27;Y&#x27;</span>);<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-keyword">row</span> affected (<span class="hljs-number">0.20</span> sec)<br><br>mysql&gt; FLUSH <span class="hljs-keyword">PRIVILEGES</span>;<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-keyword">row</span> affected (<span class="hljs-number">0.01</span> sec)<br><br>mysql&gt; <span class="hljs-keyword">SELECT</span> host, <span class="hljs-keyword">user</span>, <span class="hljs-keyword">password</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">user</span> = <span class="hljs-string">&#x27;guest&#x27;</span>;<br>+<span class="hljs-comment">-----------+---------+------------------+</span><br>| host      | <span class="hljs-keyword">user</span>    | <span class="hljs-keyword">password</span>         |<br>+<span class="hljs-comment">-----------+---------+------------------+</span><br>| localhost | guest | <span class="hljs-number">6</span>f8c114b58f2ce9e |<br>+<span class="hljs-comment">-----------+---------+------------------+</span><br><span class="hljs-number">1</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>在添加用户时，请注意使用MySQL提供的 PASSWORD() 函数来对密码进行加密。 你可以在以上实例看到用户密码加密后为： 6f8c114b58f2ce9e.</p><p><strong>注意：</strong>在 MySQL5.7 中 user 表的 password 已换成了<strong>authentication_string</strong>。</p><p><strong>注意：</strong>password() 加密函数已经在 8.0.11 中移除了，可以使用 MD5() 函数代替。</p><p><strong>注意：</strong>在注意需要执行 <strong>FLUSH PRIVILEGES</strong> 语句。 这个命令执行后会重新载入授权表。</p><p>如果你不使用该命令，你就无法使用新创建的用户来连接mysql服务器，除非你重启mysql服务器。</p><p>你可以在创建用户时，为用户指定权限，在对应的权限列中，在插入语句中设置为 ‘Y’ 即可，用户权限列表如下：</p><ul><li>Select_priv</li><li>Insert_priv</li><li>Update_priv</li><li>Delete_priv</li><li>Create_priv</li><li>Drop_priv</li><li>Reload_priv</li><li>Shutdown_priv</li><li>Process_priv</li><li>File_priv</li><li>Grant_priv</li><li>References_priv</li><li>Index_priv</li><li>Alter_priv</li></ul><p>另外一种添加用户的方法为通过SQL的 GRANT 命令，以下命令会给指定数据库TUTORIALS添加用户 zara ，密码为 zara123 。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">root@host# mysql -u root -p<br>Enter <span class="hljs-keyword">password</span>:*******<br>mysql&gt; use mysql;<br><span class="hljs-keyword">Database</span> changed<br><br>mysql&gt; <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>,<span class="hljs-keyword">INSERT</span>,<span class="hljs-keyword">UPDATE</span>,<span class="hljs-keyword">DELETE</span>,<span class="hljs-keyword">CREATE</span>,<span class="hljs-keyword">DROP</span><br>    -&gt; <span class="hljs-keyword">ON</span> TUTORIALS.*<br>    -&gt; <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;zara&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span><br>    -&gt; IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;zara123&#x27;</span>;<br></code></pre></td></tr></table></figure><p>以上命令会在mysql数据库中的user表创建一条用户信息记录。</p><p><strong>注意:</strong> MySQL 的SQL语句以分号 (;) 作为结束标识。</p><h3 id="etc-my-cnf-文件配置"><a href="#etc-my-cnf-文件配置" class="headerlink" title="/etc/my.cnf 文件配置"></a>/etc/my.cnf 文件配置</h3><p>一般情况下，你不需要修改该配置文件，该文件默认配置如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[mysqld]<br>datadir=<span class="hljs-regexp">/var/</span>lib/mysql<br>socket=<span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/mysql/my</span>sql.sock<br><br>[mysql.server]<br>user=mysql<br>basedir=<span class="hljs-regexp">/var/</span>lib<br><br>[safe_mysqld]<br>err-log=<span class="hljs-regexp">/var/</span>log/mysqld.log<br>pid-<span class="hljs-keyword">file</span>=<span class="hljs-regexp">/var/</span>run<span class="hljs-regexp">/mysqld/my</span>sqld.pid<br></code></pre></td></tr></table></figure><p>在配置文件中，你可以指定不同的错误日志文件存放的目录，一般你不需要改动这些配置。</p><hr><h3 id="管理MySQL的命令"><a href="#管理MySQL的命令" class="headerlink" title="管理MySQL的命令"></a>管理MySQL的命令</h3><p>以下列出了使用Mysql数据库过程中常用的命令：</p><ul><li><p><strong>USE *数据库名*</strong> :<br>选择要操作的Mysql数据库，使用该命令后所有Mysql命令都只针对该数据库。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">mysql&gt; use RUNOOB<span class="hljs-comment">;</span><br>Database changed<br></code></pre></td></tr></table></figure></li><li><p><strong>SHOW DATABASES:</strong><br>列出 MySQL 数据库管理系统的数据库列表。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SHOW DATABASES;</span><br><span class="hljs-section">+--------------------+</span><br><span class="hljs-section">| Database           |</span><br><span class="hljs-section">+--------------------+</span><br>| information<span class="hljs-emphasis">_schema |</span><br><span class="hljs-emphasis">| RUNOOB             |</span><br><span class="hljs-emphasis">| cdcol              |</span><br><span class="hljs-emphasis">| mysql              |</span><br><span class="hljs-emphasis">| onethink           |</span><br><span class="hljs-emphasis">| performance_</span>schema |<br>| phpmyadmin         |<br>| test               |<br>| wecenter           |<br><span class="hljs-section">| wordpress          |</span><br><span class="hljs-section">+--------------------+</span><br>10 rows in set (0.02 sec)<br></code></pre></td></tr></table></figure></li><li><p><strong>SHOW TABLES:</strong><br>显示指定数据库的所有表，使用该命令前需要使用 use 命令来选择要操作的数据库。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">mysql&gt; use RUNOOB;<br>Database changed<br><span class="hljs-section">mysql&gt; SHOW TABLES;</span><br><span class="hljs-section">+------------------+</span><br><span class="hljs-section">| Tables_in_runoob |</span><br><span class="hljs-section">+------------------+</span><br>| employee<span class="hljs-emphasis">_tbl     |</span><br><span class="hljs-emphasis">| runoob_tbl       |</span><br><span class="hljs-emphasis">| tcount_</span>tbl       |<br><span class="hljs-code">+------------------+</span><br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure></li><li><p><strong>SHOW COLUMNS FROM *数据表*:</strong><br>显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">mysql&gt; SHOW COLUMNS FROM runoob_tbl;<br>+-----------------+--------------+------+-----+---------+-------+<br>|<span class="hljs-string"> Field           </span>|<span class="hljs-string"> Type         </span>|<span class="hljs-string"> Null </span>|<span class="hljs-string"> Key </span>|<span class="hljs-string"> Default </span>|<span class="hljs-string"> Extra </span>|<br>+-----------------+--------------+------+-----+---------+-------+<br>|<span class="hljs-string"> runoob_id       </span>|<span class="hljs-string"> int(11)      </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string"> PRI </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string">       </span>|<br>|<span class="hljs-string"> runoob_title    </span>|<span class="hljs-string"> varchar(255) </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string">       </span>|<br>|<span class="hljs-string"> runoob_author   </span>|<span class="hljs-string"> varchar(255) </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string">       </span>|<br>|<span class="hljs-string"> submission_date </span>|<span class="hljs-string"> date         </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string">       </span>|<br>+-----------------+--------------+------+-----+---------+-------+<br>4 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure></li><li><p><strong>SHOW INDEX FROM *数据表*:</strong><br>显示数据表的详细索引信息，包括PRIMARY KEY（主键）。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">mysql&gt; SHOW INDEX FROM runoob_tbl;<br>+<span class="hljs-params">------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">--------------</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">-----------</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">--------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">---------------</span>+<br>| Table      | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |<br>+<span class="hljs-params">------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">--------------</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">-----------</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">--------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">---------------</span>+<br>| runoob_tbl |          0 | PRIMARY  |            1 | runoob_id   | A         |           2 |     NULL | NULL   |      | BTREE      |         |               |<br>+<span class="hljs-params">------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">--------------</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">-----------</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">--------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">---------------</span>+<br>1 row in <span class="hljs-keyword">set</span> <span class="hljs-params">(0.00 sec)</span><br></code></pre></td></tr></table></figure></li><li><p><strong>SHOW TABLE STATUS [FROM db_name] [LIKE ‘pattern’] \G:</strong><br>该命令将输出Mysql数据库管理系统的性能及统计信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">TABLE</span> STATUS  <span class="hljs-keyword">FROM</span> RUNOOB;   # 显示数据库 RUNOOB 中所有表的信息<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">TABLE</span> STATUS <span class="hljs-keyword">from</span> RUNOOB <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;runoob%&#x27;</span>;     # 表名以runoob开头的表的信息<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">TABLE</span> STATUS <span class="hljs-keyword">from</span> RUNOOB <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;runoob%&#x27;</span>\G;   # 加上 \G，查询结果按列打印<br></code></pre></td></tr></table></figure></li></ul><p>Gif 图演示：</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/03/mysql-admin.gif" alt="img"></p><h2 id="三、MySQL-PHP语法"><a href="#三、MySQL-PHP语法" class="headerlink" title="三、MySQL PHP语法"></a>三、MySQL PHP语法</h2><p>MySQL 可应用于多种语言，包括 PERL, C, C++, JAVA 和 PHP，在这些语言中，MySQL 在 PHP 的 web 开发中是应用最广泛。</p><p>在本教程中我们大部分实例都采用了 PHP 语言。如果你想了解 MySQL 在 PHP 中的应用，可以访问我们的 <a href="https://www.runoob.com/php/php-mysql-intro.html">PHP 中使用 Mysqli 介绍</a>。</p><p>PHP 提供了多种方式来访问和操作Mysql数据库记录。PHP MySQL 函数格式如下：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">mysqli_function</span>(<span class="hljs-params">value,value,...</span>)</span>;<br></code></pre></td></tr></table></figure><p>以上格式中 function部分描述了mysql函数的功能，如</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">mysqli_connect</span>($connect);<br><span class="hljs-built_in">mysqli_query</span>($connect,&quot;SQL 语句&quot;);<br><span class="hljs-built_in">mysqli_fetch_array</span>()<br><span class="hljs-built_in">mysqli_close</span>()<br></code></pre></td></tr></table></figure><p>以下实例展示了PHP调用mysql函数的语法：</p><h3 id="实例-MySQLi"><a href="#实例-MySQLi" class="headerlink" title="实例 (MySQLi)"></a>实例 (MySQLi)</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$retval</span> = <span class="hljs-title function_ invoke__">mysqli_function</span>(value, [value,...]);<br><span class="hljs-keyword">if</span>( !<span class="hljs-variable">$retval</span> )<br>&#123;<br>   <span class="hljs-keyword">die</span> ( <span class="hljs-string">&quot;相关错误信息&quot;</span> );<br>&#125;<br><span class="hljs-comment">// 其他 MySQL 或 PHP 语句</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h2 id="四、MySQL连接"><a href="#四、MySQL连接" class="headerlink" title="四、MySQL连接"></a>四、MySQL连接</h2><h3 id="使用mysql二进制方式连接"><a href="#使用mysql二进制方式连接" class="headerlink" title="使用mysql二进制方式连接"></a>使用mysql二进制方式连接</h3><p>您可以使用MySQL二进制方式进入到mysql命令提示符下来连接MySQL数据库。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>以下是从命令行中连接mysql服务器的简单实例：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@host]</span><span class="hljs-meta"># mysql -u root -p</span><br>Enter password:******<br></code></pre></td></tr></table></figure><p>在登录成功后会出现 mysql&gt; 命令提示窗口，你可以在上面执行任何 SQL 语句。</p><p>以上命令执行后，登录成功输出结果如下:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Welcome <span class="hljs-keyword">to</span> the MySQL monitor.  Commands <span class="hljs-keyword">end</span> <span class="hljs-keyword">with</span> ; <span class="hljs-keyword">or</span> \g.<br>Your MySQL <span class="hljs-keyword">connection</span> id <span class="hljs-keyword">is</span> <span class="hljs-number">2854760</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">server</span> <span class="hljs-keyword">version</span>: <span class="hljs-number">5.0</span><span class="hljs-number">.9</span><br><br><span class="hljs-keyword">Type</span> <span class="hljs-string">&#x27;help;&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;\h&#x27;</span> <span class="hljs-keyword">for</span> help. <span class="hljs-keyword">Type</span> <span class="hljs-string">&#x27;\c&#x27;</span> <span class="hljs-keyword">to</span> clear the buffer.<br></code></pre></td></tr></table></figure><p>在以上实例中，我们使用了root用户登录到mysql服务器，当然你也可以使用其他mysql用户登录。</p><p>如果用户权限足够，任何用户都可以在mysql的命令提示窗口中进行SQL操作。</p><p>退出 mysql&gt; 命令提示窗口可以使用 exit 命令，如下所示：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">mysql&gt; <span class="hljs-keyword">exit</span><br>Bye<br></code></pre></td></tr></table></figure><hr><h3 id="使用-PHP-脚本连接-MySQL"><a href="#使用-PHP-脚本连接-MySQL" class="headerlink" title="使用 PHP 脚本连接 MySQL"></a>使用 PHP 脚本连接 MySQL</h3><p>PHP 提供了 mysqli_connect() 函数来连接数据库。</p><p>该函数有 6 个参数，在成功链接到 MySQL 后返回连接标识，失败返回 FALSE 。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">mysqli<span class="hljs-constructor">_connect(<span class="hljs-params">host</span>, <span class="hljs-params">username</span>, <span class="hljs-params">password</span>, <span class="hljs-params">dbname</span>,<span class="hljs-params">port</span>, <span class="hljs-params">socket</span>)</span>;<br></code></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><em>host</em></td><td style="text-align:left">可选。规定主机名或 IP 地址。</td></tr><tr><td style="text-align:left"><em>username</em></td><td style="text-align:left">可选。规定 MySQL 用户名。</td></tr><tr><td style="text-align:left"><em>password</em></td><td style="text-align:left">可选。规定 MySQL 密码。</td></tr><tr><td style="text-align:left"><em>dbname</em></td><td style="text-align:left">可选。规定默认使用的数据库。</td></tr><tr><td style="text-align:left"><em>port</em></td><td style="text-align:left">可选。规定尝试连接到 MySQL 服务器的端口号。</td></tr><tr><td style="text-align:left"><em>socket</em></td><td style="text-align:left">可选。规定 socket 或要使用的已命名 pipe。</td></tr></tbody></table></div><p>你可以使用 PHP 的 mysqli_close() 函数来断开与 MySQL 数据库的链接。</p><p>该函数只有一个参数为 mysqli_connect() 函数创建连接成功后返回的 MySQL 连接标识符。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">bool</span> mysqli_close ( mysqli <span class="hljs-variable">$link</span> )<br></code></pre></td></tr></table></figure><p>本函数关闭指定的连接标识所关联的到 MySQL 服务器的非持久连接。如果没有指定 link_identifier，则关闭上一个打开的连接。</p><p><strong>提示：</strong>通常不需要使用 mysqli_close()，因为已打开的非持久连接会在脚本执行完毕后自动关闭。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>你可以尝试以下实例来连接到你的 MySQL 服务器:</p><h3 id="连接-MySQL"><a href="#连接-MySQL" class="headerlink" title="连接 MySQL"></a>连接 MySQL</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-variable">$dbhost</span> = <span class="hljs-string">&#x27;localhost&#x27;</span>;  <span class="hljs-comment">// mysql服务器主机地址 </span><br><span class="hljs-variable">$dbuser</span> = <span class="hljs-string">&#x27;root&#x27;</span>;            <span class="hljs-comment">// mysql用户名 </span><br><span class="hljs-variable">$dbpass</span> = <span class="hljs-string">&#x27;123456&#x27;</span>;          <span class="hljs-comment">// mysql用户名密码 </span><br><span class="hljs-variable">$conn</span> = <span class="hljs-title function_ invoke__">mysqli_connect</span>(<span class="hljs-variable">$dbhost</span>, <span class="hljs-variable">$dbuser</span>, <span class="hljs-variable">$dbpass</span>); <br><span class="hljs-keyword">if</span>(! <span class="hljs-variable">$conn</span> ) <br>&#123;    <br><span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;Could not connect: &#x27;</span> . <span class="hljs-title function_ invoke__">mysqli_error</span>()); <br>&#125; <br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;数据库连接成功！&#x27;</span>; <br><span class="hljs-title function_ invoke__">mysqli_close</span>(<span class="hljs-variable">$conn</span>); <br><span class="hljs-meta">?&gt;</span><br><br><br><br><br></code></pre></td></tr></table></figure><h2 id="五、创建数据库"><a href="#五、创建数据库" class="headerlink" title="五、创建数据库"></a>五、创建数据库</h2><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> 数据库名;<br></code></pre></td></tr></table></figure><p>以下命令简单的演示了创建数据库的过程，数据名为 RUNOOB:</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@host]</span><span class="hljs-meta"># mysql -u root -p   </span><br>Enter password:******  <span class="hljs-meta"># 登录后进入终端</span><br><br>mysql&gt; create DATABASE RUNOOB<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="六、删除数据库"><a href="#六、删除数据库" class="headerlink" title="六、删除数据库"></a>六、删除数据库</h2><h3 id="drop-命令删除数据库"><a href="#drop-命令删除数据库" class="headerlink" title="drop 命令删除数据库"></a>drop 命令删除数据库</h3><p>drop 命令格式：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">database</span> &lt;数据库名&gt;;<br></code></pre></td></tr></table></figure><p>例如删除名为 RUNOOB 的数据库：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">mysql&gt; <span class="hljs-keyword">drop</span> <span class="hljs-keyword">database</span> RUNOOB;<br></code></pre></td></tr></table></figure><h3 id="使用-mysqladmin-删除数据库"><a href="#使用-mysqladmin-删除数据库" class="headerlink" title="使用 mysqladmin 删除数据库"></a>使用 mysqladmin 删除数据库</h3><p>你也可以使用 mysql <strong>mysqladmin</strong> 命令在终端来执行删除命令。</p><p>以下实例删除数据库 RUNOOB(该数据库在前一章节已创建)：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@host]</span><span class="hljs-meta"># mysqladmin -u root -p drop RUNOOB</span><br>Enter password:******<br></code></pre></td></tr></table></figure><p>执行以上删除数据库命令后，会出现一个提示框，来确认是否真的删除数据库：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Dropping the <span class="hljs-keyword">database</span> <span class="hljs-keyword">is</span> potentially a very bad thing <span class="hljs-keyword">to</span> <span class="hljs-keyword">do</span>.<br><span class="hljs-keyword">Any</span> data stored <span class="hljs-keyword">in</span> the <span class="hljs-keyword">database</span> will be destroyed.<br><br><span class="hljs-keyword">Do</span> you really want <span class="hljs-keyword">to</span> <span class="hljs-keyword">drop</span> the <span class="hljs-string">&#x27;RUNOOB&#x27;</span> <span class="hljs-keyword">database</span> [y/N] y<br><span class="hljs-keyword">Database</span> &quot;RUNOOB&quot; dropped<br></code></pre></td></tr></table></figure><h2 id="七、选择数据库"><a href="#七、选择数据库" class="headerlink" title="七、选择数据库"></a>七、选择数据库</h2><h3 id="从命令提示窗口中选择MySQL数据库"><a href="#从命令提示窗口中选择MySQL数据库" class="headerlink" title="从命令提示窗口中选择MySQL数据库"></a>从命令提示窗口中选择MySQL数据库</h3><p>在 mysql&gt; 提示窗口中可以很简单的选择特定的数据库。你可以使用SQL命令来选择指定的数据库。</p><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><p>以下实例选取了数据库 RUNOOB:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[root@host]</span># mysql -u root -<span class="hljs-selector-tag">p</span><br>Enter password:******<br>mysql&gt; use RUNOOB;<br>Database changed<br>mysql&gt;<br></code></pre></td></tr></table></figure><p>执行以上命令后，你就已经成功选择了 RUNOOB 数据库，在后续的操作中都会在 RUNOOB 数据库中执行。</p><h2 id="八、数据类型"><a href="#八、数据类型" class="headerlink" title="八、数据类型"></a>八、数据类型</h2><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>MySQL 支持所有标准 SQL 数值数据类型。</p><p>这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL 和 NUMERIC)，以及近似数值数据类型(FLOAT、REAL 和 DOUBLE PRECISION)。</p><p>关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。</p><p>BIT数据类型保存位字段值，并且支持 MyISAM、MEMORY、InnoDB 和 BDB表。</p><p>作为 SQL 标准的扩展，MySQL 也支持整数类型 TINYINT、MEDIUMINT 和 BIGINT。下面的表显示了需要的每个整数类型的存储和范围。</p><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">大小</th><th style="text-align:left">范围（有符号）</th><th style="text-align:left">范围（无符号）</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">TINYINT</td><td style="text-align:left">1 Bytes</td><td style="text-align:left">(-128，127)</td><td style="text-align:left">(0，255)</td><td style="text-align:left">小整数值</td></tr><tr><td style="text-align:left">SMALLINT</td><td style="text-align:left">2 Bytes</td><td style="text-align:left">(-32 768，32 767)</td><td style="text-align:left">(0，65 535)</td><td style="text-align:left">大整数值</td></tr><tr><td style="text-align:left">MEDIUMINT</td><td style="text-align:left">3 Bytes</td><td style="text-align:left">(-8 388 608，8 388 607)</td><td style="text-align:left">(0，16 777 215)</td><td style="text-align:left">大整数值</td></tr><tr><td style="text-align:left">INT或INTEGER</td><td style="text-align:left">4 Bytes</td><td style="text-align:left">(-2 147 483 648，2 147 483 647)</td><td style="text-align:left">(0，4 294 967 295)</td><td style="text-align:left">大整数值</td></tr><tr><td style="text-align:left">BIGINT</td><td style="text-align:left">8 Bytes</td><td style="text-align:left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td style="text-align:left">(0，18 446 744 073 709 551 615)</td><td style="text-align:left">极大整数值</td></tr><tr><td style="text-align:left">FLOAT</td><td style="text-align:left">4 Bytes</td><td style="text-align:left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td style="text-align:left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td style="text-align:left">单精度 浮点数值</td></tr><tr><td style="text-align:left">DOUBLE</td><td style="text-align:left">8 Bytes</td><td style="text-align:left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td style="text-align:left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td style="text-align:left">双精度 浮点数值</td></tr><tr><td style="text-align:left">DECIMAL</td><td style="text-align:left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td style="text-align:left">依赖于M和D的值</td><td style="text-align:left">依赖于M和D的值</td><td style="text-align:left">小数值</td></tr></tbody></table></div><hr><h3 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h3><p>表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。</p><p>每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。</p><p>TIMESTAMP类型有专有的自动更新特性，将在后面描述。</p><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">大小 ( bytes)</th><th style="text-align:left">范围</th><th style="text-align:left">格式</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">DATE</td><td style="text-align:left">3</td><td style="text-align:left">1000-01-01/9999-12-31</td><td style="text-align:left">YYYY-MM-DD</td><td style="text-align:left">日期值</td></tr><tr><td style="text-align:left">TIME</td><td style="text-align:left">3</td><td style="text-align:left">‘-838:59:59’/‘838:59:59’</td><td style="text-align:left">HH:MM:SS</td><td style="text-align:left">时间值或持续时间</td></tr><tr><td style="text-align:left">YEAR</td><td style="text-align:left">1</td><td style="text-align:left">1901/2155</td><td style="text-align:left">YYYY</td><td style="text-align:left">年份值</td></tr><tr><td style="text-align:left">DATETIME</td><td style="text-align:left">8</td><td style="text-align:left">1000-01-01 00:00:00/9999-12-31 23:59:59</td><td style="text-align:left">YYYY-MM-DD HH:MM:SS</td><td style="text-align:left">混合日期和时间值</td></tr><tr><td style="text-align:left">TIMESTAMP</td><td style="text-align:left">4</td><td style="text-align:left">1970-01-01 00:00:00/2038结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td style="text-align:left">YYYYMMDD HHMMSS</td><td style="text-align:left">混合日期和时间值，时间戳</td></tr></tbody></table></div><hr><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。</p><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">大小</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">CHAR</td><td style="text-align:left">0-255 bytes</td><td style="text-align:left">定长字符串</td></tr><tr><td style="text-align:left">VARCHAR</td><td style="text-align:left">0-65535 bytes</td><td style="text-align:left">变长字符串</td></tr><tr><td style="text-align:left">TINYBLOB</td><td style="text-align:left">0-255 bytes</td><td style="text-align:left">不超过 255 个字符的二进制字符串</td></tr><tr><td style="text-align:left">TINYTEXT</td><td style="text-align:left">0-255 bytes</td><td style="text-align:left">短文本字符串</td></tr><tr><td style="text-align:left">BLOB</td><td style="text-align:left">0-65 535 bytes</td><td style="text-align:left">二进制形式的长文本数据</td></tr><tr><td style="text-align:left">TEXT</td><td style="text-align:left">0-65 535 bytes</td><td style="text-align:left">长文本数据</td></tr><tr><td style="text-align:left">MEDIUMBLOB</td><td style="text-align:left">0-16 777 215 bytes</td><td style="text-align:left">二进制形式的中等长度文本数据</td></tr><tr><td style="text-align:left">MEDIUMTEXT</td><td style="text-align:left">0-16 777 215 bytes</td><td style="text-align:left">中等长度文本数据</td></tr><tr><td style="text-align:left">LONGBLOB</td><td style="text-align:left">0-4 294 967 295 bytes</td><td style="text-align:left">二进制形式的极大文本数据</td></tr><tr><td style="text-align:left">LONGTEXT</td><td style="text-align:left">0-4 294 967 295 bytes</td><td style="text-align:left">极大文本数据</td></tr></tbody></table></div><p><strong>注意</strong>：char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。</p><p>CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p><p>BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。</p><p>BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。</p><p>有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。</p><h2 id="九、创建数据表"><a href="#九、创建数据表" class="headerlink" title="九、创建数据表"></a>九、创建数据表</h2><p>创建MySQL数据表需要以下信息：</p><ul><li>表名</li><li>表字段名</li><li>定义每个表字段</li></ul><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p>以下为创建MySQL数据表的SQL通用语法：</p><p><code>CREATE TABLE table_name(column_name column_type):</code></p><p>以下例子中我们将在RUNOOB数据库中创建数据表runoob_tbl:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE IF NOT EXISTS `runoob_tbl`(<br>   `runoob_id` INT UNSIGNED AUTO_INCREMENT,<br>   `runoob_title` VARCHAR(100) NOT NULL,<br>   `runoob_author` VARCHAR(40) NOT NULL,<br>   `submission_date` DATE,<br>   PRIMARY KEY ( `runoob_id` )<br>)ENGINE=InnoDB DEFAULT CHARSET=utf8;<br></code></pre></td></tr></table></figure><p>实例解析：</p><ul><li>如果你不想字段为NULL可以设置字段的属性为NOT NULL，在操作数据库时如果输入该字段的数据为NULL，就会报错；</li><li>AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动+1；</li><li>PRIMARY KEY关键字用于定义为主键。您可以使用多列来定义主键，列间以逗号分隔。</li><li>ENGINE设置存储引擎，CHARSET设置编码。</li></ul><h3 id="通过命令提示符创建表"><a href="#通过命令提示符创建表" class="headerlink" title="通过命令提示符创建表"></a>通过命令提示符创建表</h3><p>通过 mysql&gt; 命令窗口可以很简单的创建MySQL数据表。你可以使用 SQL 语句 <strong>CREATE TABLE</strong> 来创建数据表。</p><h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><p>以下为创建数据表 runoob_tbl 实例:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">root@host# mysql -u root -p<br>Enter <span class="hljs-keyword">password</span>:*******<br>mysql&gt; use RUNOOB;<br><span class="hljs-keyword">Database</span> changed<br>mysql&gt; <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> runoob_tbl(<br>   -&gt; runoob_id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>   -&gt; runoob_title <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   -&gt; runoob_author <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">40</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   -&gt; submission_date <span class="hljs-type">DATE</span>,<br>   -&gt; <span class="hljs-keyword">PRIMARY KEY</span> ( runoob_id )<br>   -&gt; )ENGINE=InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.16</span> sec)<br>mysql&gt;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>MySQL命令终止符为分号 <strong>;</strong> 。</p><p><strong>注意：</strong> <strong>-&gt;</strong> 是换行符标识，不要复制</p><h2 id="十、删除数据表"><a href="#十、删除数据表" class="headerlink" title="十、删除数据表"></a>十、删除数据表</h2><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><p>以下为删除MySQL数据表的通用语法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-built_in">table_name</span> ;<br></code></pre></td></tr></table></figure><h2 id="在命令提示窗口中删除数据表"><a href="#在命令提示窗口中删除数据表" class="headerlink" title="在命令提示窗口中删除数据表"></a>在命令提示窗口中删除数据表</h2><p>在mysql&gt;命令提示窗口中删除数据表SQL语句为 <strong>DROP TABLE</strong> ：</p><h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><p>以下实例删除了数据表runoob_tbl:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">root@host# mysql -u root -p<br>Enter password:*******<br>mysql&gt; use RUNOOB;<br>Database changed<br>mysql&gt; DROP TABLE runoob_tbl;<br>Query OK, 0 rows affected (0.8 sec)<br>mysql&gt;<br></code></pre></td></tr></table></figure><h2 id="十一、插入数据"><a href="#十一、插入数据" class="headerlink" title="十一、插入数据"></a>十一、插入数据</h2><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><p>以下为向MySQL数据表插入数据通用的 <strong>INSERT INTO</strong> SQL语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INFO table_name (field1,field2,...fieldN)<br>VALUES<br>(value1, value2,...valueN);<br></code></pre></td></tr></table></figure><h3 id="通过命令提示窗口插入数据"><a href="#通过命令提示窗口插入数据" class="headerlink" title="通过命令提示窗口插入数据"></a>通过命令提示窗口插入数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mysql">root@host# mysql -u root -p password;<br>Enter password:*******<br>mysql&gt; use RUNOOB;<br>Database changed<br>mysql&gt; Query OK, 1 rows affected, 1 warnings (0.01 sec)<br>mysql&gt; INSERT INTO runoob_tbl<br>    -&gt; (runoob_title, runoob_author, submission_date)<br>    -&gt; VALUES<br>    -&gt; (&quot;学习 PHP&quot;, &quot;菜鸟教程&quot;, NOW());<br>Query OK, 1 rows affected, 1 warnings (0.01 sec)<br>mysql&gt; INSERT INTO runoob_tbl<br>    -&gt; (runoob_title, runoob_author, submission_date)<br>    -&gt; VALUES<br>    -&gt; (&quot;学习 MySQL&quot;, &quot;菜鸟教程&quot;, NOW());<br>Query OK, 1 rows affected, 1 warnings (0.01 sec)<br>mysql&gt; INSERT INTO runoob_tbl<br>    -&gt; (runoob_title, runoob_author, submission_date)<br>    -&gt; VALUES<br>    -&gt; (&quot;JAVA 教程&quot;, &quot;RUNOOB.COM&quot;, &#x27;2016-05-06&#x27;);<br>Query OK, 1 rows affected (0.00 sec)<br>mysql&gt;<br></code></pre></td></tr></table></figure><h2 id="十二、查询数据"><a href="#十二、查询数据" class="headerlink" title="十二、查询数据"></a>十二、查询数据</h2><p>MySQL 数据库使用SQL SELECT语句来查询数据。</p><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><p>以下为在MySQL数据库中查询数据通用的 SELECT 语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column_name,column_name<br>FROM table_name<br>[WHERE Clause]<br>[LIMIT N][ OFFSET M]<br></code></pre></td></tr></table></figure><ul><li><p>查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。</p></li><li><p>SELECT 命令可以读取一条或者多条记录。</p></li><li><p>你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据</p></li><li><p>你可以使用 WHERE 语句来包含任何条件。</p></li><li><p>你可以使用 LIMIT 属性来设定返回的记录数。</p></li><li><p>你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。通过命令提示符获取数据</p><p>以下实例我们将通过 SQL SELECT 命令来获取 MySQL 数据表 runoob_tbl 的数据：</p><h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><p>以下实例将返回数据表 runoob_tbl 的所有记录:</p><h3 id="读取数据表："><a href="#读取数据表：" class="headerlink" title="读取数据表："></a>读取数据表：</h3><p><code>select * from runoob_tbl;</code></p><p>输出结果：</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/03/DB742246-84F3-4447-BD43-6BAEADD7CA91.jpg" alt="img"></p></li></ul><h2 id="十三、MySQL-WHERE字句"><a href="#十三、MySQL-WHERE字句" class="headerlink" title="十三、MySQL WHERE字句"></a>十三、MySQL WHERE字句</h2><p>我们知道从 MySQL 表中使用 SQL SELECT 语句来读取数据。</p><p>如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句中。</p><h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><p>以下是 SQL SELECT 语句使用 WHERE 子句从数据表中读取数据的通用语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT field1, field2,...fieldN FROM table_name1, table_name2...<br>[WHERE condition1 [AND [OR]] condition2.....<br></code></pre></td></tr></table></figure><ul><li>查询语句中你可以使用一个或者多个表，表之间使用逗号<strong>,</strong> 分割，并使用WHERE语句来设定查询条件。</li><li>你可以在 WHERE 子句中指定任何条件。</li><li>你可以使用 AND 或者 OR 指定一个或多个条件。</li><li>WHERE 子句也可以运用于 SQL 的 DELETE 或者 UPDATE 命令。</li><li>WHERE 子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。</li></ul><p>以下为操作符列表，可用于 WHERE 子句中。</p><p>下表中实例假定 A 为 10, B 为 20</p><div class="table-container"><table><thead><tr><th style="text-align:left">操作符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">=</td><td style="text-align:left">等号，检测两个值是否相等，如果相等返回true</td><td style="text-align:left">(A = B) 返回false。</td></tr><tr><td style="text-align:left">&lt;&gt;, !=</td><td style="text-align:left">不等于，检测两个值是否相等，如果不相等返回true</td><td style="text-align:left">(A != B) 返回 true。</td></tr><tr><td style="text-align:left">&gt;</td><td style="text-align:left">大于号，检测左边的值是否大于右边的值, 如果左边的值大于右边的值返回true</td><td style="text-align:left">(A &gt; B) 返回false。</td></tr><tr><td style="text-align:left">&lt;</td><td style="text-align:left">小于号，检测左边的值是否小于右边的值, 如果左边的值小于右边的值返回true</td><td style="text-align:left">(A &lt; B) 返回 true。</td></tr><tr><td style="text-align:left">&gt;=</td><td style="text-align:left">大于等于号，检测左边的值是否大于或等于右边的值, 如果左边的值大于或等于右边的值返回true</td><td style="text-align:left">(A &gt;= B) 返回false。</td></tr><tr><td style="text-align:left">&lt;=</td><td style="text-align:left">小于等于号，检测左边的值是否小于或等于右边的值, 如果左边的值小于或等于右边的值返回true</td><td style="text-align:left">(A &lt;= B) 返回 true。</td></tr></tbody></table></div><p>如果我们想在 MySQL 数据表中读取指定的数据，WHERE 子句是非常有用的。</p><p>使用主键来作为 WHERE 子句的条件查询是非常快速的。</p><p>如果给定的条件在表中没有任何匹配的记录，那么查询不会返回任何数据。</p><h3 id="从命令提示符中读取数据"><a href="#从命令提示符中读取数据" class="headerlink" title="从命令提示符中读取数据"></a>从命令提示符中读取数据</h3><p>我们将在SQL SELECT语句使用WHERE子句来读取MySQL数据表 runoob_tbl 中的数据：</p><p>实例</p><p>以下实例将读取 runoob_tbl 表中 runoob_author 字段值为 Sanjay 的所有记录：</p><h3 id="SQL-SELECT-WHERE-子句"><a href="#SQL-SELECT-WHERE-子句" class="headerlink" title="SQL SELECT WHERE 子句"></a>SQL SELECT WHERE 子句</h3><p>SELECT * from runoob_tbl WHERE runoob_author=’菜鸟教程’;</p><p>输出结果：</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/03/CED9CA9C-E4C7-4809-875C-A7E48F430059.jpg" alt="img"></p><p>MySQL 的 WHERE 子句的字符串比较是不区分大小写的。 你可以使用 BINARY 关键字来设定 WHERE 子句的字符串比较是区分大小写的。</p><p>如下实例:</p><h3 id="BINARY-关键字"><a href="#BINARY-关键字" class="headerlink" title="BINARY 关键字"></a>BINARY 关键字</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * from runoob_tbl WHERE BINARY runoob_author=&#x27;runoob.com&#x27;;<br>Empty set (0.01 sec)<br> <br>mysql&gt; SELECT * from runoob_tbl WHERE BINARY runoob_author=&#x27;RUNOOB.COM&#x27;;<br>+-----------+---------------+---------------+-----------------+<br>| runoob_id | runoob_title  | runoob_author | submission_date |<br>+-----------+---------------+---------------+-----------------+<br>| 3         | JAVA 教程   | RUNOOB.COM    | 2016-05-06      |<br>| 4         | 学习 Python | RUNOOB.COM    | 2016-03-06      |<br>+-----------+---------------+---------------+-----------------+<br>2 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure><p>实例中使用了 <strong>BINARY</strong> 关键字，是区分大小写的，所以 <strong>runoob_author=’runoob.com’</strong> 的查询条件是没有数据的。</p><h2 id="十四、MySQL-UPDATE更新"><a href="#十四、MySQL-UPDATE更新" class="headerlink" title="十四、MySQL UPDATE更新"></a>十四、MySQL UPDATE更新</h2><p>如果我们需要修改或更新 MySQL 中的数据，我们可以使用 SQL UPDATE 命令来操作。</p><h3 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h3><p>以下是UPDATE命令修改MySQL数据表数据通用的SQL语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE table_name SET field1=new-value1, field2=new-value2<br>[WHERE Clause]<br></code></pre></td></tr></table></figure><ul><li>你可以同时更新一个或多个字段。</li><li>你可以在 WHERE 子句中指定任何条件。</li><li>你可以在一个单独表中同时更新数据。</li></ul><p>当你需要更新数据表中指定行的数据时 WHERE 子句是非常有用的。</p><p>通过命令提示符更新数据</p><p>以下我们将在 SQL UPDATE 命令使用 WHERE 子句来更新 runoob_tbl 表中指定的数据：</p><h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><p>以下实例将更新数据表中 runoob_id 为 3 的 runoob_title 字段值：</p><h3 id="SQL-UPDATE-语句："><a href="#SQL-UPDATE-语句：" class="headerlink" title="SQL UPDATE 语句："></a>SQL UPDATE 语句：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; UPDATE runoob_tbl SET runoob_title=&#x27;学习 C++&#x27; WHERE runoob_id=3;<br>Query OK, 1 rows affected (0.01 sec)<br> <br>mysql&gt; SELECT * from runoob_tbl WHERE runoob_id=3;<br>+-----------+--------------+---------------+-----------------+<br>| runoob_id | runoob_title | runoob_author | submission_date |<br>+-----------+--------------+---------------+-----------------+<br>| 3         | 学习 C++   | RUNOOB.COM    | 2016-05-06      |<br>+-----------+--------------+---------------+-----------------+<br>1 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure><p>从结果上看，runoob_id 为 3 的 runoob_title 已被修改</p><h2 id="十五、DELETE语句"><a href="#十五、DELETE语句" class="headerlink" title="十五、DELETE语句"></a>十五、DELETE语句</h2><p>你可以使用 SQL 的 DELETE FROM 命令来删除 MySQL 数据表中的记录。</p><p>你可以在 <strong>mysql&gt;</strong> 命令提示符或 PHP 脚本中执行该命令。</p><h3 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h3><p>以下是SQL DELETE语句从MySQL数据表中删除数据的通用语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM table_name [WHERE Clause]<br></code></pre></td></tr></table></figure><ul><li>如果没有指定 WHERE 子句，MySQL 表中的所有记录将被删除。</li><li>你可以在 WHERE 子句中指定任何条件</li><li>您可以在单个表中一次性删除记录。</li></ul><p>当你想删除数据表中指定的记录时 WHERE 子句是非常有用的。</p><h3 id="从命令行中删除数据"><a href="#从命令行中删除数据" class="headerlink" title="从命令行中删除数据"></a>从命令行中删除数据</h3><p>这里我们将在 SQL DELETE 命令中使用 WHERE 子句来删除 MySQL 数据表 runoob_tbl 所选的数据。</p><h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><p>以下实例将删除 runoob_tbl 表中 runoob_id 为3 的记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; use RUNOOB;<br>Database changed<br>mysql&gt; DELETE FROM runoob_tbl WHERE runoob_id=3;<br>Query OK, 1 row affected (0.23 sec)<br><br></code></pre></td></tr></table></figure><h2 id="十六、LIKE字句"><a href="#十六、LIKE字句" class="headerlink" title="十六、LIKE字句"></a>十六、LIKE字句</h2><p>我们知道在 MySQL 中使用 SQL SELECT 命令来读取数据， 同时我们可以在 SELECT 语句中使用 WHERE 子句来获取指定的记录。</p><p>WHERE 子句中可以使用等号 <strong>=</strong> 来设定获取数据的条件，如 “runoob_author = ‘RUNOOB.COM’”。</p><p>但是有时候我们需要获取 runoob_author 字段含有==”COM”== 字符的所有记录，这时我们就需要在 WHERE 子句中使用 SQL LIKE 子句。</p><p>SQL LIKE 子句中使用百分号 <strong>%</strong>字符来表示任意字符，类似于UNIX或正则表达式中的星号 <strong>*</strong>。</p><p>如果没有使用百分号 <strong>%</strong>, LIKE 子句与等号 <strong>=</strong> 的效果是一样的。</p><h3 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h3><p>以下是 SQL SELECT 语句使用 LIKE 子句从数据表中读取数据的通用语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT field1, field2,...fieldN <br>FROM table_name<br>WHERE field1 LIKE condition1 [AND [OR]] filed2 = &#x27;somevalue&#x27;<br></code></pre></td></tr></table></figure><ul><li><p>你可以在 WHERE 子句中指定任何条件。</p></li><li><p>你可以在 WHERE 子句中使用LIKE子句。</p></li><li><p>你可以使用==LIKE子句代替等号 <strong>=</strong>。==</p></li><li><p>LIKE 通常与 <strong>%</strong> 一同使用，类似于一个元字符的搜索。</p></li><li><p>你可以使用 AND 或者 OR 指定一个或多个条件。</p></li><li><p>你可以在 DELETE 或 UPDATE 命令中使用 WHERE…LIKE 子句来指定条件。</p><h3 id="在命令提示符中使用-LIKE-子句"><a href="#在命令提示符中使用-LIKE-子句" class="headerlink" title="在命令提示符中使用 LIKE 子句"></a>在命令提示符中使用 LIKE 子句</h3><p>以下我们将在 SQL SELECT 命令中使用 WHERE…LIKE 子句来从MySQL数据表 runoob_tbl 中读取数据。</p><p>实例</p><p>以下是我们将 runoob_tbl 表中获取 runoob_author 字段中以 <strong>COM</strong> 为结尾的的所有记录：</p><h3 id="SQL-LIKE-语句："><a href="#SQL-LIKE-语句：" class="headerlink" title="SQL LIKE 语句："></a>SQL LIKE 语句：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; use RUNOOB;<br>Database changed<br>mysql&gt; SELECT * from runoob_tbl  WHERE runoob_author LIKE &#x27;%COM&#x27;;<br>+-----------+---------------+---------------+-----------------+<br>| runoob_id | runoob_title  | runoob_author | submission_date |<br>+-----------+---------------+---------------+-----------------+<br>| 3         | 学习 Java   | RUNOOB.COM    | 2015-05-01      |<br>| 4         | 学习 Python | RUNOOB.COM    | 2016-03-06      |<br>+-----------+---------------+---------------+-----------------+<br>2 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure></li></ul><h2 id="十七、UNION操作符"><a href="#十七、UNION操作符" class="headerlink" title="十七、UNION操作符"></a>十七、UNION操作符</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>MySQL UNION 操作符用于连接==两个以上的 SELECT 语句==的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。</p><h3 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h3><p>MySQL UNION 操作符语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT expression1, expression2, ... expression_n<br>FROM tables<br>[WHERE conditions]<br>UNION [ALL | DISTINCT]<br>SELECT expression1, expression2, ... expression_n<br>FROM tables<br>[WHERE conditions];<br></code></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><strong>expression1, expression2, … expression_n</strong>: 要检索的列。</li><li><strong>tables:</strong> 要检索的数据表。</li><li><strong>WHERE conditions:</strong> 可选， 检索条件。</li><li><strong>DISTINCT:</strong> 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。</li><li><strong>ALL:</strong> 可选，返回所有结果集，包含重复数据。</li></ul><h3 id="演示数据库"><a href="#演示数据库" class="headerlink" title="演示数据库"></a>演示数据库</h3><p>在本教程中，我们将使用 RUNOOB 样本数据库。</p><p>下面是选自 “Websites” 表的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM Websites;<br>+----+--------------+---------------------------+-------+---------+<br>| id | name         | url                       | alexa | country |<br>+----+--------------+---------------------------+-------+---------+<br>| 1  | Google       | https://www.google.cm/    | 1     | USA     |<br>| 2  | 淘宝          | https://www.taobao.com/   | 13    | CN      |<br>| 3  | 菜鸟教程      | http://www.runoob.com/    | 4689  | CN      |<br>| 4  | 微博          | http://weibo.com/         | 20    | CN      |<br>| 5  | Facebook     | https://www.facebook.com/ | 3     | USA     |<br>| 7  | stackoverflow | http://stackoverflow.com/ |   0 | IND     |<br>+----+---------------+---------------------------+-------+---------+<br></code></pre></td></tr></table></figure><p>下面是 “apps” APP 的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM apps;<br>+----+------------+-------------------------+---------+<br>| id | app_name   | url                     | country |<br>+----+------------+-------------------------+---------+<br>|  1 | QQ APP     | http://im.qq.com/       | CN      |<br>|  2 | 微博 APP | http://weibo.com/       | CN      |<br>|  3 | 淘宝 APP | https://www.taobao.com/ | CN      |<br>+----+------------+-------------------------+---------+<br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="SQL-UNION-实例"><a href="#SQL-UNION-实例" class="headerlink" title="SQL UNION 实例"></a>SQL UNION 实例</h3><p>下面的 SQL 语句从 “Websites” 和 “apps” 表中选取所有<strong>不同的</strong>country（只有不同的值）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT country FROM Websites<br>UNION<br>SELECT country FROM apps<br>ORDER BY country;<br></code></pre></td></tr></table></figure><p>执行以上 SQL 输出结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2013/09/union1.jpg" alt="img"></p><p><strong>注释：</strong>UNION 不能用于列出两个表中所有的country。如果一些网站和APP来自同一个国家，每个国家只会列出一次。UNION 只会选取不同的值。请使用 UNION ALL 来选取重复的值！</p><h3 id="SQL-UNION-ALL-实例"><a href="#SQL-UNION-ALL-实例" class="headerlink" title="SQL UNION ALL 实例"></a>SQL UNION ALL 实例</h3><p>下面的 SQL 语句使用 UNION ALL 从 “Websites” 和 “apps” 表中选取<strong>所有的</strong>country（也有重复的值）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT country FROM Websites<br>UNION ALL<br>SELECT country FROM apps<br>ORDER BY country;<br></code></pre></td></tr></table></figure><p>执行以上 SQL 输出结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2013/09/union2.jpg" alt="img"></p><h3 id="带有-WHERE-的-SQL-UNION-ALL"><a href="#带有-WHERE-的-SQL-UNION-ALL" class="headerlink" title="带有 WHERE 的 SQL UNION ALL"></a>带有 WHERE 的 SQL UNION ALL</h3><p>下面的 SQL 语句使用 UNION ALL 从 “Websites” 和 “apps” 表中选取<strong>所有的</strong>中国(CN)的数据（也有重复的值）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT country, name FROM Websites<br>WHERE country=&#x27;CN&#x27;<br>UNION ALL<br>SELECT country, app_name FROM apps<br>WHERE country=&#x27;CN&#x27;<br>ORDER BY country;<br></code></pre></td></tr></table></figure><p>执行以上 SQL 输出结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2013/09/AAA99C7B-36A5-43FB-B489-F8CE63B62C71.jpg" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
