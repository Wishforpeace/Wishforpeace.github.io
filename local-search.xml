<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2022/12/26/%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/12/26/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><blockquote><p>链表由一个个数据节点组成，是一个递归结构，要么为空，要么存在就是只想另一个数据节点的引用</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span>(<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> LinkNode <span class="hljs-keyword">struct</span> &#123; <br>  Data <span class="hljs-type">int64</span> <br>  NextNode *LinkNode <br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123; <br>  <span class="hljs-comment">// 新的节点 </span><br>  node := <span class="hljs-built_in">new</span>(LinkNode) <br>  node.Data = <span class="hljs-number">2</span> <br>  <span class="hljs-comment">// 新的节点 </span><br>  node1 := <span class="hljs-built_in">new</span>(LinkNode) <br>  node1.Data = <span class="hljs-number">3</span> <br>  node.NextNode = node1 <br>  <span class="hljs-comment">// node1 链接到 node 节点上</span><br>  <span class="hljs-comment">// 新的节点 </span><br>  node2 := <span class="hljs-built_in">new</span>(LinkNode) <br>  node2.Data = <span class="hljs-number">4</span> <br>  node1.NextNode = node2 <span class="hljs-comment">// node2 链接到 node1 节点上 </span><br>  <span class="hljs-comment">// 按顺序打印数据</span><br>  nowNode := node <br>  <span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-keyword">if</span> nowNode != <span class="hljs-literal">nil</span> &#123; <br>      <span class="hljs-comment">// 打印节点值 </span><br>      fmt.Println(nowNode.Data) <br>      <span class="hljs-comment">// 获取下一个节点 </span><br>      nowNode = nowNode.NextNode &#125;<br>    <span class="hljs-comment">// 如果下一个节点为空，表示链表结束了 </span><br>    <span class="hljs-keyword">break</span> <br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>结构体 <code>LinkNode</code> 有两个字段，一个字段存放数据<code> Data</code> ，另一个字典指向下一个节点 <code>NextNode </code>。这种从一个数据节点指向下一个数据节点的结构，都可以叫做链表。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li><p>单链表，就是链表是单向的，像我们上面这个结构一样，可以一直往下找到下一个数据节点，它只有一个方向，它不能往回找。</p></li><li><p>双链表，每个节点既可以找到它之前的节点，也可以找到之后的节点，是双向的。</p></li><li><p>循环链表，就是它一直往下找数据节点，最后回到了自己那个节点，形成了一个回路。循环单链表和循环双链表的区别就是，一个只能一个方向走，一个两个方向都可以走。</p></li></ol><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><h3 id="1-初始化循环链表"><a href="#1-初始化循环链表" class="headerlink" title="1.初始化循环链表"></a>1.初始化循环链表</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <br><span class="hljs-keyword">import</span> ( <span class="hljs-string">&quot;fmt&quot;</span> )<br><span class="hljs-comment">// 初始化空的循环链表，前驱和后驱都指向自己，因为是循环的 </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Ring)</span></span> init() *Ring &#123; <br>  r.next = r<br>  r.prev = r <br>  <span class="hljs-keyword">return</span> r <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123; <br>  r := <span class="hljs-built_in">new</span>(Ring) <br>  r.init() <br>&#125;<br></code></pre></td></tr></table></figure><p>创建一个指定大小 N 的循环链表，值全为空:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建N个节点的循环链表 </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> *Ring &#123; <br>  <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span> &#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> <br>  &#125;<br>  r := <span class="hljs-built_in">new</span>(Ring) <br>  p := r <br>  <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123; <br>    p.next = &amp;Ring&#123;<br>      prev: p<br>    &#125; <br>    p = p.next <br>  &#125;<br>  p.next = r <br>  r.prev = p<br></code></pre></td></tr></table></figure><h3 id="2-获取上一个或下一个节点"><a href="#2-获取上一个或下一个节点" class="headerlink" title="2.获取上一个或下一个节点"></a>2.获取上一个或下一个节点</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 获取下一个节点 </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Ring)</span></span> Next() *Ring &#123; <br>  <span class="hljs-keyword">if</span> r.next == <span class="hljs-literal">nil</span> &#123; <br>    <span class="hljs-keyword">return</span> r.init() <br>  &#125;<br>  <span class="hljs-keyword">return</span> r.next <br>&#125;<br><span class="hljs-comment">// 获取上一个节点 </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Ring)</span></span> Prev() *Ring &#123; <br>  <span class="hljs-keyword">if</span> r.next == <span class="hljs-literal">nil</span> &#123; <br>    <span class="hljs-keyword">return</span> r.init() <br>  &#125;<span class="hljs-keyword">return</span> <br>  r.prev <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-获取第n个节点"><a href="#3-获取第n个节点" class="headerlink" title="3.获取第n个节点"></a>3.获取第n个节点</h3><p>因为链表是循环的，当 n 为负数，表示从前面往前遍历，否则往后面遍历：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Ring)</span></span> Move(n <span class="hljs-type">int</span>) *Ring &#123; <br>  <span class="hljs-keyword">if</span> r.next == <span class="hljs-literal">nil</span> &#123; <br>    <span class="hljs-keyword">return</span> r.init() <br>  &#125;<br>  <span class="hljs-keyword">switch</span> &#123; <br>    <span class="hljs-keyword">case</span> n &lt; <span class="hljs-number">0</span>: <br>    <span class="hljs-keyword">for</span> ; n &lt; <span class="hljs-number">0</span>; n++ &#123;<br>        r = r.prev <br>      &#125; <br>  <span class="hljs-keyword">case</span> n &gt; <span class="hljs-number">0</span>: <br>    <span class="hljs-keyword">for</span> ; n &gt; <span class="hljs-number">0</span>; n-- &#123; <br>      r = r.next <br>    &#125; <br>  &#125;<br>  <span class="hljs-keyword">return</span> r<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-添加节点"><a href="#4-添加节点" class="headerlink" title="4.添加节点"></a>4.添加节点</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 往节点A，链接一个节点，并且返回之前节点A的后驱节点 </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Ring)</span></span> Link(s *Ring) *Ring &#123; <br>  n := r.Next() <br>  <span class="hljs-keyword">if</span> s != <span class="hljs-literal">nil</span> &#123; <br>    p := s.Prev() <br>    r.next = s <br>    s.prev = r <br>    n.prev = p <br>    p.next = n <br>  &#125;<br>  <span class="hljs-keyword">return</span> n <br>&#125;<br></code></pre></td></tr></table></figure><p>添加节点的操作比较复杂，如果节点 s 是一个新的节点。那么也就是在 r 节点后插入一个新节点 s ，而 r 节点之前的后驱节点，将会链接到新节点后面，并返回 r 节点之前的第一个后驱节点 n 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <br><span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<br>ffunc linkNewTest() &#123; <br>  <span class="hljs-comment">// 第一个节点 </span><br>  r := &amp;Ring&#123;Value: <span class="hljs-number">-1</span>&#125; <br>  <span class="hljs-comment">// 链接新的五个节点 </span><br>  r.Link(&amp;Ring&#123;Value: <span class="hljs-number">1</span>&#125;) <br>  r.Link(&amp;Ring&#123;Value: <span class="hljs-number">2</span>&#125;) <br>  r.Link(&amp;Ring&#123;Value: <span class="hljs-number">3</span>&#125;) <br>  r.Link(&amp;Ring&#123;Value: <span class="hljs-number">4</span>&#125;) <br>  node := r <br>  <span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-comment">// 打印节点值 </span><br>    fmt.Println(node.Value) <br>    <span class="hljs-comment">// 移到下一个节点 </span><br>    node = node.Next() <br>    <span class="hljs-comment">// 如果节点回到了起点，结束 </span><br>    <span class="hljs-keyword">if</span> node == r &#123; <br>      <span class="hljs-keyword">return</span> <br>    &#125; <br>  &#125; <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123; <br>  linkNewTest() <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-删除节点"><a href="#5-删除节点" class="headerlink" title="5.删除节点"></a>5.删除节点</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 删除节点后面的 n 个节点 </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Ring)</span></span> Unlink(n <span class="hljs-type">int</span>) *Ring &#123; <br>  <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span> &#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> <br>  &#125;<br>  <span class="hljs-keyword">return</span> r.Link(r.Move(n + <span class="hljs-number">1</span>)) <br>&#125;<br></code></pre></td></tr></table></figure><p>将循环链表的后面几个节点删除。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <br><span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteTest</span><span class="hljs-params">()</span></span> &#123; <br>  <span class="hljs-comment">// 第一个节点 </span><br>  r := &amp;Ring&#123;Value: <span class="hljs-number">-1</span>&#125; <br>  <span class="hljs-comment">// 链接新的五个节点 </span><br>  r.Link(&amp;Ring&#123;Value: <span class="hljs-number">1</span>&#125;) <br>  r.Link(&amp;Ring&#123;Value: <span class="hljs-number">2</span>&#125;) <br>  r.Link(&amp;Ring&#123;Value: <span class="hljs-number">3</span>&#125;) <br>  r.Link(&amp;Ring&#123;Value: <span class="hljs-number">4</span>&#125;) <br>  temp := r.Unlink(<span class="hljs-number">3</span>) <span class="hljs-comment">// 解除了后面两个节点 </span><br>  <span class="hljs-comment">// 打印原来的节点 </span><br>  node := r <span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-comment">// 打印节点值 </span><br>    fmt.Println(node.Value) <br>    <span class="hljs-comment">// 移到下一个节点 </span><br>    node = node.Next() <br>    <span class="hljs-comment">// 如果节点回到了起点，结束 </span><br>    <span class="hljs-keyword">if</span> node == r &#123; <br>      <span class="hljs-keyword">break</span> <br>    &#125; <br>  &#125;<br>  fmt.Println(<span class="hljs-string">&quot;------&quot;</span>)<br>  <span class="hljs-comment">// 打印被切断的节点 </span><br>  node = temp <span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-comment">// 打印节点值 </span><br>    fmt.Println(node.Value) <br>    <span class="hljs-comment">// 移到下一个节点 node = node.Next()</span><br>    <span class="hljs-comment">// 如果节点回到了起点，结束 </span><br>    <span class="hljs-keyword">if</span> node == temp &#123; <br>      <span class="hljs-keyword">break</span> <br>    &#125; <br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-获取链表长度"><a href="#6-获取链表长度" class="headerlink" title="6.获取链表长度"></a>6.获取链表长度</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 查看循环链表长度 </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Ring)</span></span> Len() <span class="hljs-type">int</span> &#123; <br>  n := <span class="hljs-number">0</span> <br>  <span class="hljs-keyword">if</span> r != <span class="hljs-literal">nil</span> &#123;<br>    n = <span class="hljs-number">1</span> <br>    <span class="hljs-keyword">for</span> p := r.Next(); p != r; p = p.next &#123; <br>      n++ <br>    &#125; <br>  &#125;<br>  <span class="hljs-keyword">return</span> n <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ol><li>新建一个链表ChainList，输入一组数据，并输入m，实现从第m个数及往后数据的倒序(不允许使用数组，不允许新建链表，在原有链表上实现逆置)</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//示例</span><br>输入数的个数：<span class="hljs-number">9</span><br>数据为：<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span><br>m值为：<span class="hljs-number">5</span><br>倒叙后输出：<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span> <span class="hljs-number">8</span> <span class="hljs-number">7</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><ol start="2"><li><p>链表排序</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/sort_list_2.jpg" alt="img"></p></li><li><p>使用单链表实现集合的交、并、差运算</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//示例</span><br>Set1 = <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">6</span><br>Set1 = <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">8</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span><br>Set1∩Set2 = <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span><br>Set1∪Set2 = <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span> <span class="hljs-number">8</span> <span class="hljs-number">5</span> <br>Set1-Set2 = <span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span><br>Set2-Set1 = <span class="hljs-number">3</span> <span class="hljs-number">8</span> <span class="hljs-number">5</span> <br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Go项目包管理方法</title>
    <link href="/2022/12/18/Go%E9%A1%B9%E7%9B%AE%E5%8C%85%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95/"/>
    <url>/2022/12/18/Go%E9%A1%B9%E7%9B%AE%E5%8C%85%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="企业级Go项目包管理方法"><a href="#企业级Go项目包管理方法" class="headerlink" title="企业级Go项目包管理方法"></a>企业级Go项目包管理方法</h1><h2 id="Go包管理困境"><a href="#Go包管理困境" class="headerlink" title="Go包管理困境"></a>Go包管理困境</h2><ul><li>没有统一的包管理方式</li><li>包之间的依赖关系很难维护</li><li>如果同时需要一个包的不同版本，很麻烦</li></ul><h2 id="尝试解决"><a href="#尝试解决" class="headerlink" title="尝试解决"></a>尝试解决</h2><ul><li>godep、govendor、glide</li><li>未彻底解决GOPATH问题</li><li>使用起来麻烦</li></ul><h2 id="Go-Modules"><a href="#Go-Modules" class="headerlink" title="Go Modules"></a>Go Modules</h2><ul><li>本质上Go包就是一个项目的源码</li><li>go mod作用：将Go包和Git项目关联起来</li><li>Go包的版本就是git项目的Tag</li><li>go mod解决：需要哪个git项目的什么版本</li></ul><h2 id="使用Modules"><a href="#使用Modules" class="headerlink" title="使用Modules"></a>使用Modules</h2><p>项目地址</p><ul><li>github.com&#x2F;Jeffail&#x2F;tunny</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs g">go get github.com/Jeffail/tunny<br><br>go get github.com/Jeffail/tunny@0.1.3<br></code></pre></td></tr></table></figure><h2 id="Github无法访问"><a href="#Github无法访问" class="headerlink" title="Github无法访问"></a>Github无法访问</h2><ul><li>使用goproxy.cn作为代理</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">go env -w GOPROXY=https:<span class="hljs-regexp">//g</span>oporxy.cn,direct<br></code></pre></td></tr></table></figure><h2 id="使用本地文件替代"><a href="#使用本地文件替代" class="headerlink" title="使用本地文件替代"></a>使用本地文件替代</h2><ul><li>go.mod 文件追加</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">replace</span> github.com/Jeffail/<span class="hljs-function"><span class="hljs-params">tunny</span> =&gt;</span> xxx/xxx<br></code></pre></td></tr></table></figure><ul><li>go vendor 缓存到本地</li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">go</span> <span class="hljs-built_in">mod</span> vendor<br><br><span class="hljs-built_in">go</span> build -<span class="hljs-built_in">mod</span> vendor<br></code></pre></td></tr></table></figure><h2 id="创建Go-Module"><a href="#创建Go-Module" class="headerlink" title="创建Go Module"></a>创建Go Module</h2><ul><li>删除本地go.mod</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-keyword">mod</span> init github.<span class="hljs-keyword">com</span>/仓库地址路径<br></code></pre></td></tr></table></figure><ul><li><p>推送至代码仓库</p></li><li><p>增加新版本，在仓库打新Tag</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Go程序如何运行</title>
    <link href="/2022/12/17/Go%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C/"/>
    <url>/2022/12/17/Go%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Go程序如何运行？"><a href="#Go程序如何运行？" class="headerlink" title="Go程序如何运行？"></a>Go程序如何运行？</h1><h2 id="Go程序的入口"><a href="#Go程序的入口" class="headerlink" title="Go程序的入口"></a>Go程序的入口</h2><p>第一行代码在runtime包中</p><p><strong>runtime&#x2F;rt0_XXX.s</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221217112513003.png" alt="image-20221217112513003"></p><p></p><h2 id="读取命令行参数"><a href="#读取命令行参数" class="headerlink" title="读取命令行参数"></a>读取命令行参数</h2><ul><li>复制参数数量argc和参数值argv到栈上</li></ul><h2 id="初始化g0执行栈"><a href="#初始化g0执行栈" class="headerlink" title="初始化g0执行栈"></a>初始化g0执行栈</h2><ul><li>g0是为了调度协程而产生的协程</li><li>g0是每个go语言的第一个协程</li></ul><h2 id="运行时检测"><a href="#运行时检测" class="headerlink" title="运行时检测"></a>运行时检测</h2><ul><li>检查各类型的长度</li><li>检查指针操作</li><li>检查结构体字段的偏移量</li><li>检查atomic原子操作</li><li>检查CAS操作</li><li>检查栈大小是否是2的幂次</li></ul><h2 id="参数初始化runtime-args"><a href="#参数初始化runtime-args" class="headerlink" title="参数初始化runtime.args"></a>参数初始化runtime.args</h2><ul><li>对命令行中的参数进行处理</li><li>参数数量赋值给<code>argc int32</code></li><li>参数值复制给<code>argv **byte</code></li></ul><h2 id="调度器初始化rumtime-shedinit"><a href="#调度器初始化rumtime-shedinit" class="headerlink" title="调度器初始化rumtime.shedinit"></a>调度器初始化rumtime.shedinit</h2><ul><li>全局栈空间内存分配</li><li>加载命令行参数到os.Args</li><li>堆内存空间的初始化</li><li>加载操作系统环境变量</li><li>初始化当前系统线程</li><li>垃圾回收器的参数初始化</li><li>算法初始化（map、hash）</li><li>设置process数量</li></ul><h2 id="创建主协程"><a href="#创建主协程" class="headerlink" title="创建主协程"></a>创建主协程</h2><ul><li>创建一个新的协程，执行runtime.main</li><li>放入调度器等待调度</li></ul><h2 id="初始化M"><a href="#初始化M" class="headerlink" title="初始化M"></a>初始化M</h2><ul><li>初始化一个M，用来调度主协程</li></ul><h2 id="主协程执行主函数"><a href="#主协程执行主函数" class="headerlink" title="主协程执行主函数"></a>主协程执行主函数</h2><ul><li>执行runtime包中的init方法</li><li>启动GC垃圾收集器</li><li>执行用户包依赖的init方法</li><li>执行用户主函数main.main()</li></ul>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Go程序如何编译</title>
    <link href="/2022/12/17/Go%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91/"/>
    <url>/2022/12/17/Go%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h1 id="Go程序如何编译"><a href="#Go程序如何编译" class="headerlink" title="Go程序如何编译"></a>Go程序如何编译</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br>&#123;<br>fmt.Println(<span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>go build -n</code></p><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221217102250779.png" alt="image-20221217102250779"></p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><ul><li>将源码翻译成Token</li><li>Token是代码中最小的语义结构</li></ul><h3 id="句法分析"><a href="#句法分析" class="headerlink" title="句法分析"></a>句法分析</h3><ul><li><p>Token序列经过处理，变成语法树(SST)</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221217102634690.png" alt="image-20221217102634690"></p></li></ul><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><ul><li>类型检查</li><li>类型推断</li><li>查看类型是否匹配</li><li>函数调用内联</li><li>逃逸分析</li></ul><h3 id="中间码生成"><a href="#中间码生成" class="headerlink" title="中间码生成"></a>中间码生成</h3><ul><li>为了处理不同平台的差异，先生成中间代码(SSA)</li><li>查看从代码到SSA中间码的整个过程</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-variable">$env</span>:<span class="hljs-attribute">GOSSAFUNG</span>=<span class="hljs-string">&quot;main&quot;</span><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">GOSSAFUNC</span>=main<br>go build<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221217103726909.png" alt="image-20221217103726909"></p><h3 id="机器码生成"><a href="#机器码生成" class="headerlink" title="机器码生成"></a>机器码生成</h3><ul><li><p>生成Plan9汇编代码</p></li><li><p>最后编译为机器码</p></li><li><p>输出的机器码为.a文件</p></li><li><p>查看Plan9汇编代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> build -gcflags -S main.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul><li>将各个包进行链接，包括runtime</li></ul>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>runtime</title>
    <link href="/2022/12/17/runtime/"/>
    <url>/2022/12/17/runtime/</url>
    
    <content type="html"><![CDATA[<ul><li>Runtime 就是程序的运行环境</li><li>Java：Java虚拟机</li><li>JavaScript：浏览器内核</li></ul><h1 id="Go的Runtime特点"><a href="#Go的Runtime特点" class="headerlink" title="Go的Runtime特点"></a>Go的Runtime特点</h1><ul><li>go没有虚拟机概念</li><li>Runtime作为程序的一部分打包进二进制产物</li><li>Runtime随用户程序一起运行</li><li>Runtime与用户程序没有明显界限，直接通过函数调用</li></ul><h1 id="Go的Runtime能力"><a href="#Go的Runtime能力" class="headerlink" title="Go的Runtime能力"></a>Go的Runtime能力</h1><ul><li>内存管理能力</li><li>垃圾回收能力（GC）</li><li>超强的并发能力（协程调度）</li></ul><h1 id="Go的Runtime其他特点"><a href="#Go的Runtime其他特点" class="headerlink" title="Go的Runtime其他特点"></a>Go的Runtime其他特点</h1><ul><li>Runtime有一定的屏蔽系统调用能力</li><li>一些go的关键字其实是Runtime下的函数</li></ul><table><thead><tr><th>关键字</th><th>函数</th></tr></thead><tbody><tr><td>go</td><td>newproc</td></tr><tr><td>new</td><td>newobject</td></tr><tr><td>make</td><td>makeslice，makechain，makemap</td></tr><tr><td>&lt;-</td><td>chansend1,chanrecv1</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Go的Runtime负责内存管理、垃圾回收、协程调度</li><li>Go的Runtime被编译为用户程序的一部分，一起运行</li></ul>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++异常类型以及多级catch匹配</title>
    <link href="/2022/11/30/C++%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E5%A4%9A%E7%BA%A7catch%E5%8C%B9%E9%85%8D/"/>
    <url>/2022/11/30/C++%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E5%A4%9A%E7%BA%A7catch%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="C-异常类型以及多级catch匹配"><a href="#C-异常类型以及多级catch匹配" class="headerlink" title="C++异常类型以及多级catch匹配"></a>C++异常类型以及多级catch匹配</h1><p><code>try-catch</code>使用方法</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">//</span><br>&#125;<span class="hljs-keyword">catch</span>(exceptionType <span class="hljs-keyword">variable</span>)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01深入理解神经网络原理</title>
    <link href="/2022/11/18/01%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"/>
    <url>/2022/11/18/01%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解神经网络原理"><a href="#深入理解神经网络原理" class="headerlink" title="深入理解神经网络原理"></a>深入理解神经网络原理</h1><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221119000842671.png" alt="image-20221119000842671"></p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>方法</title>
    <link href="/2022/11/17/%E6%96%B9%E6%B3%95/"/>
    <url>/2022/11/17/%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p><strong>重点</strong>：面向对象编程（OOP：Object Oriented Programming）</p><p>不同于C++和Java的<code>Class</code>类写法，</p><h2 id="1-方法声明"><a href="#1-方法声明" class="headerlink" title="1.方法声明"></a>1.方法声明</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;math&quot;</span><br><br><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span> &#123;<br>X, Y <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Distance</span><span class="hljs-params">(p, q Point)</span></span> <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Point)</span></span> Distance(q Point) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)<br>&#125;<br></code></pre></td></tr></table></figure><p>此处11行的代码，有一个<code>Point</code>类型的变量为<code>p</code>，此处的<code>p</code>名为方法的接收器<code>receiver</code>，早期也被称为”向一个对象发送消息”。</p><p>此处我们来看一下C++的写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span><br>&#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">float</span> X, Y;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y);<br>    <span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">Distance</span><span class="hljs-params">(Point q)</span></span>;<br>&#125;;<br><br>Point::<span class="hljs-built_in">Point</span>(<span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y)<br>&#123;<br>    X = x;<br>    Y = y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">Point::Distance</span><span class="hljs-params">(Point q)</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hypot</span>(X - q.X, Y - q.Y);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Point <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">Point <span class="hljs-title">q</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)</span></span>;<br>    cout &lt;&lt; p.<span class="hljs-built_in">Distance</span>(q) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>视线回到go</p><p>我们来测试一下上面的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">p := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>q := Point&#123;<span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;<br>fmt.Println(Distance(p, q)) <span class="hljs-comment">// &quot;5&quot;, function call</span><br>fmt.Println(p.Distance(q)) <span class="hljs-comment">// &quot;5&quot;, method call</span><br></code></pre></td></tr></table></figure><p>第三行调用的是函数，第四行调用的是方法，它俩没有产生任何冲突，仅仅是名字相同，一个是简单的函数运算，一个是Point类下的指定方法。</p><p><code>p.Distance(q)</code>被称为选择器，只有对应的类型才能够使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Path []Point<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(path Path)</span></span> Distance() <span class="hljs-type">float64</span> &#123;<br>sum := <span class="hljs-number">0.0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> path &#123;<br><span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &#123;<br>sum += path[i<span class="hljs-number">-1</span>].Distance(path[i])<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> sum<br><br>&#125;<br></code></pre></td></tr></table></figure><p>此处<code>Point</code>是一个<code>slice</code>类型，虽然不是结构体，但是依然可以定义方法。</p><p>其实任何类型都可以定义方法，只要不是指针和<code>interface&#123;&#125;</code></p><p>此处的<code>Distance()</code>是特定于<code>Path</code>的方法</p><p>如果是对于同一类型,内部方法必须使用唯一方法名，但是如果是不同类型，方法名可以相同</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//举例</span><br></code></pre></td></tr></table></figure><h2 id="2-基于指针对象的方法"><a href="#2-基于指针对象的方法" class="headerlink" title="2.基于指针对象的方法"></a>2.基于指针对象的方法</h2><p>调用函数时，会拷贝参数值，但是如果函数需要修改一个变量或者变量太大，这个时候就需要使用指针，通过地址直接修改变量。</p><p>如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Point)</span></span> ScaleBy(factor <span class="hljs-type">float64</span>) &#123;<br>p.X *= factor<br>p.Y *= factor<br>&#125;<br></code></pre></td></tr></table></figure><p>现实之中，如果一个<code>Point</code>的类含有一个指针作为接收器的方法，理论上其余的方法也都应该以指针作为接收器方法。</p><p>特别注意，如果一个类型名本身就是一个指针，是不能够出现在接收器之中的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> P *<span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(P)</span></span> f() &#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>想要使用<code>Point</code>的指针接收器，只需要提供<code>Point</code> 类型的指针即可</p><p>如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">r := &amp;Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>r.ScaleBy(<span class="hljs-number">2</span>)<br>fmt.Println(*r)<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">p := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>pptr := &amp;p<br>pptr.ScaleBy(<span class="hljs-number">2</span>)<br>fmt.Println(p)<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">p := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>(&amp;p).ScaleBy(<span class="hljs-number">2</span>)<br>fmt.Println(p)<br></code></pre></td></tr></table></figure><p>不过后面两种方法略显笨拙，以下为简短写法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">p.ScaleBy(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>编译器会<strong>隐式地帮我们用&amp;p</strong> 去调用 ScaleBy 这个方法。这种简写方法只适用于“变量”，包括struct 里的字段比如 p.X，以及 array 和 slice 内的元素比如 perim[0]。我们不能通过一个无法取到地址的接收器来调用指针方法，比如<strong>临时变量的内存地址</strong>就无法获取得到：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;.ScaleBy(<span class="hljs-number">2</span>) <br></code></pre></td></tr></table></figure><p>但是我们可以用一个<em>Point 这样的接收器来调用 Point 的方法，因为我们可以通过地址来找到这个变量，只要用解引用符号</em>来取到该变量即可。编译器在这里也会给我们<strong>隐式地插入*这个操作符</strong>，所以下面这两种写法等价的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">pptr.Distance(q)<br>(*pptr).Distance(q)<br></code></pre></td></tr></table></figure><h2 id="3-通过嵌入结构体来扩展类型"><a href="#3-通过嵌入结构体来扩展类型" class="headerlink" title="3.通过嵌入结构体来扩展类型"></a>3.通过嵌入结构体来扩展类型</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;image/color&quot;</span><br><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span>&#123; X, Y <span class="hljs-type">float64</span> &#125;<br><span class="hljs-keyword">type</span> ColoredPoint <span class="hljs-keyword">struct</span> &#123;<br> Point<br> Color color.RGBA<br>&#125;<br></code></pre></td></tr></table></figure><p>本来可以将颜色点定义为含有<code>X</code>、<code>Y</code>、<code>Color</code>三个字段的结构体，但是我们可以把<code>Point</code>嵌套放入<code>ColoredPoint</code>之中。</p><p>在声明的时候，我们不需要再定义<code>Point</code>，而是可以直接使用<code>ColoredPoint</code>定义<code>X</code>、<code>Y</code>，</p><p>​对于 Point 中的方法我们也有类似的用法，我们可以把 ColoredPoint 类型当作接收器来调用Point 里的方法，即使 ColoredPoint 里没有声明这些方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">red := color.RGBA&#123;<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>&#125;<br><br>blue := color.RGBA&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>&#125;<br><br><span class="hljs-keyword">var</span> p = ColoredPoint&#123;Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, red&#125;<br><br><span class="hljs-keyword">var</span> q = ColoredPoint&#123;Point&#123;<span class="hljs-number">5</span>, <span class="hljs-number">4</span>&#125;, blue&#125;<br><br>fmt.Println(p.Distance(q.Point)) <br><br>p.ScaleBy(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>展示可以看出<code>Point</code>类的方法都被引入到了<code>ColoredPoint</code>之中</p><p>此处涉及到面向对象的知识，<code>Point</code>被称之为基类，而<code>ColoredPoint</code>被称之为子类。</p><p>刚刚的调用等价于</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p ColoredPoint)</span></span> Distance(q Point) <span class="hljs-type">float64</span> &#123;<br> <span class="hljs-keyword">return</span> p.Point.Distance(q)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *ColoredPoint)</span></span> ScaleBy(factor <span class="hljs-type">float64</span>) &#123;<br> p.Point.ScaleBy(factor)<br>&#125;<br></code></pre></td></tr></table></figure><p>当 Point.Distance 被第一个包装方法调用时，它的接收器值是 p.Point，而不是 p，当然了，在 Point 类的方法里，你是访问不到 ColoredPoint 的任何字段的。</p><p>在类型中内嵌的匿名字段也可能是一个命名类型的指针，这种情况下字段和方法会被间接地引入到当前的类型中。添加这一层间接关系让我们可以共享通用的结构并动态地改变对象之间的关系。下面这个 ColoredPoint 的声明内嵌了一个*Point 的指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ColoredPoint <span class="hljs-keyword">struct</span> &#123;<br><br> *Point<br><br> Color color.RGBA<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最大子序和</title>
    <link href="/2022/11/12/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <url>/2022/11/12/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h1><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出：6<br>解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[5,4,-1,7,8]</span><br>输出：<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p><h1 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h1><h2 id="解法一：DP"><a href="#解法一：DP" class="headerlink" title="解法一：DP"></a>解法一：DP</h2>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>验证栈序列</title>
    <link href="/2022/11/08/%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97/"/>
    <url>/2022/11/08/%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="验证栈序列"><a href="#验证栈序列" class="headerlink" title="验证栈序列"></a>验证栈序列</h1><p>给定 <code>pushed</code> 和 <code>popped</code> 两个序列，每个序列中的 <strong>值都不重复</strong>，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 <code>true</code>；否则，返回 <code>false</code> 。</p><h2 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h2><p><code>pushed</code>和<code>popped</code>的性质：</p><ul><li><code>pushed</code>中元素互不相同</li><li><code>popped</code>和<code>pushed</code>长度相同</li><li><code>popped</code>是数组<code>pushed</code>的一个排列</li></ul><p>结论：</p><ul><li>栈内无重复元素</li><li>如果<code>pushed</code>和<code>poped</code>是有效的栈操作序列，则经过所有的入栈和出栈操作之后，每个元素各入栈和出栈一次，栈为空</li></ul><p>方法：</p><p>因此，可以遍历两个数组，模拟入栈和出栈操作，判断两个数组是否为有效的栈操作序列。</p><p>模拟入栈操作可以通过遍历数组 <code>pushed</code>实现。由于只有栈顶的元素可以出栈，因此需要判断栈顶元素是否与<code>popped</code>的当前元素相同，如果相同则将栈顶元素出栈。由于元素互不相同，因此当前栈顶元素与<code>popped</code>的当前元素必须将栈顶元素出栈，否则出栈顺序一定不等于<code>popped</code>。</p><p>验证栈序列的模拟做法：</p><ol><li>遍历数组<code>pushed</code>，将<code>pushed</code>的每个元素一次入栈；</li><li>每次将<code>pushed</code>的元素入栈之后，如果栈不为空且栈顶元素与<code>popped</code>的当前元素相同，则将栈顶元素出栈，同时遍历数组<code>popped</code>，直到栈为空或栈顶元素与<code>popped</code>的当前元素不同。</li></ol><p>遍历数组<code>pushed</code>,每个元素都按照<code>pushed</code>的顺序入栈一次。如果结束以后，栈为空，则表明元素按照了<code>popped</code>顺序弹出，返回true，否则返回false。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">validateStackSequences</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;pushed, vector&lt;<span class="hljs-type">int</span>&gt; &amp;popped)</span></span><br><span class="hljs-function">    </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-type">int</span> n = pushed.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-comment">//插入数据</span><br>            <span class="hljs-comment">//能够避免产生不必要的临时变量</span><br>            st.<span class="hljs-built_in">emplace</span>(pushed[i]);<br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>() == popped[j])<br>            &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; pushed = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    vector&lt;<span class="hljs-type">int</span>&gt; popped = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>    <span class="hljs-type">bool</span> result;<br>    Solution solution;<br>    cout &lt;&lt; solution.<span class="hljs-built_in">validateStackSequences</span>(pushed, popped) &lt;&lt; endl;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>复杂度分析:</p><ul><li>时间复杂度O(n)</li><li>空间负责度O(n)，取决于栈的大小for (int x: nums)</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Uninformed Search</title>
    <link href="/2022/11/02/Uninformed-Search/"/>
    <url>/2022/11/02/Uninformed-Search/</url>
    
    <content type="html"><![CDATA[<h1 id="Artificial-Intelligence-Search"><a href="#Artificial-Intelligence-Search" class="headerlink" title="Artificial Intelligence Search"></a>Artificial Intelligence Search</h1><h2 id="Agents-that-Plan-Ahead"><a href="#Agents-that-Plan-Ahead" class="headerlink" title="Agents that Plan Ahead"></a>Agents that Plan Ahead</h2><ul><li><h3 id="Reflex-Agent"><a href="#Reflex-Agent" class="headerlink" title="Reflex Agent:"></a>Reflex Agent:</h3><ul><li><p>Choose action based on current percept</p></li><li><p>May have memory or a model of the world’s current state</p></li><li><p>Do not consider the future consequences of their actions</p></li><li><p>Consider how the world IS</p></li></ul></li><li><h3 id="Planning-Agents"><a href="#Planning-Agents" class="headerlink" title="Planning Agents"></a>Planning Agents</h3><ul><li>Ask “what if”</li><li>Decisions based on (hypothesized假设) consequences of actions</li></ul></li></ul><h2 id="Search-Problems"><a href="#Search-Problems" class="headerlink" title="Search Problems"></a>Search Problems</h2><p>+ </p><h2 id="Uniformed-Search-Methods"><a href="#Uniformed-Search-Methods" class="headerlink" title="Uniformed Search Methods"></a>Uniformed Search Methods</h2><ul><li><h3 id="Depth-First-Search"><a href="#Depth-First-Search" class="headerlink" title="Depth-First Search"></a>Depth-First Search</h3></li><li><h3 id="Breadth-First-Search"><a href="#Breadth-First-Search" class="headerlink" title="Breadth-First Search"></a>Breadth-First Search</h3></li><li><h3 id="Uniform-Cost-Search"><a href="#Uniform-Cost-Search" class="headerlink" title="Uniform-Cost Search"></a>Uniform-Cost Search</h3></li></ul>]]></content>
    
    
    <categories>
      
      <category>CS188</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Network Programming PartII</title>
    <link href="/2022/10/25/Network-Programming-PartII/"/>
    <url>/2022/10/25/Network-Programming-PartII/</url>
    
    <content type="html"><![CDATA[<h1 id="Network-Programming-PartII"><a href="#Network-Programming-PartII" class="headerlink" title="Network Programming PartII"></a>Network Programming PartII</h1><h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221025212319689.png" alt="image-20221025212319689"></h1><h2 id="Socket-Interface"><a href="#Socket-Interface" class="headerlink" title="Socket Interface"></a>Socket Interface</h2><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221025214427236.png" alt=" "></p><p>This giant block diagram shows all the activities invloved in setting up and running both a server and a client.</p><p>The idead is you need to the server needs to fire up .You can’t contact the server until the server exists.</p><p> A server begins on a machine and then accepts a connection request from a client.</p><p>Each end looks like reading and writing a file.</p><p>Once the client is done with whatever it’s trying to get,it will disconnect.Then the listening server will detect this by receiving an end of file when it attempts to read from the client,then it will close the connection.</p><p> This it’s not going to shut down at this point ,it’s just going to return back and accept new connection request.This is what’s known as an interactive server,which can only handle a single client at a time. </p><p>The first step between client and server is very messy relatively new api call <code>getaddrinfo</code>.</p><p>It contains a lot of other sort of individual protocols.</p><p>It lets you sort of go forward from a domain name to a IP address and go backward from an IP address back to domain name.</p><h2 id="Recall"><a href="#Recall" class="headerlink" title="Recall"></a>Recall</h2><h3 id="Generic-socket-address"><a href="#Generic-socket-address" class="headerlink" title="Generic socket address"></a>Generic socket address</h3><ul><li><p>For address arguments to connect,bind,and accept</p></li><li><p>Necessary only because C did not have generic (void *)Pointers when the sockets interface was designed</p></li><li><p>For casting convenience,we adopt the Stevens convention:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> <span class="hljs-title">SA</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span>&#123;</span><br>  <span class="hljs-type">uint16_t</span>  sa_family; <span class="hljs-comment">//protocol family</span><br>  <span class="hljs-type">char</span> as_data[<span class="hljs-number">14</span>];<span class="hljs-comment">//Address data</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>寄存器</title>
    <link href="/2022/10/19/%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <url>/2022/10/19/%E5%AF%84%E5%AD%98%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p><img src="https://raw.githubusercontent.com/Hyeonwuu/Image/master/image-20221019161654005.png" alt="img"></p><p>一个字型数据可以存放在内存之中 可以由2个连续的地址内存单元组成</p><p><strong>高地址</strong>：内存单元存放字型数据的<strong>高位字节</strong></p><p><strong>低地址</strong>：内存单元存放字型数据的<strong>低位字节</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221019163034201.png" alt="image-20221019163034201"></p><h2 id="ds段地址寄存器"><a href="#ds段地址寄存器" class="headerlink" title="ds段地址寄存器"></a>ds段地址寄存器</h2><p>访问数据用的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov al,ds:[0];mov移动指令CPU中的AL寄存器，内存地址为ds:[0] 0为偏移地址，方括号是ds+0组合成的段地址，方括号内为得到的内容<br>;cpu从段寄存器内读取了8位数据<br></code></pre></td></tr></table></figure><p><strong>错误修改ds的方法</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221019164656493.png" alt="image-20221019164656493" style="zoom:25%;" /></strong></p><p><strong>正确方式，使用寄存器存储</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221019164806872.png" alt="image-20221019164806872" style="zoom:25%;" /></strong></p><p><strong>高位字节到高位地址，低位字节到低位地址</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221019165406196.png" alt="image-20221019165406196" style="zoom:25%;" /></strong></p><h2 id="寄存器ax-bx-cx"><a href="#寄存器ax-bx-cx" class="headerlink" title="寄存器ax bx cx"></a>寄存器ax bx cx</h2><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221019171548323.png" alt="image-20221019171548323"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax,1000H<br>mov ds,ax;获取段地址<br></code></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221019170350121.png" alt="image-20221019170350121" style="zoom:25%;" /><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221019170656087.png" alt="image-20221019170656087" style="zoom:50%;" /><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221019170543070.png" alt="image-20221019170543070"></p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p> 问题3.4</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221019171513948.png" alt="image-20221019171513948"></p>]]></content>
    
    
    <categories>
      
      <category>汇编语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>承上启下</title>
    <link href="/2022/10/19/%E6%89%BF%E4%B8%8A%E5%90%AF%E4%B8%8B/"/>
    <url>/2022/10/19/%E6%89%BF%E4%B8%8A%E5%90%AF%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="承上启下"><a href="#承上启下" class="headerlink" title="承上启下"></a>承上启下</h1><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>数据寄存器</p><p>地址寄存器</p><ul><li>段地址寄存器</li><li>偏移地址寄存器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;通用寄存器<br>AX <br>BX;偏移地址寄存器<br>CX;有其他作用<br>DX;和AX一起处理数据<br></code></pre></td></tr></table></figure><p>通用寄存器都为16位寄存器，可以分割为2个互相独立的8位寄存器</p><h2 id="翻译工作"><a href="#翻译工作" class="headerlink" title="翻译工作"></a>翻译工作</h2><p>保证数据与寄存器之间的位数一致</p><p>由寄存器的位数决定</p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov;移动指令<br>add;运算指令 <br></code></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221019153653119.png" alt="image-20221019153653119" style="zoom:50%;" /><p>运算时超过寄存器的最大值，超过部分不会消失，存储到其他部分</p><p>ax与al相互独立，超过部分不会存入ah</p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221019154053576.png" alt="image-20221019154053576" style="zoom:50%;" /><h3 id="地址寄存器"><a href="#地址寄存器" class="headerlink" title="地址寄存器"></a>地址寄存器</h3><ul><li>ds(data segment)</li><li>es(extern segment)</li><li>ss(stakc segment)</li><li>cs(code segment)</li></ul><h3 id="偏移地址寄存器"><a href="#偏移地址寄存器" class="headerlink" title="偏移地址寄存器"></a>偏移地址寄存器</h3><ul><li>sp</li><li>bp</li><li>si</li><li>di</li><li>ip</li><li>bx</li></ul><h3 id="组合规则：组合起来"><a href="#组合规则：组合起来" class="headerlink" title="组合规则：组合起来"></a>组合规则：组合起来</h3><p>段地址✖️16+偏移地址&#x3D;<strong>物理地址</strong></p><h4 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h4><p>8086CPU有20根地址线</p><h3 id="CPU区分指令和数据："><a href="#CPU区分指令和数据：" class="headerlink" title="CPU区分指令和数据："></a>CPU区分指令和数据：</h3><p>依靠CS和IP两个寄存器</p><p>任意时刻的CPU将段地址寄存器CS和偏移地址寄存器IP所组合出的地址从中读取内容</p><p>并且全部当作指令执行</p><p>指令是有长度的，且与<strong>IP寄存器</strong>有关</p><p>可以用修改CS和IP两个寄存器的指令</p><p><strong>转移指令</strong>：<code>jmp</code>     <code>call</code></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;jmp格式<br>jmp2000:0<br>jmp[寄存器];相当于mov ip,ax<br><br>;call<br>call    ******<br>;1.CPU从CS:IP所指向的内存单元读取指令，存放到指令缓存器之中<br>;2.IP=IP+所读取指令的长度，从而指向下一条指令<br>;3.执行指令缓存器中的内容，回到步骤1<br></code></pre></td></tr></table></figure><h3 id="指令和数据"><a href="#指令和数据" class="headerlink" title="指令和数据"></a>指令和数据</h3><p>存放在内存之中没有任何区别</p><p>是程序员通过修改寄存器中的内容（地址寄存器），告诉CPU数据在哪里  指令在哪里 </p>]]></content>
    
    
    <categories>
      
      <category>汇编语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>debug调试工具使用总结</title>
    <link href="/2022/10/18/debug%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2022/10/18/debug%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="debug调试工具使用总结"><a href="#debug调试工具使用总结" class="headerlink" title="debug调试工具使用总结"></a>debug调试工具使用总结</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">r     ;查看和改变寄存器中的内容<br>d     ;查看内存中的内容<br>u;将内存中的机器指令翻译成汇编指令<br>a;以汇编指令格式在内存中写入一条汇编指令<br>t;执行当前CS:IP所指向的机器指令<br>e;可以改写内存中内容<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>汇编语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Colly</title>
    <link href="/2022/10/08/Colly/"/>
    <url>/2022/10/08/Colly/</url>
    
    <content type="html"><![CDATA[<h1 id="Colly"><a href="#Colly" class="headerlink" title="Colly"></a><a href="http://go-colly.org/">Colly</a></h1><h2 id="Fast-and-Elegant-Scraping-Framework-for-Gophers"><a href="#Fast-and-Elegant-Scraping-Framework-for-Gophers" class="headerlink" title="Fast and Elegant Scraping Framework for Gophers"></a>Fast and Elegant Scraping Framework for Gophers</h2><p>Colly provides a clean interface to write any kind of <strong>crawler&#x2F;scraper&#x2F;spider</strong></p><p>With Colly you can easily extract structured data from websites, which can be used for a wide range of applications, like data mining, data processing or archiving.</p><h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> -<span class="hljs-keyword">u</span> github.<span class="hljs-keyword">com</span>/gocolly/colly/...<br></code></pre></td></tr></table></figure><h2 id="Getting-started"><a href="#Getting-started" class="headerlink" title="Getting started"></a>Getting started</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/gocolly/colly&quot;</span><br></code></pre></td></tr></table></figure><h3 id="Collector"><a href="#Collector" class="headerlink" title="Collector"></a>Collector</h3><p>Colly’s main entity.</p><p>Manages the network communication and responsible for the execution of the attached callbacks while a collector job is running. </p><p>To work with colly, you have to initialize a <code>Collector</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">c := colly.NewCollector()<br></code></pre></td></tr></table></figure><h3 id="Callbacks"><a href="#Callbacks" class="headerlink" title="Callbacks"></a>Callbacks</h3><p>Attach different type of callback functions to a <code>Collector</code> to control a collecting job or retrieve information.</p><h4 id="Add-callbacks-to-a-Collector"><a href="#Add-callbacks-to-a-Collector" class="headerlink" title="Add callbacks to a Collector"></a>Add callbacks to a Collector</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 注册请求回调，每次发送请求时执行该回调</span><br>c.OnRequest(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r *colly.Request)</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Visiting&quot;</span>, r.URL)<br>&#125;)<br><br><span class="hljs-comment">// 注册错误回调，执行请求发生时执行该回调</span><br>c.OnError(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(_ *colly.Response, err <span class="hljs-type">error</span>)</span></span> &#123;<br>    log.Println(<span class="hljs-string">&quot;Something went wrong:&quot;</span>, err)<br>&#125;)<br><span class="hljs-comment">// 注册响应回调，每次收到响应时执行该回调</span><br>c.OnResponse(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r *colly.Response)</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Visited&quot;</span>, r.Request.URL)<br>&#125;)<br><span class="hljs-comment">// 注册HTML回调，对每一个href属性的a元素执行回调函数。</span><br>c.OnHTML(<span class="hljs-string">&quot;a[href]&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(e *colly.HTMLElement)</span></span> &#123;<br>    e.Request.Visit(e.Attr(<span class="hljs-string">&quot;href&quot;</span>))<br>&#125;)<br><span class="hljs-comment">// CSS选择器</span><br>c.OnHTML(<span class="hljs-string">&quot;tr td:nth-of-type(1)&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(e *colly.HTMLElement)</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;First column of a table row:&quot;</span>, e.Text)<br>&#125;)<br><span class="hljs-comment">// 如果接收到的内容是HTML或XML ,则在之后调用(非必需)</span><br>c.OnXML(<span class="hljs-string">&quot;//h1&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(e *colly.XMLElement)</span></span> &#123;<br>    fmt.Println(e.Text)<br>&#125;)<br><span class="hljs-comment">// OnXML回调后调用(非必需)</span><br>c.OnScraped(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r *colly.Response)</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Finished&quot;</span>, r.Request.URL)<br>&#125;)<br><br></code></pre></td></tr></table></figure><h2 id="Combat"><a href="#Combat" class="headerlink" title="Combat"></a>Combat</h2><h2 id="豆瓣"><a href="#豆瓣" class="headerlink" title="豆瓣"></a>豆瓣</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;github.com/PuerkitoBio/goquery&quot;</span><br><span class="hljs-string">&quot;github.com/gocolly/colly&quot;</span><br><span class="hljs-string">&quot;github.com/gocolly/colly/extensions&quot;</span><br><span class="hljs-string">&quot;regexp&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>t := time.Now()<br>number := <span class="hljs-number">1</span><br><br>c := colly.NewCollector(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *colly.Collector)</span></span> &#123;<br>extensions.RandomUserAgent(c) <span class="hljs-comment">// 设置随机头</span><br>c.Async = <span class="hljs-literal">true</span><br>&#125;,<br><span class="hljs-comment">//过滤url,去除不是https://movie.douban.com/top250?start=0&amp;filter= 的url</span><br>colly.URLFilters(<br>regexp.MustCompile(<span class="hljs-string">&quot;^(https://movie\\.douban\\.com/top250)\\?start=[0-9].*&amp;filter=&quot;</span>),<br>),<br>) <span class="hljs-comment">// 创建收集器</span><br><span class="hljs-comment">// 响应的格式为HTML,提取页面中的链接</span><br>c.OnHTML(<span class="hljs-string">&quot;a[href]&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(e *colly.HTMLElement)</span></span> &#123;<br>link := e.Attr(<span class="hljs-string">&quot;href&quot;</span>)<br><span class="hljs-comment">//fmt.Printf(&quot;find link: %s\n&quot;, e.Request.AbsoluteURL(link))</span><br>c.Visit(e.Request.AbsoluteURL(link))<br>&#125;)<br><span class="hljs-comment">// 获取电影信息</span><br>c.OnHTML(<span class="hljs-string">&quot;div.info&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(e *colly.HTMLElement)</span></span> &#123;<br>e.DOM.Each(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>, selection *goquery.Selection)</span></span> &#123;<br>movies := selection.Find(<span class="hljs-string">&quot;span.title&quot;</span>).First().Text()<br>director := strings.Join(strings.Fields(selection.Find(<span class="hljs-string">&quot;div.bd p&quot;</span>).First().Text()), <span class="hljs-string">&quot; &quot;</span>)<br>quote := selection.Find(<span class="hljs-string">&quot;p.quote span.inq&quot;</span>).Text()<br>fmt.Printf(<span class="hljs-string">&quot;%d --&gt; %s:%s %s\n&quot;</span>, number, movies, director, quote)<br>number += <span class="hljs-number">1</span><br>&#125;)<br>&#125;)<br>c.OnError(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(response *colly.Response, err <span class="hljs-type">error</span>)</span></span> &#123;<br>fmt.Println(err)<br>&#125;)<br>  <span class="hljs-comment">// 最后我们调用c.Visit()开始访问第一个页面</span><br>c.Visit(<span class="hljs-string">&quot;https://movie.douban.com/top250?start=0&amp;filter=&quot;</span>)<br>c.Wait()<br>fmt.Printf(<span class="hljs-string">&quot;花费时间:%s&quot;</span>, time.Since(t))<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Step1-创建收集器"><a href="#Step1-创建收集器" class="headerlink" title="Step1 创建收集器"></a>Step1 创建收集器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">c := colly.NewCollector(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *colly.Collector)</span></span> &#123;<br>extensions.RandomUserAgent(c) <span class="hljs-comment">// 设置随机头</span><br>c.Async = <span class="hljs-literal">true</span><br>&#125;,<br><span class="hljs-comment">//过滤url,去除不是https://movie.douban.com/top250?start=0&amp;filter= 的url</span><br>colly.URLFilters(<br>      <span class="hljs-comment">// 正则表达</span><br>regexp.MustCompile(<span class="hljs-string">&quot;^(https://movie\\.douban\\.com/top250)\\?start=[0-9].*&amp;filter=&quot;</span>),<br>),<br>)<br></code></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221008140519140.png" style="zoom: 50%;" /><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20221008153946515.png" alt="image-20221008153946515"></p><h3 id="Step2-HTML回调"><a href="#Step2-HTML回调" class="headerlink" title="Step2 HTML回调"></a>Step2 HTML回调</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 响应的格式为HTML,提取页面中的链接</span><br>c.OnHTML(<span class="hljs-string">&quot;a[href]&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(e *colly.HTMLElement)</span></span> &#123;<br>link := e.Attr(<span class="hljs-string">&quot;href&quot;</span>)<br><span class="hljs-comment">//fmt.Printf(&quot;find link: %s\n&quot;, e.Request.AbsoluteURL(link))</span><br>c.Visit(e.Request.AbsoluteURL(link))<br>&#125;)<br><span class="hljs-comment">// 获取电影信息</span><br>c.OnHTML(<span class="hljs-string">&quot;div.info&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(e *colly.HTMLElement)</span></span> &#123;<br>e.DOM.Each(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>, selection *goquery.Selection)</span></span> &#123;<br>movies := selection.Find(<span class="hljs-string">&quot;span.title&quot;</span>).First().Text()<br>director := strings.Join(strings.Fields(selection.Find(<span class="hljs-string">&quot;div.bd p&quot;</span>).First().Text()), <span class="hljs-string">&quot; &quot;</span>)<br>quote := selection.Find(<span class="hljs-string">&quot;p.quote span.inq&quot;</span>).Text()<br>fmt.Printf(<span class="hljs-string">&quot;%d --&gt; %s:%s %s\n&quot;</span>, number, movies, director, quote)<br>number += <span class="hljs-number">1</span><br>&#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;hd&quot;</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://movie.douban.com/subject/1291546/&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>霸王别姬<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;other&quot;</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>/<span class="hljs-symbol">&amp;nbsp;</span>再见，我的妾  /  Farewell My Concubine<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;playable&quot;</span>&gt;</span>[可播放]<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bd&quot;</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>                            导演: 陈凯歌 Kaige Chen<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsqp;</span>主演: 张国荣 Leslie Cheung / 张丰毅 Fengyi Zha...<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>                            1993<span class="hljs-symbol">&amp;nbsp;</span>/<span class="hljs-symbol">&amp;nbsp;</span>中国大陆 中国香港<span class="hljs-symbol">&amp;nbsp;</span>/<span class="hljs-symbol">&amp;nbsp;</span>剧情 爱情 同性<br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>                        <br>                        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;star&quot;</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rating5-t&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rating_num&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;v:average&quot;</span>&gt;</span>9.6<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;v:best&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;10.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>2008403人评价<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;quote&quot;</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;inq&quot;</span>&gt;</span>风华绝代。<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Step3-错误处理，回调页面"><a href="#Step3-错误处理，回调页面" class="headerlink" title="Step3 错误处理，回调页面"></a>Step3 错误处理，回调页面</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">c.OnError(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(response *colly.Response, err <span class="hljs-type">error</span>)</span></span> &#123;<br>fmt.Println(err)<br>&#125;)<br>c.Visit(<span class="hljs-string">&quot;https://movie.douban.com/top250?start=0&amp;filter=&quot;</span>)<br>c.Wait()<br>fmt.Printf(<span class="hljs-string">&quot;花费时间:%s&quot;</span>, time.Since(t))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Colly</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第2章 寻址方式</title>
    <link href="/2022/09/12/%E7%AC%AC2%E7%AB%A0-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/09/12/%E7%AC%AC2%E7%AB%A0-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h1><h2 id="1-直接寻址"><a href="#1-直接寻址" class="headerlink" title="1.直接寻址"></a>1.直接寻址</h2>]]></content>
    
    
    <categories>
      
      <category>汇编语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第1章 预备知识</title>
    <link href="/2022/09/03/%E7%AC%AC1%E7%AB%A0-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/09/03/%E7%AC%AC1%E7%AB%A0-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="第1章预备知识"><a href="#第1章预备知识" class="headerlink" title="第1章预备知识"></a>第1章预备知识</h1><h2 id="1-1-机器语言与汇编语言"><a href="#1-1-机器语言与汇编语言" class="headerlink" title="1.1 机器语言与汇编语言"></a>1.1 机器语言与汇编语言</h2><h3 id="1-1-1-机器语言"><a href="#1-1-1-机器语言" class="headerlink" title="1.1.1 机器语言"></a>1.1.1 机器语言</h3><p>机器指令：操作码 + 地址码</p><p>指令的全体为计算机的<strong>指令系统</strong></p><p>指令集合为<strong>机器语言</strong></p><p><strong>机器语言程序</strong></p><h3 id="1-1-2-汇编语言"><a href="#1-1-2-汇编语言" class="headerlink" title="1.1.2 汇编语言"></a>1.1.2 汇编语言</h3><p><strong>助记符</strong>表示机器指令的<strong>操作码</strong>；用变量代替操作数的<strong>存放地址</strong>；在指令前冠以<strong>标号</strong>， 用来代表该指令的存放地址等。 </p><p><strong>指令助记符、语句标号、数据变量、伪指令</strong>及它们的使用规则构成了整个汇编语言的内容。</p><h2 id="1-2-Intel系列机"><a href="#1-2-Intel系列机" class="headerlink" title="1.2 Intel系列机"></a>1.2 Intel系列机</h2><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220903152705420.png" alt="image-20220903152705420"></p><h3 id="1-2-1-Intel-80X86-微处理器简介"><a href="#1-2-1-Intel-80X86-微处理器简介" class="headerlink" title="1.2.1 Intel 80X86 微处理器简介"></a>1.2.1 Intel 80X86 微处理器简介</h3><p><strong>8086</strong>:16位CPU</p><p><strong>80286</strong>:直接寻址16MB贮存，含有四个独立处理部件：执行部件、总线部件、指令部件和地址部件</p><p>提供两种工作方式：<strong>实地址方式和保护方式</strong></p><h3 id="1-2-2-Intel-80X86微处理结构"><a href="#1-2-2-Intel-80X86微处理结构" class="headerlink" title="1.2.2 Intel 80X86微处理结构"></a>1.2.2 Intel 80X86微处理结构</h3><p>32位CPU分为六大部件：</p><ul><li>总线接口部件</li><li>执行部件</li><li>指令预取部件</li><li>指令编译部件</li><li>分段部件</li><li>分页部件</li></ul><h4 id="1-总线接口部件"><a href="#1-总线接口部件" class="headerlink" title="1.总线接口部件"></a>1.总线接口部件</h4><p>CPU与整个计算机系统之间的高速接口</p><p>接受总线请求，按有限权进行选择，最大限度利用本身资源位请求服务</p><h4 id="2-执行部件"><a href="#2-执行部件" class="headerlink" title="2.执行部件"></a>2.执行部件</h4><h5 id="（1）数据寄存器组-EAX、EBX、ECX、EDX"><a href="#（1）数据寄存器组-EAX、EBX、ECX、EDX" class="headerlink" title="（1）数据寄存器组(EAX、EBX、ECX、EDX)"></a>（1）数据寄存器组(EAX、EBX、ECX、EDX)</h5><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220903154542135.png" alt="image-20220903154542135"></p><p>EAX(Accumulator)：暂存</p><p>EBX(Base):</p><p>ECX(Count)：标志循环次数上届</p><p>EDX(Data):保存操作数</p><h5 id="2-指示器编制寄存器组-ESI、EDI、ESP、EBP"><a href="#2-指示器编制寄存器组-ESI、EDI、ESP、EBP" class="headerlink" title="(2)指示器编制寄存器组(ESI、EDI、ESP、EBP)"></a>(2)指示器编制寄存器组(ESI、EDI、ESP、EBP)</h5><p>存放操作数的偏移地址，用作指示器或变址寄存器。</p><ul><li>ESP：堆栈指示器，栈顶指针</li><li>EBP：基址寄存器，存放存储单元的偏移地址</li><li>ESI和EDI:指示器、变址寄存器</li><li>ESI用作取源操作数的指示器，源变址寄存器</li><li>EDI用作送目的操作数的指示器，目的变址寄存器</li></ul><h4 id="3-指令预取部件和指令译码部件"><a href="#3-指令预取部件和指令译码部件" class="headerlink" title="3.指令预取部件和指令译码部件"></a>3.指令预取部件和指令译码部件</h4><ul><li>指令<strong>预取</strong>部件：把<strong>将要执行</strong>的指令从主存之中取出，送入指令排队机构中排队（此处为复杂的排队系统）</li><li>指令<strong>译码</strong>部件：从预取指令队列中读<strong>出指令并译码</strong>，再送入译码指令队列排队供执行部件使用</li></ul><p>独取指令时，用到很重要的寄存器——<strong>指令指示器</strong></p><p>保存下一条将要被CPU执行的指令的偏移地址（EA）</p><p>16位代码段之中，指令指示器也为16位，称为IP，可以表示64k的偏移地址</p><p>32位代码段之中，EIP，表示4G的偏移地址</p><h4 id="4-分段部件、分页部件"><a href="#4-分段部件、分页部件" class="headerlink" title="4.分段部件、分页部件"></a>4.分段部件、分页部件</h4><p>程序投入运行时，系统会为每个程序分配一片独立的虚拟内存空间</p><p>只有主存中的程序和数据才能够被访问，所以在执行某一程序或访问某一数据，必须要将其所在的虚拟空间映射到物理存储空间</p><p>32位CPU使用<strong>分段部件</strong>和<strong>分页部件</strong>实现这一映射</p><p><strong>分段部件</strong>用于将各段<strong>二维</strong>的逻辑地址转换为<strong>一维</strong>的线性地址， 从而完成从<strong>虚拟空间</strong>到<strong>线性空间</strong>的转换， 实现系统与用户、用户与用户之间的隔离与共享。</p><p>分段部件有 ６ 个 １６ 位的段寄存器， 它们分别是：</p><p>ＣＳ———代码段寄存器；</p><p>ＳＳ———堆栈段寄存器；</p><p>ＤＳ———数据段寄存器；</p><p>ＥＳ、ＦＳ、ＧＳ———附加数据段寄存器。</p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220903204235387.png" alt="image-20220903204235387" style="zoom:33%;" /><p>实方式下，段的大小最大只能为64KB，取数据或指令的物理地址<strong>直接通过段寄存器的内容和EＡ生成</strong></p><p>保护方式下，段大小可达4GB，这时的段寄存器内容称为<strong>选择符</strong>，通过该选择符找到描述符表，取出描述符后才能确定所需访问的段和存储单元</p><ul><li>分段部件构造虚拟存储空间</li><li>分页部件则主要用于物理存储器的管理</li></ul><h3 id="1-2-3-80X86的3种工作方式"><a href="#1-2-3-80X86的3种工作方式" class="headerlink" title="1.2.3  80X86的3种工作方式"></a>1.2.3  80X86的3种工作方式</h3><h4 id="1-实地址方式"><a href="#1-实地址方式" class="headerlink" title="1.实地址方式"></a>1.实地址方式</h4><p>32位寄存器、32位操作数、32位寻址方式</p><p>32位CPU和16位CPU只能寻址1MB物理存储空间，程序段段大小不超过64KB</p><p>段基址和偏移地址都是32位（16位段）</p><h4 id="2-保护方式"><a href="#2-保护方式" class="headerlink" title="2.保护方式"></a>2.保护方式</h4><p>32位地址先，寻址4GB的物理存储空间，虚拟存储空看可达64TB</p><p>段基址和段内偏移量都是32位，程序段的大小可达4GB，这样的段也称为“32位”。</p><h4 id="3-保护方式下的虚拟8086方式（V86方式）"><a href="#3-保护方式下的虚拟8086方式（V86方式）" class="headerlink" title="3.保护方式下的虚拟8086方式（V86方式）"></a>3.保护方式下的虚拟8086方式（V86方式）</h4><p>保护方式下运行的类似实方式的工作环境</p><p>对于80X86中的32位ＣＰＵ，在实方式下执行的是16位段的程序(寄存器和数据可以是 32&#x2F;16位);在保护方式下可以对 32位段和 16位段的程序单独或混合操作；</p><p>虚 拟 8086方式可并行执行多个 8086的16位段程序，但由于它与实方式的特权级不同，因此，它还不能代替实方式。 </p><h2 id="1-3-主存储器和物地址的形成"><a href="#1-3-主存储器和物地址的形成" class="headerlink" title="1.3 主存储器和物地址的形成"></a>1.3 主存储器和物地址的形成</h2><h3 id="1-3-1主存储器"><a href="#1-3-1主存储器" class="headerlink" title="1.3.1主存储器"></a>1.3.1主存储器</h3><p><strong>存储器</strong>是用来存放程序和数据的装置</p><p><strong>主存</strong>设在主机内部，用来存放当前运行的程序和所需的数据，一边随时像CPU高速提供信息</p><p>主存由许多存储位构成，这些储存位<strong>每8位</strong>组合成<strong>一个字节</strong>，</p><p>每相邻的<strong>2个字节</strong>又可以组成一个<strong>字</strong>，</p><p>相邻的<strong>2个字</strong>有可以组成一个<strong>双字</strong>。</p><h4 id="区分不同字节存储单元："><a href="#区分不同字节存储单元：" class="headerlink" title="区分不同字节存储单元："></a><strong>区分不同字节存储单元</strong>：</h4><h5 id="物理地址-PA"><a href="#物理地址-PA" class="headerlink" title="物理地址(PA):"></a>物理地址(PA):</h5><p>​每一单元被指定一个编号，用以区分不同字节存储单元。</p><p>​80X86机的主存是按8位字节编址的，即以字节为最小寻址单位。</p><p>字由相邻两个字节组成，规定字地址由2个字节中较小的确定</p><p>双字地址由4个字节的最低地址确定</p><p>存放在主存中的程序和数据一般均按<strong>物理地址</strong>存取</p><p><strong>字数据</strong>低8位存放在低地址字节中，高8位存放在相邻的高地址字节中；<strong>双字数据</strong>存放是低16位存放在低地址字中，高16位存放在相邻的高地址字中。</p><h3 id="1-3-2-堆栈"><a href="#1-3-2-堆栈" class="headerlink" title="1.3.2 堆栈"></a>1.3.2 堆栈</h3><p><strong>先进后出</strong>原则，进栈为“压入”，出栈为“弹出”。</p><p>堆栈由一片<strong>存储单元</strong>和一个<strong>指示器</strong>组成，固定端叫做<strong>栈底</strong></p><ul><li><strong>栈指针</strong>：用来指示栈元素进栈和出栈时偏移地址的变化</li><li><strong>栈顶</strong>：指针所指示的最后存入数据的单元</li></ul><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220903204213353.png" alt="image-20220903204213353" style="zoom:33%;" /><h4 id="1-进栈指令PUSH"><a href="#1-进栈指令PUSH" class="headerlink" title="1.进栈指令PUSH"></a>1.进栈指令PUSH</h4><p>语句格式：PUSH OPS</p><p>功能：将立即数或寄存器、段寄存、存储器中的一个字&#x2F;双字数据压入堆栈中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">PUSH 04F8H<br>执行前:(SP)=1000H<br>执行：(SP)-2 -&gt;SP<br>04F8H-&gt;[SP]<br></code></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220903205005287.png" alt="image-20220903205005287" style="zoom:33%;" /><h4 id="2-出栈指令POP"><a href="#2-出栈指令POP" class="headerlink" title="2.出栈指令POP"></a>2.出栈指令POP</h4><p>语句格式：POP OPD</p><p>功能：将栈顶元素弹出送至某一寄存器、段寄存器或存储器中。</p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220903205642816.png" alt="image-20220903205642816" style="zoom: 33%;" /><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">POP</span> <span class="hljs-built_in">BX</span><br>执行前:<span class="hljs-keyword">POP</span> <span class="hljs-built_in">BX</span><br>执行:([<span class="hljs-built_in">SP</span>])-&gt;<span class="hljs-built_in">BX</span><br>(<span class="hljs-built_in">SP</span>)+<span class="hljs-number">1</span>-&gt;<span class="hljs-built_in">SP</span><br>执行后:(<span class="hljs-built_in">BX</span>)=<span class="hljs-number">04F8H</span><span class="hljs-comment">;(SP)=1000H</span><br></code></pre></td></tr></table></figure><p>除了PUSH和POP指令外，如果其他指令要访问堆栈，也可以通过基址寄存器BP进行</p><p><strong>注意</strong>:</p><ol><li>当堆栈段为16位段时，系统自动使用SP作栈指针；32位，使用ESP</li><li>进栈或出栈操作时，**栈指针(SP&#x2F;ESP)**移动的字节数取决于操作数的类型。字操作，(SP&#x2F;ESP)均是±2，双字操作，(SP&#x2F;ESP)均为±4</li></ol><h4 id="3-将8个寄存器内容顺序入栈指令"><a href="#3-将8个寄存器内容顺序入栈指令" class="headerlink" title="3.将8个寄存器内容顺序入栈指令"></a><del>3.将8个寄存器内容顺序入栈指令</del></h4><p><del>该指令分为<strong>8个16位寄存器</strong>入栈和对<strong>8个32位寄存器</strong>入栈</del></p><h5 id="1-将8个16位寄存器入栈"><a href="#1-将8个16位寄存器入栈" class="headerlink" title="(1)将8个16位寄存器入栈"></a><del>(1)将8个16位寄存器入栈</del></h5><p><del>语句格式：PUSHA</del></p><p><del>功能：将8个16位寄存器按AX、CX、DX、BX、SP、BP、SI、DI顺序入栈保存</del></p><h3 id="1-3-3-物理地址的形成"><a href="#1-3-3-物理地址的形成" class="headerlink" title="1.3.3 物理地址的形成"></a>1.3.3 物理地址的形成</h3><p>80X86机，最低档CPU为8086，20根地址线，寻址能力为$2^{20}B$，主内存容量为1MB，物理地址编号从0~0FFFFFH。</p><p>此时CPU与存储器交换信息必须要<strong>20位的物理地址</strong>，但是8086内部为<strong>16位结构</strong>，寄存器也是16位的。</p><p>16位寄存器进行地址运算，表示16位地址，<strong>操作数范围最大为64KB</strong>。</p><h4 id="主存分段使用方案："><a href="#主存分段使用方案：" class="headerlink" title="主存分段使用方案："></a>主存分段使用方案：</h4><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220904155556771.png" alt="image-20220904155556771" style="zoom:33%;" /><p>将1MB的存储器<strong>按64KB分段</strong>，设置4个段寄存器CS、DS、SS、ES，保存当前可使用段的段首址。</p><p>段首址从刚好被<strong>16整除</strong>的地址开始，<strong>低四位均为0</strong>，忽略这些0，刚好16位可以存入段寄存器之中，然后操作时，内容左移4位，补上4个0，再加上某待访问存储单元的偏移地址，获得20位物理地址。</p><p>存储单元的地址由两部分组成：<strong>段首地址：偏移地址</strong>，被称为<strong>二维的逻辑地址</strong></p><h4 id="1-实方式物理地址的形成"><a href="#1-实方式物理地址的形成" class="headerlink" title="1. 实方式物理地址的形成"></a>1. 实方式物理地址的形成</h4><p>实方式情况下，32位CPU只能寻址1MB的物理存储空间，采用分段使用的方式，每段大小不超过64KB，段首地址和段内偏移地址都用16位表示。</p><p>在每一给定时刻，CPU可以在不修改段寄存器内容的情况下访问6个段：</p><ul><li>代码段</li><li>堆栈段</li><li>数据段</li><li>3个附加数据段</li></ul><p>这些当前能被CPU访问段的首地址由分段部件中的6个专用段寄存器给出</p><ul><li><p>CS：给出当前代码段首地址（取指令指针为IP）</p></li><li><p>SS：给出当前堆栈段首地址（取栈指针为SP）</p></li><li><p>DS：给出当前数据段首地址</p></li><li><p>ES、FS、GS：给出当前附加数据段首地址</p></li><li><p><strong>代码段</strong>是程序代码的存储区，指令指示器IP总是保存着下一条将要取出指令相对于<strong>CS</strong>的偏移地址在<strong>代码段中取指令</strong>时，指令物理地址：</p></li></ul><p>​$PA &#x3D; (CS)_{左移4位}+(IP)$</p><ul><li><p><strong>堆栈段</strong>时程序的<strong>临时数据存储区</strong>，存放暂时无用的数据。用户自定义堆栈段，作子程序调用、系统功能调用、中断处理等操作。系统以<strong>SP</strong>为指针，做堆栈操作时，栈顶物理地址：</p><p>​$PA &#x3D; (SS)_{左移4位}+(SP)$</p></li><li><p><strong>数据段和附加数据段</strong>是程序<strong>使用时</strong>的数据存储区。附加数据段和数据段重合，设置成一个段，数据的物理地址：</p><p>​$PA &#x3D; (DS或ES、FS、GS)_{左移4位}+16位偏移地址$</p></li></ul><h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5><ul><li><p>程序大小可以自定，但是必须要小于或等于64KB，每个段在主存的具体位置由操作系统分配</p></li><li><p>分段不唯一，某一片具体存储单元，可以属于一个段，也可以属于多个段</p></li><li><p>汇编源程序之中，用户必须将数据段首址置入DS、ES、FS、GS，而CS、SS由系统自动录入</p></li></ul><h4 id="2-保护方式下物理地址的形成"><a href="#2-保护方式下物理地址的形成" class="headerlink" title="2.保护方式下物理地址的形成"></a>2.保护方式下物理地址的形成</h4><p>保护方式，使用32根地址线，可以寻址4GB物理存储空间，程序大小也可达到4GB，段基址和段内偏移地址都为32位。</p><p><strong>多任务机制</strong>：对虚拟存储空间的任务进入主存进行合理调度和分配，实施执行环境的<strong>隔离和保护</strong>。</p><h5 id="1-特权级"><a href="#1-特权级" class="headerlink" title="(1) 特权级"></a>(1) 特权级</h5><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20220904210520629.png" alt="image-20220904210520629"></p><h5 id="2-描述符"><a href="#2-描述符" class="headerlink" title="(2) 描述符"></a>(2) 描述符</h5><p>除了段基址以外，其余信息被整合到一起，用4个字来描述，被称为<strong>描述符</strong></p><p>按不同的描述对象，可分为：</p><ul><li>存储段描述符</li><li>系统段描述符</li><li>控制描述符</li></ul><h6 id="描述符通用结构"><a href="#描述符通用结构" class="headerlink" title="描述符通用结构"></a>描述符通用结构</h6><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20220904211612369.png" alt="image-20220904211612369"></p><ul><li><p>32位段基址（不分页，该基地址为段在主存的起始物理地址）</p></li><li><p>20位段界限（段长度）</p></li><li><p>第三个字的高字节描述了段的性质及当前使用情况</p><ul><li><p><strong>P</strong>：存在为，P&#x3D;1，描述符对应段存在，P&#x3D;0，不存在</p></li><li><p><strong>DPL</strong>：描述符对应段的特权级</p></li><li><p><strong>S</strong>：段类型，S&#x3D;1，存储段描述符（程序代码段、数据段），S&#x3D;0，存储系统描述符</p></li><li><p><strong>TYPE</strong>：段的具体属性，共有三位。对存储段来说， 第 11位<strong>E</strong>描述了该段<strong>是否为可执行段</strong>。 Ｅ ＝０ 说明该段为不可执行段， 即为数据段或堆栈段；Ｅ ＝１ 说明该段为可执行段， 即为代码段。</p><p> 在两种不同类型的段中， 另两位（第 １０ ～９ 位）所描述的内容是不同的</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20220904212532573.png" alt="image-20220904212532573"></p></li><li><p><strong>A</strong>：已访问位</p></li></ul></li><li><p>第四个字7~4描述信息</p><ul><li><strong>G</strong>：粒度位  Ｇ ＝０ 时说明段长度的计量单位为字节(B)；Ｇ ＝１ 时说明段长度的计量单位为页， １ 页为 ４KB。</li><li><strong>D</strong>：D&#x3D;0，16位操作数和16位有效地址，堆栈使用SP作指针，界限值0FFFFH；D&#x3D;1，32位操作数和32位有效地址， 堆栈使用ESP指针，界限值0FFFFFFFFH。剩余两位为保留位和系统专用位。</li></ul></li></ul><h5 id="3-描述符表"><a href="#3-描述符表" class="headerlink" title="(3)描述符表"></a>(3)描述符表</h5><ul><li>局部描述符表</li><li>全局描述符表</li><li>中断描述符表</li></ul><h5 id="4-段选择符和描述符寄存器"><a href="#4-段选择符和描述符寄存器" class="headerlink" title="(4)段选择符和描述符寄存器"></a>(4)段选择符和描述符寄存器</h5><p>保护方式下，段寄存器不保存段的开始地址，从描述符表中选择相应段的描述符的方式。</p><h6 id="段选择符"><a href="#段选择符" class="headerlink" title="段选择符"></a>段选择符</h6><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20220904213647690.png" alt="image-20220904213647690" style="zoom:33%;" /><h5 id="5-保护方式下物理地址的形成"><a href="#5-保护方式下物理地址的形成" class="headerlink" title="(5)保护方式下物理地址的形成"></a>(5)保护方式下物理地址的形成</h5><ol><li>根据段寄存器中的描述符索引值、TI及RPL值，从描述符表中选出描述符，然后判断是否有溢出，进行特权级、使用合法性及各种相关属性检查，合格之后送入对应描述符高速缓冲寄存器。</li><li>需要对该段存储空间访问时，从描述符高速缓冲寄存器中取出段基址，与存放于EIP&#x2F;ESP或某一指示器中的偏移地址相加，形成32位线性地址。</li><li>不分页，则得到物理地址；分页的话，经过分页部件映射，将线性地址转换为物理地址。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20220904214102185.png" alt="image-20220904214102185"></p><h2 id="1-4数据在计算机内的表示形式"><a href="#1-4数据在计算机内的表示形式" class="headerlink" title="1.4数据在计算机内的表示形式"></a>1.4数据在计算机内的表示形式</h2><ul><li>二进制<ul><li>字节</li><li>字</li><li>双字</li><li>三字</li><li>四字</li><li>十字</li></ul></li><li>八进制</li><li>十六进制</li><li>BCD码</li></ul><h3 id="1-4-1-数值数据在计算机内的表示形式"><a href="#1-4-1-数值数据在计算机内的表示形式" class="headerlink" title="1.4.1 数值数据在计算机内的表示形式"></a>1.4.1 数值数据在计算机内的表示形式</h3><ul><li>定点表示法</li><li>浮点表示法</li></ul><p>有符号数一律采用二进制补码</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20220905162139363.png" alt="image-20220905162139363"></p><p>计算机在进行<strong>算术逻辑运算时</strong>， 总是把参与运算的、用补码表示的操作数作为无符号数处理， 这时， 数的表示范围则与前面讨论的完全不同。</p><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20220905162310714.png" alt="image-20220905162310714"></p><h3 id="1-4-2-BCD码"><a href="#1-4-2-BCD码" class="headerlink" title="1.4.2 BCD码"></a>1.4.2 BCD码</h3><p>利用4位二进制表示十进制数</p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20220905162515343.png" alt="image-20220905162515343" style="zoom: 50%;" /><p>BCD码：</p><ul><li><p>未压缩的BCD码</p><ul><li>每个字节只放一个十进制位数</li></ul></li><li><p>压缩的BCD码</p><ul><li>一个字节存放两个十进制位数</li></ul><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20220905162706328.png" alt="image-20220905162706328" style="zoom:50%;" /></li></ul><h3 id="1-4-3-字符数据在机内的表示形式"><a href="#1-4-3-字符数据在机内的表示形式" class="headerlink" title="1.4.3 字符数据在机内的表示形式"></a>1.4.3 字符数据在机内的表示形式</h3><p>$ASCII$码标准</p><h2 id="1-5-标志寄存器"><a href="#1-5-标志寄存器" class="headerlink" title="1.5 标志寄存器"></a>1.5 标志寄存器</h2><p><strong>标志寄存器</strong>：保存在一条指令执行之后， ＣＰＵ 所处状态的信息及运算结果的特征。</p><p>16位CPU中的标志寄存器是16位的，称为FLAGS，32位CPU中的标志寄存器是32位的，称EFLAGS</p><p>32位向下兼容</p><h3 id="1-5-1-标志位"><a href="#1-5-1-标志位" class="headerlink" title="1.5.1 标志位"></a>1.5.1 标志位</h3><p><img src="https://cdn.jsdelivr.net/gh/Hyeonwuu/Image/image-20220905170358493.png" alt="image-20220905170358493"></p><p>常用标志位：</p><ul><li>条件标志位</li><li>控制标志位</li><li>32位寄存器扩充的系统标志位</li></ul><h4 id="1-条件标志位"><a href="#1-条件标志位" class="headerlink" title="1.条件标志位"></a>1.条件标志位</h4><p>由CPU根据执行完一条指令后所得运算结果的特征自动设置的，主要用作控制条件转移指令是否转移的条件。</p><ul><li>符号标志SF（第7位）</li><li>零标志符ZF（第6位）</li><li>溢出标志OF（第11位）</li><li>进位标志CF（第0位）</li><li>辅助进位标志AF（第4位）</li><li>奇偶标志位PF（第2位）</li></ul><h4 id="2-控制标志位"><a href="#2-控制标志位" class="headerlink" title="2.控制标志位"></a>2.控制标志位</h4><ul><li>方向标志DF</li><li>中断允许标志IF</li><li>跟踪标志TF</li></ul><h4 id="3-32-位标志寄存器扩充的系统标志位"><a href="#3-32-位标志寄存器扩充的系统标志位" class="headerlink" title="3.32 位标志寄存器扩充的系统标志位"></a>3.32 位标志寄存器扩充的系统标志位</h4><ul><li>IO 特权标志 IOPL</li><li>占两位，指定了要求执行I&#x2F;O指令的特权级</li><li>嵌套任务标志 NT<ul><li>控制中断返回指令的执行</li></ul></li><li>恢复标志RF<ul><li>与寄存器一起使用，确定是否接受调试故障</li></ul></li><li>虚拟8086方式标志VM<ul><li>VM置1，CPU在虚拟8086方式下工作，置0，保护方式下工作</li></ul></li></ul><h3 id="1-5-2标志寄存器操作指令"><a href="#1-5-2标志寄存器操作指令" class="headerlink" title="1.5.2标志寄存器操作指令"></a>1.5.2标志寄存器操作指令</h3><h4 id="1-标志寄存器传送指令"><a href="#1-标志寄存器传送指令" class="headerlink" title="1.标志寄存器传送指令"></a>1.标志寄存器传送指令</h4><h5 id="1-LAHF"><a href="#1-LAHF" class="headerlink" title="(1)LAHF"></a>(1)LAHF</h5><p>功能：将标志寄存器低8位存入AH中，即$(EFALGS){7~0} \rightarrow AH$</p><h5 id="2-SAHF"><a href="#2-SAHF" class="headerlink" title="(2)SAHF"></a>(2)SAHF</h5><p>功能：将AH中的内容送入标志寄存器的低8位之中，高位保持不变。</p><h4 id="2-32位标志寄存器进栈指令PUSHFD"><a href="#2-32位标志寄存器进栈指令PUSHFD" class="headerlink" title="2.32位标志寄存器进栈指令PUSHFD"></a>2.32位标志寄存器进栈指令PUSHFD</h4><p>功能：将标志寄存器的内容压入堆栈之中</p><p>​$(EFLAGS)\rightarrow \downarrow(ESP&#x2F;SP) $</p><h4 id="3-32位标志寄存器出栈指令POPFD"><a href="#3-32位标志寄存器出栈指令POPFD" class="headerlink" title="3.32位标志寄存器出栈指令POPFD"></a>3.32位标志寄存器出栈指令POPFD</h4><p>功能：$\uparrow(ESP&#x2F;SP)\rightarrow EFLAGS$</p><p>说明：该指令不影响标志位RF、VM、IOPL、VIF、VIP和未定义位。</p>]]></content>
    
    
    <categories>
      
      <category>汇编语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>go项目部署到linxu</title>
    <link href="/2022/08/08/go%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0linxu/"/>
    <url>/2022/08/08/go%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0linxu/</url>
    
    <content type="html"><![CDATA[<h1 id="go项目部署到linxu"><a href="#go项目部署到linxu" class="headerlink" title="go项目部署到linxu"></a>go项目部署到linxu</h1><p>2020-09-27阅读 4390</p><p>环境: 在<code>mac</code>上编译, 编译后上传到<code>linux</code>, 然后运行代码</p><p><strong><code>go</code>项目打包</strong></p><p>一、直接部署到<code>linux</code></p><ol><li><p>在mac上, 进入到项目目录, 执行以下命令</p><p><code>CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go</code></p></li></ol><p>, 进行编译: , 生成一个main文件. </p><ol start="2"><li>将main文件上传到linux任意目录下, 执行<code> nohup ./main &amp;运行项目</code>. 如果出错, 则查看日志即可</li></ol><p>二. 通过nginx部署</p><p><code> **beego</code>项目打包**</p><p> 环境: 本地开发是<code>mac</code>, 部署到<code>linux</code></p><ol><li><p>在mac上, 进入到项目目录, 执行: <code>bee pack -be GOOS=linux </code>进行打包, 打包成功后, 会生成一个<code>****.tar.gz</code>的文件.</p></li><li><p>在<code>linux</code>的某一个目录下创建一个新的文件夹(一定要创建, 否则会解压到根目录), 将<code>***tar.gz</code>文件上传到<code>linux</code>. </p></li><li><p>解压<code> tar -xvzf xxxx.tar.gz</code></p></li><li><p>分配权限: <code>sudo chmod 777 xxxx</code></p></li><li><p>运行可执行文件<code>. nohup ./**** &amp;  </code>成功</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>M1 配置numpy和scipy</title>
    <link href="/2022/08/06/M1-%E9%85%8D%E7%BD%AEnumpy%E5%92%8Cscipy/"/>
    <url>/2022/08/06/M1-%E9%85%8D%E7%BD%AEnumpy%E5%92%8Cscipy/</url>
    
    <content type="html"><![CDATA[<h1 id="1-安装anaconda"><a href="#1-安装anaconda" class="headerlink" title="1. 安装anaconda"></a>1. 安装<a href="https://www.anaconda.com/products/distribution">anaconda</a></h1><p>命令行安装</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/v2-5dd0d5f450efafa2c036bd094bfc127c_1440w.jpg" alt="img"></p><p>下载完成后，打开terminal，输入bash空格后，直接将下载的文件拖到terminal里面，会直接转换成当前文件所在的路径，然后回车：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">bash /Users/yourname/Downloads/Anaconda3-2022.05-MacOSX-arm64.sh <br></code></pre></td></tr></table></figure><p>然后一直回车，后面的选项建议都是yes，就不要自己改动了。</p><h1 id="2-创建新环境"><a href="#2-创建新环境" class="headerlink" title="2.创建新环境"></a>2.创建新环境</h1><p>安装好arm64版本的anaconda后，先创建一个新环境，在terminal中输入</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">conda create -n EnvName python=3.8<br></code></pre></td></tr></table></figure><h2 id="报错："><a href="#报错：" class="headerlink" title="报错："></a>报错：</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">zsh：<span class="hljs-keyword">command</span> not <span class="hljs-keyword">find</span>:conda<br></code></pre></td></tr></table></figure><h2 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h2><h3 id="1-检查是否安装conda"><a href="#1-检查是否安装conda" class="headerlink" title="1.检查是否安装conda"></a>1.检查是否安装<code>conda</code></h3><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220806153339601.png" alt="image-20220806153339601"></p><p>在<code>bin</code>目录下查看是否有conda</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> bin<br><span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220806153501459.png" alt="image-20220806153501459"></p><h3 id="2-文件夹有conda，但是显示zsh-command-not-find-conda"><a href="#2-文件夹有conda，但是显示zsh-command-not-find-conda" class="headerlink" title="2.文件夹有conda，但是显示zsh:command not find:conda"></a>2.文件夹有<code>conda</code>，但是显示<code>zsh:command not find:conda</code></h3><p>需要修改.zshrc这个文件中的路径。</p><blockquote><p>.zshrc是什么 ：The individual per-interactive-shell startup file<br> 简单来说它是linux文件夹的一个配置文件，这个文件主要保存个人的一些个性化设置，比如命名别名、路径等。</p></blockquote><h3 id="3-打开终端，修改路径"><a href="#3-打开终端，修改路径" class="headerlink" title="3.打开终端，修改路径"></a>3.打开终端，修改路径</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-symbol">wuyuxian@</span>wuyuxiandeMacBook-Pro ~ % vim ~/.zshrc<br></code></pre></td></tr></table></figure><p>最后一行加入</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">export PATH=<span class="hljs-regexp">/home/u</span>sername<span class="hljs-regexp">/anaconda/</span>bin:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220810114603506.png" alt="image-20220810114603506"></p><h3 id="4-使文件生效"><a href="#4-使文件生效" class="headerlink" title="4.使文件生效"></a>4.使文件生效</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></td></tr></table></figure><h3 id="5-检验生效"><a href="#5-检验生效" class="headerlink" title="5.检验生效"></a>5.检验生效</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">conda <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220806153923541.png" alt="image-20220806153923541"></p><h2 id="继续："><a href="#继续：" class="headerlink" title="继续："></a>继续：</h2><p>终端输入:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">conda</span> create -n EnvName python=<span class="hljs-number">3</span>.<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>中间的EnvName为环境名称，可以自己设置</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220806154153604.png" alt="image-20220806154153604"></p><p>然后激活这个环境：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">conda activate EnvName<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220806154212919.png" alt="image-20220806154212919"></p><h1 id="3-安装numpy"><a href="#3-安装numpy" class="headerlink" title="3.安装numpy"></a>3.安装<code>numpy</code></h1><p>第一步：由于我们需要自己编译numpy，所以先下载cython和pybind11</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">pip install cython pybind11<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220806154350218.png" alt="image-20220806154350218"></p><p>第二步：安装numpy</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">pip install --no-binary :all: --no-use-pep517 numpy<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220806154859018.png" alt="image-20220806154859018"></p><p>安装完成之后可以打开Python，import numpy as np后输入</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">np.show_config()<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220806155255881.png" alt="image-20220806155255881"></p><p>成功：</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220806155334825.png" alt="image-20220806155334825"></p><h1 id="4-安装scipy"><a href="#4-安装scipy" class="headerlink" title="4.安装scipy"></a>4.安装<code>scipy</code></h1><p>前提：安装<code>homebrew</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> pythran<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220806155807546.png" alt="image-20220806155807546"></p><p>然后再安装这两个package</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">brew install openblas gfortran<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220806161015913.png" alt="image-20220806161015913"></p><p>因为scipy是依赖fortran和BLAS&#x2F;LACK的，因此我们要先安装上面两个</p><p>并且设置OPENBLAS的路径：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">export OPENBLAS=<span class="hljs-regexp">/opt/</span>homebrew<span class="hljs-regexp">/opt/</span>openblas<span class="hljs-regexp">/lib/</span><br></code></pre></td></tr></table></figure><p>这时就可以安装numpy了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 install --no-binary :all: --no-use-pep517 numpy<br></code></pre></td></tr></table></figure><p>然后就可以安装scipy了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 install --no-binary :all: --no-use-pep517 scipy<br></code></pre></td></tr></table></figure><p>以上寄掉，可以试试conda</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220806170404370.png" alt="image-20220806170404370"></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>numpy spicy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学规划</title>
    <link href="/2022/08/05/%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92/"/>
    <url>/2022/08/05/%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="数学规划模型"><a href="#数学规划模型" class="headerlink" title="数学规划模型"></a>数学规划模型</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="（1）什么是数学规划"><a href="#（1）什么是数学规划" class="headerlink" title="（1）什么是数学规划"></a>（1）什么是数学规划</h3><p>数学规划是运筹学 的 ⼀个 分⽀ , 其⽤来研究: 在 给定的条件 下 (约束条件),如何按照某 ⼀衡量指标 (⽬标函数) 来寻求计划、管理⼯作中的最优⽅案 。 </p><p>&#x3D;&#x3D;&#x3D;&gt;求 ⽬标函数 在 ⼀定约束条件 下 的极值问题 。</p><p>​例⼦ : 数学⾼考试卷 中的 线性规划 ⼤题 </p><h3 id="2-数学规划的一般形式"><a href="#2-数学规划的一般形式" class="headerlink" title="(2) 数学规划的一般形式"></a>(2) 数学规划的一般形式</h3><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220805212036714.png" alt="image-20220805212036714"></p><h3 id="3-数学规划的分类"><a href="#3-数学规划的分类" class="headerlink" title="(3) 数学规划的分类"></a>(3) 数学规划的分类</h3><h4 id="①-线性规划-Liner-programming"><a href="#①-线性规划-Liner-programming" class="headerlink" title="① 线性规划 ( Liner programming)"></a>① 线性规划 ( Liner programming)</h4><p>如果<strong>⽬标函数</strong>$$f(x)$$和<strong>约束条件</strong>均是决策变量的线性表达式 , 那么 此时的 数学规划问题就属于线性规划 。 </p><p>1947年 ,美国数学家丹⻬格 ( GB.Dantz.in)提出了求解线性规划的<strong>单纯形法</strong> ,奠定了这⻔学科的基础。</p><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220805212912821.png" alt="image-20220805212912821"></h3><h4 id="②-⾮线性规划-nonlinear-pogramming"><a href="#②-⾮线性规划-nonlinear-pogramming" class="headerlink" title="② ⾮线性规划 ( nonlinear pogramming)"></a>② ⾮线性规划 ( nonlinear pogramming)</h4><p>当⽬标函数和或者约束条件中有⼀个是<strong>决策变量ㄨ的⾮线性表达式</strong> , 那么此时的数学规划问题就属于<strong>⾮线性规划</strong> 。解决⾮线性规划要⽐线性规划困难得多,⽬前没有通⽤算法,⼤多数算法都是在选定决策变量的初始值后 ,通过一定的<strong>搜索⽅法</strong>寻求最优的决策变量 。</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220805213119482.png" alt="image-20220805213119482"></p><h4 id="③整数规划-integer-programming）"><a href="#③整数规划-integer-programming）" class="headerlink" title="③整数规划 ( integer programming）"></a>③整数规划 ( integer programming）</h4><p>整数规划是一类要求变量取整数值的数学规划</p><h5 id="线性整数规划（在线性规划模型中，有决策变量限定为整数"><a href="#线性整数规划（在线性规划模型中，有决策变量限定为整数" class="headerlink" title="线性整数规划（在线性规划模型中，有决策变量限定为整数)"></a>线性整数规划（在线性规划模型中，有决策变量限定为整数)</h5><h5 id="非线性整数规划"><a href="#非线性整数规划" class="headerlink" title="非线性整数规划"></a>非线性整数规划</h5><p>⽬前, 所流⾏的求解整数规划的算法往往只适⽤于线性整数规划</p><h4 id="④-0-1-规划-otngrammng"><a href="#④-0-1-规划-otngrammng" class="headerlink" title="④ 0- 1 规划 ( otngrammng) :"></a>④ 0- 1 规划 ( otngrammng) :</h4><p>整数规划的特例 ,整数变量的取值只能为 0 和 1 </p>]]></content>
    
    
    <categories>
      
      <category>Mathematical Modeling</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第4章 Pod--Kubernetes的基本单位</title>
    <link href="/2022/07/30/%E7%AC%AC4%E7%AB%A0%20Pod--Kubernetes%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D/"/>
    <url>/2022/07/30/%E7%AC%AC4%E7%AB%A0%20Pod--Kubernetes%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Pod是Kubernetes中的&#x3D;&#x3D;基本单位&#x3D;&#x3D;。容器本身并不会直接分配到主机上，而会封装到名为Pod的对象中。</p><p>Pod通常表示<strong>单个应用程序</strong>，由一个或多个关系紧密的容器构成，这些容器拥有同样的生命周期，作为一个整体一起编排到Node上。</p><p>这些容器<strong>共享环境、存储卷（volume）和IP空间</strong>。尽管Pod基于一个或多个容器，但应将Pod视作一个单一的整体、单独的应用程序。Kubernetes以Pod为最小单位进行调度、伸缩并共享资源、管理生命周期。</p></blockquote><h1 id="1-Pod基本操作"><a href="#1-Pod基本操作" class="headerlink" title="1. Pod基本操作"></a>1. Pod基本操作</h1><h2 id="1-创建Pod"><a href="#1-创建Pod" class="headerlink" title="1. 创建Pod"></a>1. 创建Pod</h2><h3 id="部署Pod"><a href="#部署Pod" class="headerlink" title="部署Pod"></a>部署Pod</h3><p>定义模版文件：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">vim</span> examplepod.yml<br></code></pre></td></tr></table></figure><p>填入：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">apiVersion</span><span class="hljs-punctuation">:</span> <span class="hljs-string">v1</span><br><span class="hljs-attribute">kind</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attribute">metadata</span><span class="hljs-punctuation">:</span><br> <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">examplepod</span><br><span class="hljs-attribute">spec</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">containers</span><span class="hljs-punctuation">:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">name: examplepod-container</span><br><span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">busybox</span><br><span class="hljs-attribute">imagePullPolicy</span><span class="hljs-punctuation">:</span> <span class="hljs-string">IfNotPresent</span><br><span class="hljs-attribute">command</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[&#x27;sh&#x27;, &#x27;-c&#x27;]</span><br><span class="hljs-attribute">args</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[&#x27;echo &quot;Hello Kubernetes!&quot;; sleep 3600&#x27;]</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>apiVersion</strong>表示使用的<strong>API版本</strong>。v1表示使用Kubernetes API的稳定版本</p></li><li><p><strong>kind</strong>表示要创建的<strong>资源对象</strong>，这里使用关键字Pod。</p></li><li><p><strong>metadata</strong>表示该资源对象的元数据。一个资源对象可拥有多个元数据，其中一项是name，它表示当前资源的名称。</p></li><li><p><strong>spec</strong>表示该资源对象的具体设置。其中containers表示容器的集合，这里只设置了一个容器，该容器的属性如下。</p><ul><li><p>name：要创建的容器名称。</p></li><li><p>image：容器的镜像地址。</p></li><li><p>imagePullPolicy：镜像的下载策略，支持3种</p><p>imagePullPolicy，如下所示。</p><ul><li>Always：不管镜像是否存在都会进行一次拉取。</li><li>Never：不管镜像是否存在都不会进行拉取。</li><li>IfNotPresent：只有镜像不存在时，才会进行拉取。</li></ul></li><li><p>command：容器的启动命令列表（不配置的话，使用镜像内部的命令）。</p></li><li><p>args：启动参数列表（在本例中是输出文字“HelloKubernetes!”并休眠3600s）</p></li></ul></li></ul><p>运行以下命令，通过模板创建Pod。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">kubectl <span class="hljs-built_in">apply</span> -f examplepod.yml<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220804215147389.png" alt="image-20220804215147389"></p><hr><p><em><strong>提示</strong>：apply是一种声明式对象配置命令。这里应用了之前创建的模板，-f参数表示使用文件名作为参数。相比命令式对象管理，apply既便于跟踪，又具备很好的可读性。本书将统一使用声明式对象配置来管理资源。</em></p><hr><p>创建成功后，可通过以下命令查询当前运行的所有Pod。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">kubectl <span class="hljs-built_in">get</span> pod<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220804215230213.png" alt="image-20220804215230213"></p><h2 id="2-查询Pod"><a href="#2-查询Pod" class="headerlink" title="2. 查询Pod"></a>2. 查询Pod</h2><p>​Pod创建后，最常用的功能就是查询。可以用以下命令<strong>查询Pod的状态</strong>。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">kubectl <span class="hljs-built_in">get</span> <span class="hljs-keyword">pod</span> &#123;Pod名称&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220804215302364.png" alt="image-20220804215302364"></p><p>还可以在查询命令中带上参数-w，以对Pod状态进行<strong>持续监控</strong>。</p><p>​只要Pod发生了变化，就会在控制台中输出相应信息。命令如下。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">kubectl <span class="hljs-built_in">get</span> <span class="hljs-keyword">pod</span> &#123;Pod名称&#125; <span class="hljs-operator">-</span>w<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220804215324072.png" alt="image-20220804215324072"></p><p>​另外，还可以在查询命令中带上-o wide参数，<strong>输出Pod的更多概要信息</strong>（如调度到哪台机器上，Pod本身的虚拟IP等信息）。命令如下。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">kubectl <span class="hljs-built_in">get</span> <span class="hljs-keyword">pod</span> &#123;Pod名称&#125; <span class="hljs-operator">-</span>o wide<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220804215453630.png" alt="image-20220804215453630"></p><p>​get命令除了可以显示简要的运行信息外，还可以输出<strong>完整信息</strong>。它支持<strong>多种格式</strong>的输出，如可以用yaml和Json方式输出，命令如下。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">kubectl <span class="hljs-keyword">get</span> pod examplepod <span class="hljs-comment">--output yaml</span><br>kubectl <span class="hljs-keyword">get</span> pod examplepod <span class="hljs-comment">--output json</span><br></code></pre></td></tr></table></figure><p>一般情况下，如果要<strong>查询Pod更详细的信息</strong>（包括状态、生命周期和执行情况等），除了将其输出为yaml或json格式，还可以用<strong>describe命令</strong>查看详情，格式如下。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">kubectl describe pods </span><span class="hljs-template-variable">&#123;Pod名称&#125;</span><br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><code class="hljs dts">[root@iZbp1f3y0av6g5d4zhb3uoZ examplepod]<span class="hljs-meta"># kubectl get pod examplepod --output  yaml</span><br><span class="hljs-symbol">apiVersion:</span> v1<br><span class="hljs-symbol">kind:</span> Pod<br><span class="hljs-symbol">metadata:</span><br><span class="hljs-symbol">  annotations:</span><br>    kubectl.kubernetes.io/last-applied-configuration: |<br>      <span class="hljs-punctuation">&#123;</span><span class="hljs-string">&quot;apiVersion&quot;</span>:<span class="hljs-string">&quot;v1&quot;</span>,<span class="hljs-string">&quot;kind&quot;</span>:<span class="hljs-string">&quot;Pod&quot;</span>,<span class="hljs-string">&quot;metadata&quot;</span>:<span class="hljs-punctuation">&#123;</span><span class="hljs-string">&quot;annotations&quot;</span>:<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>,<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;examplepod&quot;</span>,<span class="hljs-string">&quot;namespace&quot;</span>:<span class="hljs-string">&quot;cert-manager&quot;</span><span class="hljs-punctuation">&#125;</span>,<span class="hljs-string">&quot;spec&quot;</span>:<span class="hljs-punctuation">&#123;</span><span class="hljs-string">&quot;containers&quot;</span>:[<span class="hljs-punctuation">&#123;</span><span class="hljs-string">&quot;args&quot;</span>:[<span class="hljs-string">&quot;echo \&quot;Hello Kubernetes!\&quot;; sleep 3600&quot;</span>],<span class="hljs-string">&quot;command&quot;</span>:[<span class="hljs-string">&quot;sh&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>],<span class="hljs-string">&quot;image&quot;</span>:<span class="hljs-string">&quot;busybox&quot;</span>,<span class="hljs-string">&quot;imagePullPolicy&quot;</span>:<span class="hljs-string">&quot;IfNotPresent&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;examplepod-container&quot;</span><span class="hljs-punctuation">&#125;</span>]<span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">  creationTimestamp:</span> <span class="hljs-string">&quot;2022-08-04T13:32:13Z&quot;</span><br><span class="hljs-symbol">  managedFields:</span><br>  - apiVersion: v1<br><span class="hljs-symbol">    fieldsType:</span> FieldsV1<br><span class="hljs-symbol">    fieldsV1:</span><br><span class="hljs-symbol">      f:</span>metadata:<br><span class="hljs-symbol">        f:</span>annotations:<br>          .: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">          f:</span>kubectl.kubernetes.io/last-applied-configuration: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">      f:</span>spec:<br><span class="hljs-symbol">        f:</span>containers:<br><span class="hljs-symbol">          k:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;examplepod-container&quot;</span><span class="hljs-punctuation">&#125;</span>:<br>            .: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>args: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>command: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>image: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>imagePullPolicy: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>name: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>resources: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>terminationMessagePath: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>terminationMessagePolicy: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">        f:</span>dnsPolicy: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">        f:</span>enableServiceLinks: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">        f:</span>restartPolicy: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">        f:</span>schedulerName: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">        f:</span>securityContext: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">        f:</span>terminationGracePeriodSeconds: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">    manager:</span> kubectl-client-side-apply<br><span class="hljs-symbol">    operation:</span> Update<br><span class="hljs-symbol">    time:</span> <span class="hljs-string">&quot;2022-08-04T13:32:13Z&quot;</span><br>  - apiVersion: v1<br><span class="hljs-symbol">    fieldsType:</span> FieldsV1<br><span class="hljs-symbol">    fieldsV1:</span><br><span class="hljs-symbol">      f:</span>status:<br><span class="hljs-symbol">        f:</span>conditions:<br><span class="hljs-symbol">          k:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;ContainersReady&quot;</span><span class="hljs-punctuation">&#125;</span>:<br>            .: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>lastProbeTime: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>lastTransitionTime: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>status: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>type: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">          k:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;Initialized&quot;</span><span class="hljs-punctuation">&#125;</span>:<br>            .: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>lastProbeTime: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>lastTransitionTime: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>status: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>type: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">          k:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;Ready&quot;</span><span class="hljs-punctuation">&#125;</span>:<br>            .: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>lastProbeTime: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>lastTransitionTime: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>status: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>type: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">        f:</span>containerStatuses: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">        f:</span>hostIP: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">        f:</span>phase: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">        f:</span>podIP: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">        f:</span>podIPs:<br>          .: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">          k:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-string">&quot;ip&quot;</span>:<span class="hljs-string">&quot;10.42.2.25&quot;</span><span class="hljs-punctuation">&#125;</span>:<br>            .: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">            f:</span>ip: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">        f:</span>startTime: <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">    manager:</span> k3s<br><span class="hljs-symbol">    operation:</span> Update<br><span class="hljs-symbol">    time:</span> <span class="hljs-string">&quot;2022-08-04T13:32:39Z&quot;</span><br><span class="hljs-symbol">  name:</span> examplepod<br><span class="hljs-symbol">  namespace:</span> cert-manager<br><span class="hljs-symbol">  resourceVersion:</span> <span class="hljs-string">&quot;82803826&quot;</span><br><span class="hljs-symbol">  uid:</span> be9afea5<span class="hljs-number">-2764</span><span class="hljs-number">-4</span>a01-ba9e<span class="hljs-number">-33</span>f13082e7d0<br><span class="hljs-symbol">spec:</span><br><span class="hljs-symbol">  containers:</span><br>  - args:<br>    - echo <span class="hljs-string">&quot;Hello Kubernetes!&quot;</span><span class="hljs-punctuation">;</span> sleep <span class="hljs-number">3600</span><br><span class="hljs-symbol">    command:</span><br>    - sh<br>    - -c<br><span class="hljs-symbol">    image:</span> busybox<br><span class="hljs-symbol">    imagePullPolicy:</span> IfNotPresent<br><span class="hljs-symbol">    name:</span> examplepod-container<br><span class="hljs-symbol">    resources:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">    terminationMessagePath:</span> <span class="hljs-keyword">/dev/</span>termination-log<br><span class="hljs-symbol">    terminationMessagePolicy:</span> File<br><span class="hljs-symbol">    volumeMounts:</span><br>    - mountPath: <span class="hljs-keyword">/var/</span>run<span class="hljs-keyword">/secrets/</span>kubernetes.io/serviceaccount<br><span class="hljs-symbol">      name:</span> default-token-kj5lt<br><span class="hljs-symbol">      readOnly:</span> true<br><span class="hljs-symbol">  dnsPolicy:</span> ClusterFirst<br><span class="hljs-symbol">  enableServiceLinks:</span> true<br><span class="hljs-symbol">  nodeName:</span> izbp113w9axywnhpyk1525z<br><span class="hljs-symbol">  preemptionPolicy:</span> PreemptLowerPriority<br><span class="hljs-symbol">  priority:</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">  restartPolicy:</span> Always<br><span class="hljs-symbol">  schedulerName:</span> default-scheduler<br><span class="hljs-symbol">  securityContext:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">  serviceAccount:</span> default<br><span class="hljs-symbol">  serviceAccountName:</span> default<br><span class="hljs-symbol">  terminationGracePeriodSeconds:</span> <span class="hljs-number">30</span><br><span class="hljs-symbol">  tolerations:</span><br>  - effect: NoExecute<br><span class="hljs-symbol">    key:</span> node.kubernetes.io/not-ready<br><span class="hljs-symbol">    operator:</span> Exists<br><span class="hljs-symbol">    tolerationSeconds:</span> <span class="hljs-number">300</span><br>  - effect: NoExecute<br><span class="hljs-symbol">    key:</span> node.kubernetes.io/unreachable<br><span class="hljs-symbol">    operator:</span> Exists<br><span class="hljs-symbol">    tolerationSeconds:</span> <span class="hljs-number">300</span><br><span class="hljs-symbol">  volumes:</span><br>  - name: default-token-kj5lt<br><span class="hljs-symbol">    secret:</span><br><span class="hljs-symbol">      defaultMode:</span> <span class="hljs-number">420</span><br><span class="hljs-symbol">      secretName:</span> default-token-kj5lt<br><span class="hljs-symbol">status:</span><br><span class="hljs-symbol">  conditions:</span><br>  - lastProbeTime: null<br><span class="hljs-symbol">    lastTransitionTime:</span> <span class="hljs-string">&quot;2022-08-04T13:32:13Z&quot;</span><br><span class="hljs-symbol">    status:</span> <span class="hljs-string">&quot;True&quot;</span><br><span class="hljs-symbol">    type:</span> Initialized<br>  - lastProbeTime: null<br><span class="hljs-symbol">    lastTransitionTime:</span> <span class="hljs-string">&quot;2022-08-04T13:32:39Z&quot;</span><br><span class="hljs-symbol">    status:</span> <span class="hljs-string">&quot;True&quot;</span><br><span class="hljs-symbol">    type:</span> Ready<br>  - lastProbeTime: null<br><span class="hljs-symbol">    lastTransitionTime:</span> <span class="hljs-string">&quot;2022-08-04T13:32:39Z&quot;</span><br><span class="hljs-symbol">    status:</span> <span class="hljs-string">&quot;True&quot;</span><br><span class="hljs-symbol">    type:</span> ContainersReady<br>  - lastProbeTime: null<br><span class="hljs-symbol">    lastTransitionTime:</span> <span class="hljs-string">&quot;2022-08-04T13:32:13Z&quot;</span><br><span class="hljs-symbol">    status:</span> <span class="hljs-string">&quot;True&quot;</span><br><span class="hljs-symbol">    type:</span> PodScheduled<br><span class="hljs-symbol">  containerStatuses:</span><br>  - containerID: containerd:<span class="hljs-comment">//7500b2e8b6f2e0932250d129685edaa17ed84e50aa575bfd5e34ff8203ce2b6f</span><br><span class="hljs-symbol">    image:</span> docker.io<span class="hljs-keyword">/library/</span>busybox:latest<br><span class="hljs-symbol">    imageID:</span> docker.io<span class="hljs-keyword">/library/</span>busybox@sha256:ef320ff10026a50cf5f0213d35537ce0041ac1d96e9b7800bafd8bc9eff6c693<br><span class="hljs-symbol">    lastState:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-symbol">    name:</span> examplepod-container<br><span class="hljs-symbol">    ready:</span> true<br><span class="hljs-symbol">    restartCount:</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">    started:</span> true<br><span class="hljs-symbol">    state:</span><br><span class="hljs-symbol">      running:</span><br><span class="hljs-symbol">        startedAt:</span> <span class="hljs-string">&quot;2022-08-04T13:32:38Z&quot;</span><br><span class="hljs-symbol">  hostIP:</span> <span class="hljs-number">172.19</span><span class="hljs-number">.230</span><span class="hljs-number">.67</span><br><span class="hljs-symbol">  phase:</span> Running<br><span class="hljs-symbol">  podIP:</span> <span class="hljs-number">10.42</span><span class="hljs-number">.2</span><span class="hljs-number">.25</span><br><span class="hljs-symbol">  podIPs:</span><br>  - ip: <span class="hljs-number">10.42</span><span class="hljs-number">.2</span><span class="hljs-number">.25</span><br><span class="hljs-symbol">  qosClass:</span> BestEffort<br><span class="hljs-symbol">  startTime:</span> <span class="hljs-string">&quot;2022-08-04T13:32:13Z&quot;</span><br></code></pre></td></tr></table></figure><p>该命令会输出<strong>比较全面</strong>的信息，包括资源的<u>基本信息、容器信息、准备情况、存储卷信息及相关的事件列表</u>。在资源部署时如果遇到问题，可以使用此命令查看详情，分析部署错误的原因。</p><p>如果要查询Pod本身输出的日志信息，还可以使用logs命令，格式如下。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">kubectl logs </span><span class="hljs-template-variable">&#123;Pod名称&#125;</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220804220238729.png" alt="image-20220804220238729"></p><h2 id="3-修改Pod"><a href="#3-修改Pod" class="headerlink" title="3. 修改Pod"></a>3. 修改Pod</h2><p>​可以用replace命令来修改原先设置的Pod属性，命令格式如下:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">kubectl <span class="hljs-built_in">replace</span> -f &#123;pod模板路径&#125;<br></code></pre></td></tr></table></figure><p>修改之前示例中定义的Pod，使它输出“Hello Kubernetesreplaced!”。先打开examplepod.yml文件。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">vim</span> examplepod.yml<br></code></pre></td></tr></table></figure><p>在文件中填入如下内容并保存。</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">apiVersion</span><span class="hljs-punctuation">:</span> <span class="hljs-string">v1</span><br><span class="hljs-attribute">kind</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attribute">metadata</span><span class="hljs-punctuation">:</span><br> <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">examplepod</span><br><span class="hljs-attribute">spec</span><span class="hljs-punctuation">:</span><br> <span class="hljs-attribute">containers</span><span class="hljs-punctuation">:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">name: examplepod-container</span><br>  <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">busybox</span><br>   <span class="hljs-attribute">imagePullPolicy</span><span class="hljs-punctuation">:</span> <span class="hljs-string">IfNotPresent</span><br>   <span class="hljs-attribute">command</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[&#x27;sh&#x27;, &#x27;-c&#x27;]</span><br>   <span class="hljs-attribute">args</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[&#x27;echo &quot;Hello Kubernetes replaced!&quot;; sleep 3600&#x27;]</span><br></code></pre></td></tr></table></figure><hr><p><em>提示：Pod有很多属性无法修改，比如containers的image属性，spec下的activeDeadline Seconds、tolerations属性等。如果一定要修改，则需要加上–force参数，相当于重新创建Pod，命令如下。</em></p><hr><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">kubectl replace -f &#123;pod模板路径&#125; <span class="hljs-comment">--force</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220804221306895.png" alt="image-20220804221306895"></p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220804221403636.png" alt="image-20220804221403636"></p><h2 id="4-删除Pod"><a href="#4-删除Pod" class="headerlink" title="4. 删除Pod"></a>4. 删除Pod</h2><p>Pod的删除非常简单，只要执行以下命令即可</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">kubectl <span class="hljs-keyword">delete</span> pod &#123;Pod名称&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220804221552127.png" alt="image-20220804221552127"></p><p>另外，还可以基于模板文件删除资源，如以下命令所示:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">kubectl <span class="hljs-keyword">delete</span> -f &#123;模板文件名称&#125;<br></code></pre></td></tr></table></figure><h1 id="2-Pod模板详解"><a href="#2-Pod模板详解" class="headerlink" title="2. Pod模板详解"></a>2. Pod模板详解</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span> <span class="hljs-comment">#版本，必填，v1代表稳定版本</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">pod</span> <span class="hljs-comment">#类型，必填，Pod</span><br><span class="hljs-attr">metadata:</span> <span class="hljs-comment">#元数据，表示资源的标识信息</span><br> <span class="hljs-attr">name:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#元数据，必填，Pod的名字</span><br> <span class="hljs-attr">namespace:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#元数据，Pod的命名空间</span><br> <span class="hljs-attr">labels:</span> <span class="hljs-comment">#元数据，标签列表</span><br> <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">value</span> <span class="hljs-comment">#元数据，可定义多个标签的键/值对</span><br> <span class="hljs-attr">annotations:</span> <span class="hljs-comment">#元数据，自定义注解列表</span><br> <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">value</span> <span class="hljs-comment">#元数据，可定义多个注解的键/值对</span><br><span class="hljs-attr">spec:</span> <span class="hljs-comment">#Pod中容器的详细定义，必填</span><br> <span class="hljs-attr">containers:</span> <span class="hljs-comment">#Pod中的容器列表，必填，可以有多个容器</span><br> <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#容器名称，必填</span><br> <span class="hljs-attr">image:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#容器中的镜像地址，必填</span><br> <span class="hljs-attr">imagePullPolicy:</span> [<span class="hljs-string">Always|Never|IfNotPresent</span>]<span class="hljs-comment">#获取镜像的策略，Always表示下载镜像；</span><br> <span class="hljs-comment">#IfNotPresent表示优先使用本地镜像，否则下载镜像；Never表示仅使用本地镜像</span><br> <span class="hljs-attr">command:</span> [<span class="hljs-string">String</span>] <span class="hljs-comment">#容器的启动命令列表（不配置的话，使用镜像内部的命令）</span><br> <span class="hljs-attr">args:</span> [<span class="hljs-string">String</span>] <span class="hljs-comment">#启动命令参数列表</span><br> <span class="hljs-attr">workingDir:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#容器的工作目录</span><br> <span class="hljs-attr">volumeMounts:</span> <span class="hljs-comment">#挂载到容器内部的存储卷设置</span><br> <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#为了引用Pod定义的共享存储卷的名称，要用volumes[]部分定义的卷名</span><br> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#存储卷在容器内挂载的绝对路径，应少于512个字符</span><br> <span class="hljs-attr">readOnly:</span> <span class="hljs-string">boolean</span> <span class="hljs-comment">#是否为只读模式</span><br> <span class="hljs-attr">ports:</span> <span class="hljs-comment">#容器需要暴露的端口号列表</span><br> <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#端口名称</span><br> <span class="hljs-attr">containerPort:</span> <span class="hljs-string">int</span> <span class="hljs-comment">#容器要暴露的端口</span><br> <span class="hljs-attr">hostPort:</span> <span class="hljs-string">int</span> <span class="hljs-comment">#容器所在主机监听的端口（把容器暴露的端口映射到宿主机的端口）</span><br> <span class="hljs-attr">protocol:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#端口协议，支持TCP和UDP，默认为TCP</span><br> <span class="hljs-attr">env:</span> <span class="hljs-comment">#容器运行前要设置的环境变量列表</span><br> <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#环境变量名称</span><br> <span class="hljs-attr">value:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#环境变量值</span><br> <span class="hljs-attr">resources:</span> <span class="hljs-comment">#资源限制和请求的设置</span><br> <span class="hljs-attr">limits:</span> <span class="hljs-comment">#资源限制的设置</span><br> <span class="hljs-attr">cpu:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#CPU的限制，单位为CPU内核数。将用于docker run--cpu-quota 参数，</span><br> <span class="hljs-comment">#也可以使用小数，例如0.1，0.1等价于表达式100m，表示100milicpu</span><br> <span class="hljs-attr">memory:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#内存限制，单位可以为</span><br><span class="hljs-string">MiB/GiB/MB/GB（1MiB=1024×1024B，#1MB=1000×1000B），将用于docker</span> <span class="hljs-string">run</span> <span class="hljs-string">--memory参数</span> <span class="hljs-attr">requests:</span> <span class="hljs-comment">#资源请求的设置</span><br> <span class="hljs-attr">cpu:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#CPU请求，容器启动时的初始可用数量，将用于</span><br><span class="hljs-string">docker</span> <span class="hljs-string">run</span> <span class="hljs-string">--cpu-shares参数</span><br> <span class="hljs-attr">memory:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#内存请求，容器启动时的初始可用数量</span><br> <span class="hljs-attr">livenessProbe:</span> <span class="hljs-comment">#Pod内容器健康检查的设置，当探测几次无响应后将自动重启该容器，</span><br> <span class="hljs-comment">#检查方法有exec、httpGet和tcpSocket，对一个容器只要设置一种方法即可</span><br> <span class="hljs-attr">exec:</span> <span class="hljs-comment">#通过exec方式来检查Pod内各容器的健康状况</span><br> <span class="hljs-attr">command:</span> [<span class="hljs-string">String</span>] <span class="hljs-comment">#exec方式需要指定的命令或脚本</span><br> <span class="hljs-attr">httpGet:</span> <span class="hljs-comment">#通过httpGet方式来检查Pod中各容器的健康状况，需要指定path、port</span><br> <span class="hljs-attr">path:</span> <span class="hljs-string">String</span><br> <span class="hljs-attr">port:</span> <span class="hljs-string">number</span><br> <span class="hljs-attr">host:</span> <span class="hljs-string">String</span><br> <span class="hljs-attr">scheme:</span> <span class="hljs-string">String</span><br> <span class="hljs-attr">httpHeaders:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">String</span><br> <span class="hljs-attr">value:</span> <span class="hljs-string">String</span> <br> <span class="hljs-attr">tcpSocket:</span> <span class="hljs-comment">#通过tcpSocket检查Pod中各容器的健康状况</span><br> <span class="hljs-attr">port:</span> <span class="hljs-string">number</span><br> <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">0</span> <span class="hljs-comment">#容器启动完成后，首次探测的时间（单位为秒）</span><br> <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">0</span> <span class="hljs-comment">#对容器进行健康检查时探测等待响应的超时时间</span><br><span class="hljs-string">（单位为秒，默认为1s）</span><br> <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">0</span> <span class="hljs-comment">#对容器监控检查的定期探测时间设置（单位为秒），默认10s一次</span><br> <span class="hljs-attr">successThreshold:</span> <span class="hljs-number">0</span><br> <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">0</span><br> <span class="hljs-attr">securityContext:</span> <span class="hljs-comment">#安全配置</span><br> <span class="hljs-attr">privileged:</span> <span class="hljs-literal">false</span><br> <span class="hljs-attr">restartPolicy:</span> [<span class="hljs-string">Always|Never|OnFailure</span>]<span class="hljs-comment">#Pod的重启策略，Always表示不管以何种方式终止</span><br> <span class="hljs-comment">#运行，kubelet都将重启；OnFailure表示只有Pod以非0码退出才重启；Never表示不再重启该Pod</span><br> <span class="hljs-attr">nodeSelector:</span> <span class="hljs-string">object</span> <span class="hljs-comment">#节点选择，设置nodeSelector表示将该Pod调度到包含这个标签的</span><br> <span class="hljs-comment">#节点上，以key：value格式来指定</span><br> <span class="hljs-attr">imagePullSecrets:</span> <span class="hljs-comment">#拉取镜像时使用的secret名称，以key：</span><br><span class="hljs-string">secretkey格式指定</span><br> <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">String</span><br> <span class="hljs-attr">hostNetwork:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</span><br> <span class="hljs-attr">volumes:</span> <span class="hljs-comment">#在该Pod上定义共享存储卷列表</span><br> <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">String</span> <span class="hljs-comment">#共享存储卷名称</span><br> <span class="hljs-attr">emptyDir:</span> &#123;&#125; <span class="hljs-comment">#类型为emptyDir的存储卷，与Pod有相同生命周期的一个临时目录，为空值</span><br> <span class="hljs-attr">hostPath:</span> <span class="hljs-comment">#类型为hostPath的存储卷，将会挂载Pod所在宿主机的目录</span><br> <span class="hljs-attr">path:</span> <span class="hljs-string">string</span> <span class="hljs-comment">#Pod所在宿主机的目录，该目录将在容器中挂载</span><br> <span class="hljs-attr">secret:</span> <span class="hljs-comment">#类型为secret的存储卷，在容器内部挂载集群中</span><br><span class="hljs-string">预定义的secret对象</span><br> <span class="hljs-attr">secretName:</span> <span class="hljs-string">String</span><br> <span class="hljs-attr">items:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">String</span><br> <span class="hljs-attr">path:</span> <span class="hljs-string">String</span><br> <span class="hljs-attr">configMap:</span> <span class="hljs-comment">#类型为configMap的存储卷，挂载预定义的</span><br><span class="hljs-string">configMap对象到容器内部</span><br> <span class="hljs-attr">name:</span> <span class="hljs-string">String</span><br> <span class="hljs-attr">items:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">String</span><br> <span class="hljs-attr">path:</span> <span class="hljs-string">String</span><br></code></pre></td></tr></table></figure><p>还可以使用<code>$ kubectl explain pod</code>命令详细查看Pod资源所支持的所有字段的详细说明</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220804222023988.png" alt="image-20220804222023988"></p><p>可以看到图中列出了5个字段，分别是apiVersion、kind、metadata、spec、status。如果要进一步查看每个字段的详情，例如，对于spec字段可以使用命令<code>$ kubectl explainpod.spec</code>进行查看，</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Notes/main/picture/image-20220804222153635.png" alt="image-20220804222153635"></p><p>如果要了解一个正在运行的Pod的配置，可以通过以下命令来获取。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">kubectl <span class="hljs-built_in">get</span> <span class="hljs-keyword">pod</span> &#123;pod名称&#125; <span class="hljs-operator">-</span>o yaml<br></code></pre></td></tr></table></figure><h1 id="3-Pod与容器"><a href="#3-Pod与容器" class="headerlink" title="3. Pod与容器"></a>3. Pod与容器</h1><h2 id="1-Pod创建容器的方式"><a href="#1-Pod创建容器的方式" class="headerlink" title="1. Pod创建容器的方式"></a>1. Pod创建容器的方式</h2><p>之前描述的<strong>Pod模板</strong>和<strong>Docker-Compose</strong>配置非常相似，但Pod模板涉及其他部署参数的设定，相对更复杂。</p><p>先排除与容器无关的配置参数，在模板的<strong>Containers</strong>部分，<strong>指明容器的部署方式</strong>。在部署过程中，会转换成对应的容器运行时（containerruntime）命令，例如，对于Docker，会转换成类似于Docker run的命令。</p><p>​在最开始的例子中，yml文件内容如下。</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">apiVersion</span><span class="hljs-punctuation">:</span> <span class="hljs-string">v1</span><br><span class="hljs-attribute">kind</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attribute">metadata</span><span class="hljs-punctuation">:</span><br> <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">examplepod</span><br><span class="hljs-attribute">spec</span><span class="hljs-punctuation">:</span><br> <span class="hljs-attribute">containers</span><span class="hljs-punctuation">:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">name: examplepod-container</span><br>  <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">busybox</span><br>   <span class="hljs-attribute">imagePullPolicy</span><span class="hljs-punctuation">:</span> <span class="hljs-string">IfNotPresent</span><br>   <span class="hljs-attribute">command</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[&#x27;sh&#x27;, &#x27;-c&#x27;]</span><br>   <span class="hljs-attribute">args</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[&#x27;echo &quot;Hello Kubernetes!&quot;; sleep 3600&#x27;]</span><br></code></pre></td></tr></table></figure><p>在Kubernetes将Pod调度到某个节点后，kubelet会调用容器运行时（本例中为Docker），执行如下所示的命令。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">docker <span class="hljs-keyword">run</span> --name examplepod-container busybox <span class="hljs-keyword">sh</span> -c &#x27;echo<span class="hljs-string">&quot;Hello Kubernetes!&quot;</span>; <span class="hljs-keyword">sleep</span> 3600&#x27;<br></code></pre></td></tr></table></figure><hr><p><em>提示：command和args设置会分别覆盖原Docker镜像中定义的EntryPoint与CMD，在使用时请务必注意以下规则。</em></p><hr><ul><li>如果没有在模板中提供command或args，则<u>使用Docker镜像中定义的默认值运行</u>。</li><li>如果在模板中提供了command，但未提供args，则仅使用提供的command。Docker镜像中定义的默认的EntryPoint和默认的命令都将被忽略。</li><li>如果只提供了args，则Docker镜像中定义的默认的EntryPoint将与所提供的args组合到一起运行。</li><li>如果只提供了args，则Docker镜像中定义的默认的EntryPoint将与所提供的args组合到一起运行。</li><li>如果同时提供了command和args，Docker镜像中定义的默认的EntryPoint和命令都将被忽略。所提供的command和args将会组合到一起运行。</li></ul><p>同样，在Pod模板的Container设置中的各项信息，在运行时都会转换为类似的容器命令来执行。Container的基础信息的设置如下所示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">containers: <span class="hljs-comment">#Pod中的容器列表，必填，可以有多个容器</span><br>- name: String <span class="hljs-comment">#容器的名称，必填</span><br> image: String <span class="hljs-comment">#容器中的镜像地址，必填</span><br> imagePullPolicy: [Always|Never|IfNotPresent]<span class="hljs-comment">#获取镜像的策略。</span><br>Always表示下载镜像；<br> <span class="hljs-comment">#IfNotPresent表示优先使用本地镜像，否则下载镜像；Never表示仅使用本地镜</span><br>像<br> <span class="hljs-built_in">command</span>: [String] <span class="hljs-comment">#容器的启动命令列表（不配置的话，使用镜像内部的</span><br>命令）<br> args: [String] <span class="hljs-comment">#启动命令参数列表</span><br> workingDir: String <span class="hljs-comment">#容器的工作目录</span><br> volumeMounts: <span class="hljs-comment">#挂载到容器内部的存储卷设置</span><br> - name: String <span class="hljs-comment">#为了引用Pod定义的共享存储卷的名称，要用</span><br>volumes[]部分定义的卷名<br> mountPath: String <span class="hljs-comment">#存储卷在容器内挂载的绝对路径，应少于512个字符</span><br> readOnly: boolean <span class="hljs-comment">#是否为只读模式</span><br> ports: <span class="hljs-comment">#容器需要暴露的端口号列表</span><br> - name: String <span class="hljs-comment">#端口名称</span><br> containerPort: int <span class="hljs-comment">#容器要暴露的端口</span><br> hostPort: int <span class="hljs-comment">#容器所在主机监听的端口（把容器暴露的端口映射到</span><br>宿主机的端口）<br> protocol: String <span class="hljs-comment">#端口协议，支持TCP和UDP，默认为TCP</span><br> <span class="hljs-built_in">env</span>: <span class="hljs-comment">#容器运行前要设置的环境变量列表</span><br> - name: String <span class="hljs-comment">#环境变量名称</span><br> value: String <span class="hljs-comment">#环境变量值</span><br></code></pre></td></tr></table></figure><h3 id="1-1．volumeMounts配置信息"><a href="#1-1．volumeMounts配置信息" class="headerlink" title="1.1．volumeMounts配置信息"></a>1.1．volumeMounts配置信息</h3><p>容器运行时通常会提供一些机制来将存储附加到容器上。例如，Docker有两种容器机制：一种是<strong>数据卷（data volume）</strong>，它可以<u>将容器内的文件或目录映射到宿主机上的文件或目录中</u>，其命令格式为</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$docker</span> run -v <span class="hljs-regexp">/&#123;主机的目录&#125;:/</span>&#123;映射到容器的目录&#125; &#123;镜像名称&#125;<br></code></pre></td></tr></table></figure><p>另一种是<strong>数据卷容器（data volume container）</strong>，不过其本质使用的还是数据卷，这种容器一般用在一组相关的容器中，<u>用于专门处理数据存储以供其他容器挂载</u>。</p><p>不管是数据卷还是数据卷容器，其<strong>存留时间通常超过其他容器的生命周期</strong>。由于生命周期不同步，因此实现起来非常<strong>缺乏灵活性</strong>。</p><p>为了解决这些问题，<strong>Kubernetes</strong>在数据卷的基础上，<u>又新增加了一套自己的存储卷（volume）抽象机制</u>。该机制不仅允许Pod中的所有容器方便地<strong>共享数据</strong>，还允许存储卷与Pod中的其他容器保持完全一致的生命周期</p><p>下面是一个简单的示例，说明如何对容器创建数据卷及存储卷，以实现数据共享。</p><ol><li>首先，创建examplepodforvolumemount.yml文件。</li></ol><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>vim examplepodforvolumemount.yml<br></code></pre></td></tr></table></figure><ol start="2"><li>填入以下内容</li></ol><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">apiVersion</span><span class="hljs-punctuation">:</span> <span class="hljs-string">v1</span><br><span class="hljs-attribute">kind</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attribute">metadata</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">examplepodforvolumemount</span><br><span class="hljs-attribute">spec</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">containers</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">name: containerforwrite</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attribute">imagePullPolicy</span><span class="hljs-punctuation">:</span> <span class="hljs-string">IfNotPresent</span><br>    <span class="hljs-attribute">command</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[&#x27;sh&#x27;, &#x27;-c&#x27;]</span><br>    <span class="hljs-attribute">args</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[&#x27;echo &quot;test data!&quot; &gt; /write_dir/data; sleep 3600&#x27;]</span><br>    <span class="hljs-attribute">volumeMounts</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">name: filedata</span><br>    <span class="hljs-attribute">mountPath</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/write_dir</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">name: containerforread</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attribute">imagePullPolicy</span><span class="hljs-punctuation">:</span> <span class="hljs-string">IfNotPresent</span><br>    <span class="hljs-attribute">command</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[&#x27;sh&#x27;, &#x27;-c&#x27;]</span><br>    <span class="hljs-attribute">args</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[&#x27;cat /read_dir/data; sleep 3600&#x27;]</span><br>    <span class="hljs-attribute">volumeMounts</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">name: filedata</span><br>    <span class="hljs-attribute">mountPath</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/read_dir</span><br>    <span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">name: filedata</span><br>    <span class="hljs-attribute">emptyDir</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#123;&#125;</span><br></code></pre></td></tr></table></figure><p>在本例中，我们创建了<strong>两个容器</strong>。一个是<code>containerforwrite</code>，它<u>向数据卷写入数据</u>，会向<code>/write_dir/data</code>文件写入<code>&quot;testdata!&quot;</code>文本。容器内的<strong>数据卷地址</strong>为<code>/write_dir</code>，它引用的<strong>存储卷</strong>为<code>filedata</code>。</p><p>另一个容器是<code>containerforread</code>，<code>TE</code>会从<code>/read_dir/data</code>文件中读取文本，并将其输出到控制台（后续可以通过日志查询方式读取输出到控制台的文本）。容器内的数据卷地址为<code>/read_dir</code>，它引用的存储卷为<code>filedata</code>。</p><p>本例中还创建了一个存储卷，其名称为<code>filedata</code>，这个名称会<u>被容器设置中的数据卷所引用</u>。</p><p>存储卷的类型是<code>emptyDir</code>它是最基础的类型，表示<strong>纯净的空目录</strong>，其生命周期和所属的<code>Pod</code>完全一致（后续章节会讲解更多的种类）。对于例子中的两个容器，虽然数据卷地址不同（一个是<code>/write_dir</code>，一个是<code>/read_dir</code>），但因为它们都是映射到同一个空目录下的，所以本质上仍在同一个文件夹内进行操作。</p><p>执行以下命令，创建Pod。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> kubectl apply <span class="hljs-operator">-f</span> examplepodforvolumemount.yml<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220812150036626.png" alt="image-20220812150036626"></p><p>通过以下命令，查看Pod的运行情况，READY 2&#x2F;2表示两个容器都已成功运行。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ kubectl <span class="hljs-built_in">get</span> pods examplepodforvolumemount<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220812150142353.png" alt="image-20220812150142353"></p><p>此时可以通过logs命令，查看Pod中containerforread容器的日志</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>kubectl logs examplepodforvolumemount containerforread<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220812150253756.png" alt="image-20220812150253756"></p><p> 此处已经可以看到containerforwrite写入的数据内容了。</p><h3 id="1-2-ports配置信息"><a href="#1-2-ports配置信息" class="headerlink" title="1.2 ports配置信息"></a>1.2 ports配置信息</h3><p>容器运行时通常会提供一些机制<strong>以将容器端口暴露出来</strong>，并<strong>映射到主机的端口上</strong>，以便其他人能通过“主机IP:端口”访问容器所提供的服务，例如，Docker的命令<code>$ docker run -p &#123;宿主机端口&#125;:&#123;容器端口&#125; &#123;镜像名称&#125;</code>。同样，Pod模板中也提供了这个功能。为了通过例子进行演示，首先，创建<code>examplepodforport.yml</code>文件。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">$ vim examplepodfor<span class="hljs-keyword">port</span>.yml<br></code></pre></td></tr></table></figure><p>在文件中填入以下内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br> <span class="hljs-attr">name:</span> <span class="hljs-string">examplepodforport</span><br><span class="hljs-attr">spec:</span><br> <span class="hljs-attr">containers:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">containerfornginx</span><br>   <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>   <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>   <span class="hljs-attr">ports:</span> <br> <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">portfoxnginx</span><br>   <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span> <br>   <span class="hljs-attr">hostPort:</span> <span class="hljs-number">8081</span> <br>   <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br></code></pre></td></tr></table></figure><p>​在本例中，<strong>Nginx镜像中默认定义的对外提供服务的端口为80</strong>。通过<strong>containerPort</strong>属性，我们将80端口暴露出来，再通过<strong>hostPort属性将其映射到宿主机的端口8081上</strong>，以便通过“主机IP:端口”访问容器所提供的服务，其中<strong>protocol为端口协议</strong>，<u>支持TCP和UDP</u>，默认为<strong>TCP</strong>。</p><p>​执行以下命令，创建Pod。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">$ kubectl apply -f examplepodfor<span class="hljs-keyword">port</span>.yml<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220812163407488.png" alt="image-20220812163407488"></p><p>通过以下命令，查看Pod的运行情况，直到状态变为Running。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">$ kubectl get pods examplepodfor<span class="hljs-keyword">port</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220812163813405.png" alt="image-20220812163813405"></p><p>Pod创建完成后，执行以下命令，查看Pod具体被分配到哪台Node上</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">$ kubectl describe pods examplepodfor<span class="hljs-keyword">port</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220812164520644.png" alt="image-20220812164520644"></p><p>Pod被分配到了<code>izbp113w9axywnhpyk1525z/172.19.230.67</code>上</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">Node</span><span class="hljs-title">:         izbp113w9axywnhpyk1525z</span>/<span class="hljs-number">172.19</span>.<span class="hljs-number">230.67</span><br></code></pre></td></tr></table></figure><p>使用wget检验端口是否开通</p><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220812172604700.png" alt="image-20220812172604700"></p><hr><p><strong>注意：</strong>以上案例仅为了说明<code>Kubernetes</code>是如何创建容器的，<u>这种类似于Docker直接映射到主机端口的方式</u>，在Kubernetes中<strong>强烈不推荐</strong>。</p><p>Pod只是一个运行服务的实例，随时可能在一个Node上停止，而在另一个Node上以新的IP地址启动新的Pod，因此它不能以稳定的IP地址和端口号提供服务。若要稳定地提供服务，则需要服务发现和负载均衡能力。</p><hr><h3 id="3．env配置信息"><a href="#3．env配置信息" class="headerlink" title="3．env配置信息"></a>3．env配置信息</h3><p>容器运行时通常还会提供一些机制来输入<strong>可动态配置的一些环境变量</strong>，以供容器中的应用程序使用。如在Docker中，配置环境变量的命令为<code>$ docker run --env &#123;变量1&#125;=&#123;值1&#125; --env &#123;变量2&#125;=&#123;值2&#125; ... &#123;镜像名称&#125;</code>。同样，Pod模板中也提供了这个功能。</p><p>首先，创建examplepodforenv.yml文件。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>vim examplepodforenv.yml<br></code></pre></td></tr></table></figure><p>填入以下内容：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">apiVersion</span><span class="hljs-punctuation">:</span> <span class="hljs-string">v1</span><br><span class="hljs-attribute">kind</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attribute">metadata</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">examplepodforenv</span><br><span class="hljs-attribute">spec</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">containers</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">name: containerforenv</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attribute">imagePullPolicy</span><span class="hljs-punctuation">:</span> <span class="hljs-string">IfNotPresent</span><br>    <span class="hljs-attribute">env</span><span class="hljs-punctuation">: </span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">name: parameter1</span><br>      <span class="hljs-attribute">value</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;good morning!&quot; </span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">name: parameter2</span><br>      <span class="hljs-attribute">value</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;good night!&quot;</span><br>  <span class="hljs-attribute">command</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[&#x27;sh&#x27;,&#x27;-c&#x27;]</span><br><span class="hljs-attribute">args</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[&#x27;echo &quot;$&#123;parameter1&#125; $&#123;parameter2&#125;&quot;; sleep 3600&#x27;]</span><br></code></pre></td></tr></table></figure><p>在模板中定义了一个名为<code>containerforenv</code>的容器，向它传入了两个环境变量：其中一个名为<code>parameter1</code>，值为<code>goodmorning!</code>；另一个变量名为<code>parameter2</code>，值为<code>good night!</code>。在本例中，将通过在容器中执行命令的方式，<u>将传入的两个环境变量拼接到一起并输出到日志</u>。</p><p>执行以下命令，创建Pod</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> kubectl apply <span class="hljs-operator">-f</span> examplepodforenv.yml<br></code></pre></td></tr></table></figure><p>运行以下命令，查看Pod的运行情况，直到状态变为Running</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ kubectl <span class="hljs-built_in">get</span> pods examplepodforenv<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220812193426614.png" alt="image-20220812193426614"></p><p>通过以下命令，查看Pod中输出的日志。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>kubectl logs examplepodforenv<br></code></pre></td></tr></table></figure><p>可以看到两个环境变量的值成功拼接到一起并输出到日志中</p><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220812193508164.png" alt="image-20220812193508164"></p><h2 id="2-Pod组织容器的方式"><a href="#2-Pod组织容器的方式" class="headerlink" title="2. Pod组织容器的方式"></a>2. Pod组织容器的方式</h2><p>Pod的设计初衷在于同时运行<strong>多个共同协作</strong>的进程（作为容器来运行）。Pod中的各个容器总是作为一个整体，同时调度到某台Node上。容器之间可以共享资源、网络环境和依赖，并拥有相同的生命周期。</p><p>当然，在同一个Pod中同时运行和管理多个容器，是一种相对高级的用法，只在容器必须要紧密配合进行协作的时候才使用此模式。</p><h3 id="1-容器如何组成一个Pod"><a href="#1-容器如何组成一个Pod" class="headerlink" title="1. 容器如何组成一个Pod"></a>1. 容器如何组成一个Pod</h3><p>Pod只是一种抽象，并不是一个真正的物理实体，表示一组相关容器的<strong>逻辑划分</strong>。每个Pod都包含一个或一组密切相关的业务容器，除此之外，每个Pod都还有一个称为“<strong>根容器</strong>”的特殊<strong>Pause容器</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220812194430776.png" alt="image-20220812194430776"></p><p>Pause容器其实属于Kubernetes的一部分。在一组容器作为一个单位的情况下，很难对整个容器组进行判断，如一个容器挂载了能代表整个Pod都挂载了吗？</p><p>如果引入一个和业务无关的Pause容器，用它作为Pod的根容器，<strong>用它的状态代表整组容器的状态</strong>，便能解决该问题。</p><p>另外，Pod中的所有容器都<strong>共享Pause容器的IP地址及其挂载的存储卷</strong>，这样也<strong>简化了容器之间的通信和数据共享</strong>问题。另外，Pause容器还在Pod中担任<strong>Linux命名空间共享</strong>的基础，为各个容器启用<strong>pid命名空间</strong>，开启init进程。</p><p>例如，对于本章最开始的操作示例，<strong>创建Pod后可以登录对应的Node</strong>，使用以下命令查看创建的容器。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> docker <span class="hljs-built_in">ps</span><br></code></pre></td></tr></table></figure><p>Pod中的容器可以使用Pod所提供的两种共享资源——存储和网络。</p><h4 id="1-存储"><a href="#1-存储" class="headerlink" title="1) 存储"></a>1) 存储</h4><p>在Pod中，可以指定<strong>一个或多个共享存储卷</strong>。Pod中的所有容器都可以<strong>访问共享存储卷</strong>，从而让这些容器共享数据。存储卷也可以用来持久化Pod中的存储资源，以防容器重启后文件丢失。</p><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220812204444677.png" alt="image-20220812204444677"></p><h4 id="2）网络"><a href="#2）网络" class="headerlink" title="2）网络"></a>2）网络</h4><p>每个Pod都分配了<strong>唯一的IP地址</strong>。Pod中的每个容器都<strong>共享网络命名空间</strong>，包括<u>IP地址和网络端口</u>。Pod内部的容器可以使用<strong>localhost互相通信</strong>。当Pod中的容器与Pod外部进行通信时，还必须<strong>共享网络资源</strong>（如使用端口映射）。</p><p>Docker和Kubernetes在网络空间上的差异</p><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220812215352573.png" alt="image-20220812215352573"></p><p>要查看Pod的IP，可以使用以下命令</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ kubectl <span class="hljs-keyword">get</span> pod <span class="hljs-keyword">my</span>-app <span class="hljs-comment">--template=&#123;&#123;.status.podIP&#125;&#125;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220813111719382.png" alt="image-20220813111719382"></p><h3 id="2．Pod之间如何通信"><a href="#2．Pod之间如何通信" class="headerlink" title="2．Pod之间如何通信"></a>2．Pod之间如何通信</h3><p>Docker其实一开始没有考虑<strong>多主机互连的网络解决方案</strong>。在实际的业务场景中，组件之间的管理十分复杂，应用部署的<strong>粒度更加细小</strong>。Kubernetes使用其独有的网络模型去解决这些问题。</p><p>Pod之间的通信主要涉及两个方面:</p><h4 id="1）同一个Node上Pod之间的通信"><a href="#1）同一个Node上Pod之间的通信" class="headerlink" title="1）同一个Node上Pod之间的通信"></a>1）同一个Node上Pod之间的通信</h4><p>因为同一个Node上的Pod使用的都是<strong>相同的Docker网桥</strong>，所以它们天然支持通信。</p><p><img src="https://cdn.jsdelivr.net/gh/Wishforpeace/Notes/picture/image-20220813111911317.png" alt="image-20220813111911317"></p><p>每一个Pod都有一个<strong>全局IP地址</strong>，同一个Node内不同Pod之间可以<strong>直接采用对方Pod的IP地址通信</strong>，而且不需要使用其他发现机制。因为它们都是通过veth连接在<strong>同一个docker0网桥</strong>上的，其IP地址都是<strong>从docker0网桥上动态获取的，并关联在同一个docker0网桥上</strong>，<strong>地址段也相同</strong>，所以它们之间能直接通信。</p><h4 id="2）跨Node的Pod之间的通信"><a href="#2）跨Node的Pod之间的通信" class="headerlink" title="2）跨Node的Pod之间的通信"></a>2）跨Node的Pod之间的通信</h4><p>要实现跨Node的Pod之间的通信，首先需要保证的是<strong>Pod的IP地址</strong>在<strong>所有Node上</strong>都是<strong>全局唯一的</strong>。这其实并不复杂，因为Pod的IP地址是由<strong>Docker 网桥</strong>分配的，所以可以<strong>将不同Node机器上的Docker网桥配置成不同的IP网段</strong>来实现这个功能。</p><p>然后需要在<strong>容器集群中创建一个覆盖网络</strong>来连接各个机器。目前可以通过第三方网络插件来覆盖网络。</p><p>Flannel会配置Docker网桥（即docker0），通过修<strong>改Docker的启动参数bip</strong>来实现这一点。通过这种方式，集群中各台机器的Docker网桥就得到了全局唯一的IP网段，它所创建的容器自然也拥有全局唯一的IP。</p>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Swag</title>
    <link href="/2022/07/27/Swag/"/>
    <url>/2022/07/27/Swag/</url>
    
    <content type="html"><![CDATA[<h1 id="Swaggo"><a href="#Swaggo" class="headerlink" title="Swaggo"></a>Swaggo</h1><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/1-20220727141857667.png" alt="swaggo"></p><h2 id="1-1-1关于Swaggo"><a href="#1-1-1关于Swaggo" class="headerlink" title="1.1.1关于Swaggo"></a>1.1.1关于Swaggo</h2><p>目前swaggo主要实现了swagger 2.0 的以下部分功能：</p><ul><li>基本结构（Basic Structure）</li><li>API 地址与基本路径（API Host and Base Path）</li><li>路径与操作 （Paths and Operations）</li><li>参数描述（Describing Parameters）</li><li>请求参数描述（Describing Request Body）</li><li>返回描述（Describing Responses）</li><li>MIME 类型（MIME Types）</li><li>认证（Authentication）<ul><li>Basic Authentication</li><li>API Keys</li></ul></li><li>添加实例（Adding Examples）</li><li>文件上传（File Upload）</li><li>枚举（Enums）</li><li>按标签分组（Grouping Operations With Tags）</li><li>扩展（Swagger Extensions）</li></ul><p>下文内容均以gin-swaggo为例 <a href="https://github.com/razeencheng/demo-go/tree/master/swaggo-gin">这里是demo地址</a></p><h2 id="1-1-2-使用"><a href="#1-1-2-使用" class="headerlink" title="1.1.2. 使用"></a>1.1.2. 使用</h2><p>安装swag cli 及下载相关包</p><p>要使用swaggo,首先需要安装swag cli。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">go get -u github.com<span class="hljs-regexp">/swaggo/</span>swag<span class="hljs-regexp">/cmd/</span>swag<br></code></pre></td></tr></table></figure><p>然后我们还需要两个包。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># gin-swagger 中间件</span><br>go get github.com<span class="hljs-regexp">/swaggo/gi</span>n-swagger<br><span class="hljs-comment"># swagger 内置文件</span><br>go get github.com<span class="hljs-regexp">/swaggo/gi</span>n-swagger/swaggerFiles<br></code></pre></td></tr></table></figure><p>在main.go内添加注释</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net/http&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>    _ <span class="hljs-string">&quot;github.com/student/0509/docs&quot;</span><br>    ginSwagger <span class="hljs-string">&quot;github.com/swaggo/gin-swagger&quot;</span><br>    <span class="hljs-string">&quot;github.com/swaggo/gin-swagger/swaggerFiles&quot;</span><br>)<br><br><span class="hljs-comment">// @title Swagger Example API</span><br><span class="hljs-comment">// @version 1.0</span><br><span class="hljs-comment">// @description This is a sample server celler server.</span><br><span class="hljs-comment">// @termsOfService https://www.topgoer.com</span><br><br><span class="hljs-comment">// @contact.name www.topgoer.com</span><br><span class="hljs-comment">// @contact.url https://www.topgoer.com</span><br><span class="hljs-comment">// @contact.email me@razeen.me</span><br><br><span class="hljs-comment">// @license.name Apache 2.0</span><br><span class="hljs-comment">// @license.url http://www.apache.org/licenses/LICENSE-2.0.html</span><br><br><span class="hljs-comment">// @host 127.0.0.1:8080</span><br><span class="hljs-comment">// @BasePath /api/v1</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    r := gin.Default()<br><br>    r.GET(<span class="hljs-string">&quot;/swagger/*any&quot;</span>, ginSwagger.WrapHandler(swaggerFiles.Handler))<br><br>    v1 := r.Group(<span class="hljs-string">&quot;/api/v1&quot;</span>)<br>    &#123;<br>        v1.GET(<span class="hljs-string">&quot;/hello&quot;</span>, HandleHello)<br>        <span class="hljs-comment">// v1.POST(&quot;/login&quot;, HandleLogin)</span><br>        <span class="hljs-comment">// v1Auth := r.Use(HandleAuth)</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     v1Auth.POST(&quot;/upload&quot;, HandleUpload)</span><br>        <span class="hljs-comment">//     v1Auth.GET(&quot;/list&quot;, HandleList)</span><br>        <span class="hljs-comment">// &#125;</span><br>    &#125;<br><br>    r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>如上所示，我们需要导入</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ginSwagger</span> <span class="hljs-string">&quot;github.com/swaggo/gin-swagger&quot;</span><br><span class="hljs-string">&quot;github.com/swaggo/gin-swagger/swaggerFiles&quot;</span><br></code></pre></td></tr></table></figure><p>添加注释：</p><ul><li><code>title</code>：文档标题</li><li><code>version</code>：版本</li><li><code>description,termsOfService,contact...</code>这些都是一些声明，可以不写</li><li><code>license.name</code>：必须</li><li><code>host</code>,<code>BasePath</code>:</li><li><code>securityDefinitions.basic</code>,<code>securityDefinitions.apikey</code>等</li></ul><p>到这里，我们在<code>mian.go</code>同目录下执行<code>swag init</code>就可以自动生成文档，如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">E</span>:\goproject\src\github.com\topgoer&gt;swag init<br><span class="hljs-attribute">2020</span>/<span class="hljs-number">05</span>/<span class="hljs-number">13</span> <span class="hljs-number">16</span>:<span class="hljs-number">28</span>:<span class="hljs-number">02</span> Generate swagger docs....<br><span class="hljs-attribute">2020</span>/<span class="hljs-number">05</span>/<span class="hljs-number">13</span> <span class="hljs-number">16</span>:<span class="hljs-number">28</span>:<span class="hljs-number">02</span> Generate general API Info, search dir:./<br><span class="hljs-attribute">2020</span>/<span class="hljs-number">05</span>/<span class="hljs-number">13</span> <span class="hljs-number">16</span>:<span class="hljs-number">28</span>:<span class="hljs-number">02</span> create docs.go at  docs/docs.go<br><span class="hljs-attribute">2020</span>/<span class="hljs-number">05</span>/<span class="hljs-number">13</span> <span class="hljs-number">16</span>:<span class="hljs-number">28</span>:<span class="hljs-number">02</span> create swagger.json at  docs/swagger.json<br><span class="hljs-attribute">2020</span>/<span class="hljs-number">05</span>/<span class="hljs-number">13</span> <span class="hljs-number">16</span>:<span class="hljs-number">28</span>:<span class="hljs-number">02</span> create swagger.yaml at  docs/swagger.yaml<br></code></pre></td></tr></table></figure><p>然后我们在<code>main.go</code>导入这个自动生成的<code>docs</code>包，运行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>    ginSwagger <span class="hljs-string">&quot;github.com/swaggo/gin-swagger&quot;</span><br>    <span class="hljs-string">&quot;github.com/swaggo/gin-swagger/swaggerFiles&quot;</span><br><br>    _ <span class="hljs-string">&quot;github.com/razeencheng/demo-go/swaggo-gin/docs&quot;</span><br>)<br><br><span class="hljs-comment">// @title Swagger Example API</span><br><span class="hljs-comment">// @version 1.0</span><br><span class="hljs-comment">// ...</span><br>E:\goproject\src\github.com\topgoer&gt;<span class="hljs-keyword">go</span> run main.<span class="hljs-keyword">go</span><br>[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.<br><br>[GIN-debug] [WARNING] Running in <span class="hljs-string">&quot;debug&quot;</span> mode. Switch to <span class="hljs-string">&quot;release&quot;</span> mode in production.<br> - using env:   export GIN_MODE=release<br> - using code:  gin.SetMode(gin.ReleaseMode)<br><br>[GIN-debug] GET    /swagger<span class="hljs-comment">/*any             --&gt; github.com/swaggo/gin-swagger.CustomWrapHandler.func1 (3 handlers)</span><br><span class="hljs-comment">[GIN-debug] GET    /api/v1/hello             --&gt; main.HandleHello (3 handlers)</span><br><span class="hljs-comment">[GIN-debug] Listening and serving HTTP on :8080</span><br></code></pre></td></tr></table></figure><p>浏览器打开<a href="http://127.0.0.1:8080/swagger/index.html">http://127.0.0.1:8080/swagger/index.html</a>, 我们可以看到如下文档标题已经生成。<img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/2-20220727141858552.png" alt="swaggo"></p><h3 id="1-1-3-在Handle函数上添加注释"><a href="#1-1-3-在Handle函数上添加注释" class="headerlink" title="1.1.3. 在Handle函数上添加注释"></a>1.1.3. 在Handle函数上添加注释</h3><p>接下来，我们需要在每个路由处理函数上加上注释，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net/http&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>    _ <span class="hljs-string">&quot;github.com/student/0509/docs&quot;</span><br>    ginSwagger <span class="hljs-string">&quot;github.com/swaggo/gin-swagger&quot;</span><br>    <span class="hljs-string">&quot;github.com/swaggo/gin-swagger/swaggerFiles&quot;</span><br>)<br><br><span class="hljs-comment">// @title Swagger Example API</span><br><span class="hljs-comment">// @version 1.0</span><br><span class="hljs-comment">// @description This is a sample server celler server.</span><br><span class="hljs-comment">// @termsOfService https://www.topgoer.com</span><br><br><span class="hljs-comment">// @contact.name www.topgoer.com</span><br><span class="hljs-comment">// @contact.url https://www.topgoer.com</span><br><span class="hljs-comment">// @contact.email me@razeen.me</span><br><br><span class="hljs-comment">// @license.name Apache 2.0</span><br><span class="hljs-comment">// @license.url http://www.apache.org/licenses/LICENSE-2.0.html</span><br><br><span class="hljs-comment">// @host 127.0.0.1:8080</span><br><span class="hljs-comment">// @BasePath /api/v1</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    r := gin.Default()<br><br>    r.GET(<span class="hljs-string">&quot;/swagger/*any&quot;</span>, ginSwagger.WrapHandler(swaggerFiles.Handler))<br><br>    v1 := r.Group(<span class="hljs-string">&quot;/api/v1&quot;</span>)<br>    &#123;<br>        v1.GET(<span class="hljs-string">&quot;/hello&quot;</span>, HandleHello)<br>        <span class="hljs-comment">// v1.POST(&quot;/login&quot;, HandleLogin)</span><br>        <span class="hljs-comment">// v1Auth := r.Use(HandleAuth)</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     v1Auth.POST(&quot;/upload&quot;, HandleUpload)</span><br>        <span class="hljs-comment">//     v1Auth.GET(&quot;/list&quot;, HandleList)</span><br>        <span class="hljs-comment">// &#125;</span><br>    &#125;<br><br>    r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// @Summary 测试SayHello</span><br><span class="hljs-comment">// @Description 向你说Hello</span><br><span class="hljs-comment">// @Tags 测试</span><br><span class="hljs-comment">// @Accept json</span><br><span class="hljs-comment">// @Param who query string true &quot;人名&quot;</span><br><span class="hljs-comment">// @Success 200 &#123;string&#125; string &quot;&#123;&quot;msg&quot;: &quot;hello Razeen&quot;&#125;&quot;</span><br><span class="hljs-comment">// @Failure 400 &#123;string&#125; string &quot;&#123;&quot;msg&quot;: &quot;who are you&quot;&#125;&quot;</span><br><span class="hljs-comment">// @Router /hello [get]</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HandleHello</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>    who := c.Query(<span class="hljs-string">&quot;who&quot;</span>)<br><br>    <span class="hljs-keyword">if</span> who == <span class="hljs-string">&quot;&quot;</span> &#123;<br>        c.JSON(http.StatusBadRequest, gin.H&#123;<span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;who are u?&quot;</span>&#125;)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    c.JSON(http.StatusOK, gin.H&#123;<span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;hello &quot;</span> + who&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们再次<code>swag init</code>, 运行一下。<img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/3-20220727141859223.png" alt="swaggo"></p><p>此时，该API的相关描述已经生成了，我们点击<code>Try it out</code>还可以直接测试该API。<img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/4-20220727141859903.png" alt="swaggo"></p><p>是不是很好用，当然这并没有结束，这些注释字段，我们一个个解释。<img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/5-20220727141901469.png" alt="swaggo"></p><p>这些注释对应出现在API文档的位置，我在上图中已经标出，这里我们主要详细说说下面参数：</p><h4 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h4><p>Tags 是用来给API分组的。</p><h4 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h4><p>接收的参数类型，支持表单(<code>mpfd</code>) 和 JSON(<code>json</code>)</p><h4 id="Produce"><a href="#Produce" class="headerlink" title="Produce"></a>Produce</h4><p>返回的数据结构，一般都是<code>json</code>, 其他支持如下表：</p><table><thead><tr><th>Mime Type</th><th>声明</th></tr></thead><tbody><tr><td>application&#x2F;json</td><td>json</td></tr><tr><td>text&#x2F;xml</td><td>xml</td></tr><tr><td>text&#x2F;plain</td><td>plain</td></tr><tr><td>html</td><td>html</td></tr><tr><td>multipart&#x2F;form-data</td><td>mpfd</td></tr><tr><td>application&#x2F;x-www-form-urlencoded</td><td>x-www-form-urlencoded</td></tr><tr><td>application&#x2F;vnd.api+json</td><td>json-api</td></tr><tr><td>application&#x2F;x-json-stream</td><td>json-stream</td></tr><tr><td>application&#x2F;octet-stream</td><td>octet-stream</td></tr><tr><td>image&#x2F;png</td><td>png</td></tr><tr><td>image&#x2F;jpeg</td><td>jpeg</td></tr><tr><td>image&#x2F;gif</td><td>gif</td></tr></tbody></table><h4 id="Param"><a href="#Param" class="headerlink" title="Param"></a>Param</h4><p>参数，从前往后分别是：</p><blockquote><p>@Param <code>1.参数名</code> <code>2.参数类型</code> <code>3.参数数据类型</code> <code>4.是否必须</code> <code>5.参数描述``6.其他属性</code></p></blockquote><ul><li><p>1.参数名</p><p>参数名就是我们解释参数的名字。</p></li><li><p>2.参数类型</p><p>参数类型主要有三种：</p><ul><li><p><code>path</code> 该类型参数直接拼接在URL中，如<a href="https://github.com/razeencheng/demo-go/blob/master/swaggo-gin/handle.go">Demo</a>中<code>HandleGetFile</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">// @Param <span class="hljs-built_in">id</span> path <span class="hljs-built_in">integer</span> <span class="hljs-literal">true</span> <span class="hljs-string">&quot;文件ID&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><code>query</code> 该类型参数一般是组合在URL中的，如<a href="https://github.com/razeencheng/demo-go/blob/master/swaggo-gin/handle.go">Demo</a>中<code>HandleHello</code></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">// <span class="hljs-symbol">@Param</span> who query <span class="hljs-built_in">string</span> <span class="hljs-literal">true</span> <span class="hljs-string">&quot;人名&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><code>formData</code> 该类型参数一般是<code>POST,PUT</code>方法所用，如<a href="https://github.com/razeencheng/demo-go/blob/master/swaggo-gin/handle.go">Demo</a>中<code>HandleLogin</code></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">// @Param <span class="hljs-keyword">user</span> <span class="hljs-title">formData</span> <span class="hljs-keyword">string</span> <span class="hljs-literal">true</span> <span class="hljs-string">&quot;用户名&quot;</span> default(admin)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>3.参数数据类型</p><p>数据类型主要支持一下几种：</p><ul><li>string (string)</li><li>integer (int, uint, uint32, uint64)</li><li>number (float32)</li><li>boolean (bool)</li></ul><p>注意，如果你是上传文件可以使用<code>file</code>, 但参数类型一定是<code>formData</code>, 如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">// @Param <span class="hljs-keyword">file</span> formData <span class="hljs-keyword">file</span> <span class="hljs-keyword">true</span> <span class="hljs-string">&quot;文件&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>4.是否是必须</p><p>表明该参数是否是必须需要的，必须的在文档中会黑体标出，测试时必须填写。</p></li><li><p>5.参数描述</p><p>就是参数的一些说明</p></li><li><p>6.其他属性</p><p>除了上面这些属性外，我们还可以为该参数填写一些额外的属性，如枚举，默认值，值范围等。如下：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs autoit">枚举<br>// <span class="hljs-symbol">@Param</span> enumstring query <span class="hljs-built_in">string</span> <span class="hljs-literal">false</span> <span class="hljs-string">&quot;string enums&quot;</span> Enums(A, B, C)<br>// <span class="hljs-symbol">@Param</span> enumint query <span class="hljs-built_in">int</span> <span class="hljs-literal">false</span> <span class="hljs-string">&quot;int enums&quot;</span> Enums(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>// <span class="hljs-symbol">@Param</span> enumnumber query <span class="hljs-built_in">number</span> <span class="hljs-literal">false</span> <span class="hljs-string">&quot;int enums&quot;</span> Enums(<span class="hljs-number">1.1</span>, <span class="hljs-number">1.2</span>, <span class="hljs-number">1.3</span>)<br><br>值添加范围<br>// <span class="hljs-symbol">@Param</span> <span class="hljs-built_in">string</span> query <span class="hljs-built_in">string</span> <span class="hljs-literal">false</span> <span class="hljs-string">&quot;string valid&quot;</span> minlength(<span class="hljs-number">5</span>) maxlength(<span class="hljs-number">10</span>)<br>// <span class="hljs-symbol">@Param</span> <span class="hljs-built_in">int</span> query <span class="hljs-built_in">int</span> <span class="hljs-literal">false</span> <span class="hljs-string">&quot;int valid&quot;</span> mininum(<span class="hljs-number">1</span>) maxinum(<span class="hljs-number">10</span>)<br><br>设置默认值<br>// <span class="hljs-symbol">@Param</span> <span class="hljs-literal">default</span> query <span class="hljs-built_in">string</span> <span class="hljs-literal">false</span> <span class="hljs-string">&quot;string default&quot;</span> <span class="hljs-literal">default</span>(A)<br></code></pre></td></tr></table></figure><p>而且这些参数是可以组合使用的，如：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">// <span class="hljs-symbol">@Param</span> enumstring query <span class="hljs-built_in">string</span> <span class="hljs-literal">false</span> <span class="hljs-string">&quot;string enums&quot;</span> Enums(A, B, C) <span class="hljs-literal">default</span>(A)<br></code></pre></td></tr></table></figure></li></ul><h4 id="Success"><a href="#Success" class="headerlink" title="Success"></a>Success</h4><p>指定成功响应的数据。格式为：</p><blockquote><p>&#x2F;&#x2F; @Success <code>1.HTTP响应码</code> <code>&#123;2.响应参数类型&#125;</code> <code>3.响应数据类型</code> <code>4.其他描述</code></p></blockquote><ul><li><p>1.HTTP响应码</p><p>也就是200，400，500那些。</p></li><li><p>2.响应参数类型 &#x2F; 3.响应数据类型</p><p>返回的数据类型，可以是自定义类型，可以是json。</p><ul><li>自定义类型</li></ul><p>在平常的使用中，我都会返回一些指定的模型序列化JSON的数据，这时，就可以这么写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">// <span class="hljs-keyword">@Success</span> <span class="hljs-number">200</span> &#123;<span class="hljs-selector-tag">object</span>&#125; <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.File</span><br></code></pre></td></tr></table></figure><p>其中，模型直接用<code>包名.模型</code>即可。你会说，假如我返回模型数组怎么办？这时你可以这么写：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> @Success <span class="hljs-number">200</span> &#123;anrry&#125; main.File<br></code></pre></td></tr></table></figure><ul><li>json</li></ul><p>将如你只是返回其他的json数据可如下写：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">// <span class="hljs-symbol">@Success</span> <span class="hljs-number">200</span> &#123;<span class="hljs-built_in">string</span>&#125; json <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>4.其他描述</p><p>可以添加一些说明。</p></li></ul><h4 id="Failure"><a href="#Failure" class="headerlink" title="Failure"></a>Failure</h4><p> 同Success。</p><h4 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h4><p> 指定路由与HTTP方法。格式为：</p><blockquote><p>&#x2F;&#x2F; @Router <code>/path/to/handle</code> [<code>HTTP方法</code>]</p></blockquote><p> 不用加基础路径哦。</p><h3 id="1-1-4-生成文档与测试"><a href="#1-1-4-生成文档与测试" class="headerlink" title="1.1.4. 生成文档与测试"></a>1.1.4. 生成文档与测试</h3><p>其实上面已经穿插的介绍了。</p><p>在<code>main.go</code>下运行<code>swag init</code>即可生成和更新文档。</p><p>点击文档中的<code>Try it out</code>即可测试。 如果部分API需要登陆，可以Try登陆接口即可。</p><h3 id="1-1-5-优化"><a href="#1-1-5-优化" class="headerlink" title="1.1.5. 优化"></a>1.1.5. 优化</h3><p>看到这里，基本可以使用了。但文档一般只是我们测试的时候需要，当我的产品上线后，接口文档是不应该给用户的，而且带有接口文档的包也会大很多（swaggo是直接build到二进制里的）。</p><p>想要处理这种情况，我们可以在编译的时候优化一下，如利用<code>build tag</code>来控制是否编译文档。</p><p>在<code>main.go</code>声明<code>swagHandler</code>,并在该参数不为空时才加入路由：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">var</span> swagHandler gin.HandlerFunc<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-keyword">if</span> swagHandler != <span class="hljs-literal">nil</span> &#123;<br>            r.GET(<span class="hljs-string">&quot;/swagger/*any&quot;</span>, swagHandler)<br>        &#125;<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同时,我们将该参数在另外加了<code>build tag</code>的包中初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// +build doc</span><br><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    _ <span class="hljs-string">&quot;github.com/razeencheng/demo-go/swaggo-gin/docs&quot;</span><br><br>    ginSwagger <span class="hljs-string">&quot;github.com/swaggo/gin-swagger&quot;</span><br>    <span class="hljs-string">&quot;github.com/swaggo/gin-swagger/swaggerFiles&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    swagHandler = ginSwagger.WrapHandler(swaggerFiles.Handler)<br>&#125;<br></code></pre></td></tr></table></figure><p>之后我们就可以使用<code>go build -tags &quot;doc&quot;</code>来打包带文档的包，直接<code>go build</code>来打包不带文档的包。</p><p>你会发现，即使我这么小的Demo,编译后的大小也要相差19M !</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">➜  <span class="hljs-keyword">swaggo-gin </span>git:(master) ✗ go <span class="hljs-keyword">build</span><br><span class="hljs-keyword"></span>➜  <span class="hljs-keyword">swaggo-gin </span>git:(master) ✗ <span class="hljs-keyword">ll </span><span class="hljs-keyword">swaggo-gin</span><br><span class="hljs-keyword"></span>-rwxr-xr-x  <span class="hljs-number">1</span> xxx  staff    <span class="hljs-number">15</span>M <span class="hljs-keyword">Jan </span><span class="hljs-number">13</span> <span class="hljs-number">00</span>:<span class="hljs-number">23</span> <span class="hljs-keyword">swaggo-gin</span><br><span class="hljs-keyword"></span>➜  <span class="hljs-keyword">swaggo-gin </span>git:(master) ✗ go <span class="hljs-keyword">build </span>-tags <span class="hljs-string">&quot;doc&quot;</span><br>➜  <span class="hljs-keyword">swaggo-gin </span>git:(master) ✗ <span class="hljs-keyword">ll </span><span class="hljs-keyword">swaggo-gin</span><br><span class="hljs-keyword"></span>-rwxr-xr-x  <span class="hljs-number">1</span> xxx  staff    <span class="hljs-number">34</span>M <span class="hljs-keyword">Jan </span><span class="hljs-number">13</span> <span class="hljs-number">00</span>:<span class="hljs-number">24</span> <span class="hljs-keyword">swaggo-gin</span><br></code></pre></td></tr></table></figure><p>文章到这里也就结束了，完整的<a href="https://github.com/razeencheng/demo-go/tree/master/swaggo-gin">Demo地址在这里</a>。</p><h3 id="1-1-6-使用token"><a href="#1-1-6-使用token" class="headerlink" title="1.1.6. 使用token"></a>1.1.6. 使用token</h3><p>如果你的程序中使用了token中间键，只需要添加下面两行注释即可</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">// <span class="hljs-title">@Security</span> <span class="hljs-keyword">x</span>-token<br>// <span class="hljs-title">@param</span> <span class="hljs-keyword">x</span>-token header string <span class="hljs-keyword">true</span> <span class="hljs-string">&quot;Authorization&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Swaggo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第3章 Kubernetes的安装与部署</title>
    <link href="/2022/07/17/%E7%AC%AC3%E7%AB%A0-Kubernetes%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/"/>
    <url>/2022/07/17/%E7%AC%AC3%E7%AB%A0-Kubernetes%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<p>在虚拟机上部署Kubernetes运行环境，集群构成如下</p><table><thead><tr><th>节点类型</th><th>节点名称</th><th>IP地址</th></tr></thead><tbody><tr><td>Master</td><td>k8smaster</td><td>192.168.100.100</td></tr><tr><td>Node</td><td>k8snode1</td><td>192.168.100.101</td></tr><tr><td>Node</td><td>k8snode2</td><td>192.168.100.102</td></tr><tr><td>Node</td><td>k8snode3</td><td>192.168.100.103</td></tr></tbody></table><p>​给Master分配更多的内存和CPU，以减少异常的产生。</p><p>​在开始安装之前，请先在各台机器上配置好相应的主机，以便各台机器之间可通过机器名称相互访问。可通过如下命令编辑hosts文件。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vi <span class="hljs-regexp">/etc/</span>hosts<br></code></pre></td></tr></table></figure><p>​hosts的配置如下。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.100.100</span> k8smaster<br><span class="hljs-number">192.168.100.101</span> k8snode1<br><span class="hljs-number">192.168.100.102</span> k8snode2<br><span class="hljs-number">192.168.100.103</span> k8snode3<br></code></pre></td></tr></table></figure><h1 id="1-Master与Node都要安装的基础组件"><a href="#1-Master与Node都要安装的基础组件" class="headerlink" title="1. Master与Node都要安装的基础组件"></a>1. Master与Node都要安装的基础组件</h1><h2 id="1-在CentOS以及RHEL和Fedora系统上安装基础组件"><a href="#1-在CentOS以及RHEL和Fedora系统上安装基础组件" class="headerlink" title="1. 在CentOS以及RHEL和Fedora系统上安装基础组件"></a>1. 在CentOS以及RHEL和Fedora系统上安装基础组件</h2><p>首先安装并启动docker</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">[root@iZbp1f3y0av6g5d4zhb3uoZ ~]# yum-config-manager --<span class="hljs-built_in">add</span>-repo http://mirrors.aliyun.<span class="hljs-keyword">com</span>/docker-<span class="hljs-keyword">ce</span>/linux/centos/docker-<span class="hljs-keyword">ce</span>.repo<br>-bash: yum-config-manager: 未找到命令<br></code></pre></td></tr></table></figure><p>um-config-manager: command not found，这个是因为系统默认没有安装这个命令，这个命令在yum-utils 包里。安装命令：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum -y <span class="hljs-keyword">install</span> yum-utils<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs subunit">[root@iZbp1f3y0av6g5d4zhb3uoZ ~]# yum -y install yum-utils<br>已加载插件：fastestmirror<br>Determining fastest mirrors<br>base                                                                                                                                                                          | 3.6 kB  00:00:00<br>epel                                                                                                                                                                          | 4.7 kB  00:00:00<br>extras                                                                                                                                                                        | 2.9 kB  00:00:00<br>updates                                                                                                                                                                       | 2.9 kB  00:00:00<br>(1/4): extras/7/x86_64/primary_db                                                                                                                                             | 247 kB  00:00:00<br>(2/4): epel/x86_64/primary_db                                                                                                                                                 | 7.0 MB  00:00:00<br>(3/4): epel/x86_64/updateinfo                                                                                                                                                 | 1.1 MB  00:00:00<br>(4/4): updates/7/x86_64/primary_db                                                                                                                                            |  16 MB  00:00:00<br>正在解决依赖关系<br>--&gt; 正在检查事务<br>---&gt; 软件包 yum-utils.noarch.0.1.1.31<span class="hljs-string">-54</span>.el7_8 将被 安装<br>--&gt; 正在处理依赖关系 python-kitchen，它被软件包 yum-utils<span class="hljs-string">-1</span>.1.31<span class="hljs-string">-54</span>.el7_8.noarch 需要<br>--&gt; 正在处理依赖关系 libxml2-python，它被软件包 yum-utils<span class="hljs-string">-1</span>.1.31<span class="hljs-string">-54</span>.el7_8.noarch 需要<br>--&gt; 正在检查事务<br>---&gt; 软件包 libxml2-python.x86_64.0.2.9.1<span class="hljs-string">-6</span>.el7_9.6 将被 安装<br>--&gt; 正在处理依赖关系 libxml2 = 2.9.1<span class="hljs-string">-6</span>.el7_9.6，它被软件包 libxml2-python<span class="hljs-string">-2</span>.9.1<span class="hljs-string">-6</span>.el7_9.6.x86_64 需要<br>---&gt; 软件包 python-kitchen.noarch.0.1.1.1<span class="hljs-string">-5</span>.el7 将被 安装<br>--&gt; 正在处理依赖关系 python-chardet，它被软件包 python-kitchen<span class="hljs-string">-1</span>.1.1<span class="hljs-string">-5</span>.el7.noarch 需要<br>--&gt; 正在检查事务<br>---&gt; 软件包 libxml2.x86_64.0.2.9.1<span class="hljs-string">-6</span>.el7_2.3 将被 升级<br>---&gt; 软件包 libxml2.x86_64.0.2.9.1<span class="hljs-string">-6</span>.el7_9.6 将被 更新<br>---&gt; 软件包 python-chardet.noarch.0.2.2.1<span class="hljs-string">-3</span>.el7 将被 安装<br>--&gt; 解决依赖关系完成<br><br>依赖关系解决<br><br>=====================================================================================================================================================================================================<br> Package                                            架构                                       版本                                                源                                           大小<br>=====================================================================================================================================================================================================<br>正在安装:<br> yum-utils                                          noarch                                     1.1.31<span class="hljs-string">-54</span>.el7_8                                     base                                        122 k<br>为依赖而安装:<br> libxml2-python                                     x86_64                                     2.9.1<span class="hljs-string">-6</span>.el7_9.6                                     updates                                     247 k<br> python-chardet                                     noarch                                     2.2.1<span class="hljs-string">-3</span>.el7                                         base                                        227 k<br> python-kitchen                                     noarch                                     1.1.1<span class="hljs-string">-5</span>.el7                                         base                                        267 k<br>为依赖而更新:<br> libxml2                                            x86_64                                     2.9.1<span class="hljs-string">-6</span>.el7_9.6                                     updates                                     668 k<br><br>事务概要<br>=====================================================================================================================================================================================================<br>安装  1 软件包 (<span class="hljs-string">+3</span> 依赖软件包)<br>升级           ( 1 依赖软件包)<br><br>总下载量：1.5 M<br>Downloading packages:<br>Delta RPMs disabled because /usr/bin/applydeltarpm not installed.<br>(1/5): libxml2-python<span class="hljs-string">-2</span>.9.1<span class="hljs-string">-6</span>.el7_9.6.x86_64.rpm                                                                                                                              | 247 kB  00:00:00<br>(2/5): python-kitchen<span class="hljs-string">-1</span>.1.1<span class="hljs-string">-5</span>.el7.noarch.rpm                                                                                                                                  | 267 kB  00:00:00<br>(3/5): python-chardet<span class="hljs-string">-2</span>.2.1<span class="hljs-string">-3</span>.el7.noarch.rpm                                                                                                                                  | 227 kB  00:00:00<br>(4/5): yum-utils<span class="hljs-string">-1</span>.1.31<span class="hljs-string">-54</span>.el7_8.noarch.rpm                                                                                                                                   | 122 kB  00:00:00<br>(5/5): libxml2<span class="hljs-string">-2</span>.9.1<span class="hljs-string">-6</span>.el7_9.6.x86_64.rpm                                                                                                                                     | 668 kB  00:00:00<br>-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------<br>总计                                                                                                                                                                 2.7 MB/s | 1.5 MB  00:00:00<br>Running transaction check<br>Running transaction test<br>Transaction test succeeded<br>Running transaction<br>  正在更新    : libxml2<span class="hljs-string">-2</span>.9.1<span class="hljs-string">-6</span>.el7_9.6.x86_64                                                                                                                                                   1/6<br>  正在安装    : libxml2-python<span class="hljs-string">-2</span>.9.1<span class="hljs-string">-6</span>.el7_9.6.x86_64                                                                                                                                            2/6<br>  正在安装    : python-chardet<span class="hljs-string">-2</span>.2.1<span class="hljs-string">-3</span>.el7.noarch                                                                                                                                                3/6<br>  正在安装    : python-kitchen<span class="hljs-string">-1</span>.1.1<span class="hljs-string">-5</span>.el7.noarch                                                                                                                                                4/6<br>  正在安装    : yum-utils<span class="hljs-string">-1</span>.1.31<span class="hljs-string">-54</span>.el7_8.noarch                                                                                                                                                 5/6<br>  清理        : libxml2<span class="hljs-string">-2</span>.9.1<span class="hljs-string">-6</span>.el7_2.3.x86_64                                                                                                                                                   6/6<br>  验证中      : python-chardet<span class="hljs-string">-2</span>.2.1<span class="hljs-string">-3</span>.el7.noarch                                                                                                                                                1/6<br>  验证中      : libxml2<span class="hljs-string">-2</span>.9.1<span class="hljs-string">-6</span>.el7_9.6.x86_64                                                                                                                                                   2/6<br>  验证中      : libxml2-python<span class="hljs-string">-2</span>.9.1<span class="hljs-string">-6</span>.el7_9.6.x86_64                                                                                                                                            3/6<br>  验证中      : python-kitchen<span class="hljs-string">-1</span>.1.1<span class="hljs-string">-5</span>.el7.noarch                                                                                                                                                4/6<br>  验证中      : yum-utils<span class="hljs-string">-1</span>.1.31<span class="hljs-string">-54</span>.el7_8.noarch                                                                                                                                                 5/6<br>  验证中      : libxml2<span class="hljs-string">-2</span>.9.1<span class="hljs-string">-6</span>.el7_2.3.x86_64                                                                                                                                                   6/6<br><br>已安装:<br>  yum-utils.noarch 0:1.1.31<span class="hljs-string">-54</span>.el7_8<br><br>作为依赖被安装:<br>  libxml2-python.x86_64 0:2.9.1<span class="hljs-string">-6</span>.el7_9.6                             python-chardet.noarch 0:2.2.1<span class="hljs-string">-3</span>.el7                             python-kitchen.noarch 0:1.1.1<span class="hljs-string">-5</span>.el7<br><br>作为依赖被升级:<br>  libxml2.x86_64 0:2.9.1<span class="hljs-string">-6</span>.el7_9.6<br><br>完毕！<br></code></pre></td></tr></table></figure><p>然后继续：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> yum makecache fast<br><span class="hljs-variable">$</span> yum <span class="hljs-literal">-y</span> install docker<span class="hljs-literal">-ce</span><br><span class="hljs-variable">$</span> systemctl <span class="hljs-built_in">start</span> docker<br></code></pre></td></tr></table></figure><p>安装完成，测试命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> hello-world<br></code></pre></td></tr></table></figure><p>然后安装K8S关键组件</p><p>配置安装源地址</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/yum</span>.repos.d/Kubernetes.repo<br></code></pre></td></tr></table></figure><p>修改内容：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">[Kubernetes]<br>name=Kubernetes<br>baseurl=https:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/Kubernetes/yum</span><span class="hljs-regexp">/repos/</span>Kubernetes<br>-el7-x86_64/<br>enabled=<span class="hljs-number">1</span><br>gpgcheck=<span class="hljs-number">1</span><br>repo_gpgcheck=<span class="hljs-number">1</span><br>gpgkey=https:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/Kubernetes/yum</span><span class="hljs-regexp">/doc/yum</span>-key.gpg <br>https:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/Kubernetes/yum</span><span class="hljs-regexp">/doc/</span>rpm-package-key.gpg<br></code></pre></td></tr></table></figure><p>安装K8S关键组件：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> setenforce <span class="hljs-number">0</span><br><span class="hljs-variable">$</span> yum install <span class="hljs-literal">-y</span> kubelet kubeadm kubectl<br><span class="hljs-variable">$</span> systemctl enable kubelet &amp;&amp; systemctl <span class="hljs-built_in">start</span> kubelet<br></code></pre></td></tr></table></figure><p><img src="/Users/wuyuxian/Library/Application%20Support/typora-user-images/image-20220730160742043.png"></p><p>……</p><p>太烦了，不想装了，直接用团队现成的吧</p><h2 id="2-Master安装与配置"><a href="#2-Master安装与配置" class="headerlink" title="2. Master安装与配置"></a>2. Master安装与配置</h2><p>跳过…</p><h2 id="3-Node安装与配置"><a href="#3-Node安装与配置" class="headerlink" title="3.Node安装与配置"></a>3.Node安装与配置</h2><p>跳过</p>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第2章 K8S的核心概念</title>
    <link href="/2022/07/17/%E7%AC%AC2%E7%AB%A0-K8S%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
    <url>/2022/07/17/%E7%AC%AC2%E7%AB%A0-K8S%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<blockquote><p>容器有效管理需要考虑：</p><ul><li>组件复制；</li><li>自动缩放；</li><li>负载均衡；</li><li>滚动更新；</li><li>组件记录；</li><li>监测和健康检查；</li><li>服务发现；</li><li>认证。</li></ul><p>由Google内部的Brog演变而来的Kubernetes完美地解决了这一问题</p></blockquote><h1 id="2-1-Kubernetes的设计架构"><a href="#2-1-Kubernetes的设计架构" class="headerlink" title="2.1 Kubernetes的设计架构"></a>2.1 Kubernetes的设计架构</h1><h2 id="Master和Node"><a href="#Master和Node" class="headerlink" title="Master和Node"></a>Master和Node</h2><p>K8S集群之中，由Master和Node两种角色，Master管理Node，Node管理容器</p><h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><p>Master主要负责整个集群的管理控制，相当于整个Kubernetes集 群的首脑。它用于监控、编排、调度集群中的各个工作节点。通常 Master会占用一台独立的服务器，基于高可用原因，也有可能是多台。</p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Node则是Kubernetes集群中的各个工作节点。Node由Master管理，提供运行容器所需的各种环境，对容器进行实际的控制，而这些容器会提供实际的应用服务。</p><h4 id="Kubernetes的整体架构"><a href="#Kubernetes的整体架构" class="headerlink" title="Kubernetes的整体架构"></a>Kubernetes的整体架构</h4><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/image-20220717070231850.png" alt="Kubernetes的整体架构"></p><h2 id="2-1-1-Master"><a href="#2-1-1-Master" class="headerlink" title="2.1.1 Master"></a>2.1.1 Master</h2><h3 id="1-API-Server进程"><a href="#1-API-Server进程" class="headerlink" title="1.API Server进程"></a>1.API Server进程</h3><p>API Server（kube-apiserver）进程为Kubernetes中各类资源对象提供了&#x3D;&#x3D;增删改查等HTTP REST接口&#x3D;&#x3D;。对于资源的任何操作，都需要经过API Server进程来处理。除此之外，API Server进程还提供了一系列&#x3D;&#x3D;认证授权机制&#x3D;&#x3D;。</p><h4 id="访问API-Server进程"><a href="#访问API-Server进程" class="headerlink" title="访问API Server进程"></a>访问API Server进程</h4><h4 id="Master组成"><a href="#Master组成" class="headerlink" title="Master组成"></a>Master组成</h4><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/image-20220717070601701.png" alt="image-20220717070601701"></p><h4 id="三种访问API-Server进程的方式"><a href="#三种访问API-Server进程的方式" class="headerlink" title="三种访问API Server进程的方式"></a>三种访问API Server进程的方式</h4><ul><li><p>直接通过REST Request</p></li><li><p>通过官方提供的客户端库文件来访问，本质上，通过编程方式，转换为对API Server进程的REST API调用。</p></li><li><p>通过命令行工具kubectl客户端来访问。kubectl客户端将把命令</p><p>行转换为对API Server进程的REST API调用。</p></li></ul><h3 id="2-etcd"><a href="#2-etcd" class="headerlink" title="2.etcd"></a>2.etcd</h3><p>etcd项目是一种轻量级的分布式键值存储，由CoreOS团队开发，可以在单台Master服务器上配置，也可以配置到多台服务器。</p><p>可以将etcd理解为Kubernetes的“&#x3D;&#x3D;数据库&#x3D;&#x3D;”，用于保存集群中所有的配置和各个对象的状态信息。</p><p>只有API Server进程才能直接访问和操作etcd。</p><h3 id="3-调度器"><a href="#3-调度器" class="headerlink" title="3.调度器"></a>3.调度器</h3><p>调度器（kube-scheduler）是Pod资源的调度器。它用于监听最近创建但还未分配Node的Pod资源，会为Pod自动分配相应的Node。</p><p>调度器所执行的各项操作均是&#x3D;&#x3D;基于API Server进程&#x3D;&#x3D;的。如调度器会通过API Server进程的Watch接口监听新建的Pod，并搜索所有满足Pod需求的Node列表，再执行Pod调度逻辑。调度成功后会将Pod绑定到目标Node上。</p><h3 id="4-控制器管理器（kube-controller-manager）"><a href="#4-控制器管理器（kube-controller-manager）" class="headerlink" title="4.控制器管理器（kube-controller-manager）"></a>4.控制器管理器（kube-controller-manager）</h3><p>Kubernetes集群的大部分功能是由控制器执行的。</p><p>每个控制器都是一个独立进程，为了降低复杂度，都被编译、合并到单个文件夹中，并在单个进程中进行。</p><ul><li>Node 控制器：负责在Node出现故障时做出响应。</li><li>Replication控制器：负责对系统中的每个</li><li>ReplicationController对象维护正确数量的Pod。</li><li>Endpoint 控制器：负责生成和维护所有Endpoint对象的控制器。</li><li>Endpoint控制器用于监听Service和对应的Pod副本的变化。</li><li>ServiceAccount及Token 控制器：为新的命名空间创建默认账户和API访问令牌。</li></ul><p>kube-controller-manager所执行的各项操作也是基于API Server进程的。例如，Node控制器会通过API Server进程提供的Watch接口，实时监控Node的信息并进行相应处理。</p><h2 id="2-1-2-Node"><a href="#2-1-2-Node" class="headerlink" title="2.1.2 Node"></a>2.1.2 Node</h2><p>Node主要由3个部分组成，分别是kubelet、kube-proxy和容器运行时（container runtime）</p><h3 id="Node的组成"><a href="#Node的组成" class="headerlink" title="Node的组成"></a>Node的组成</h3><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/image-20220717072049811.png" alt="image-20220717072049811"></p><h3 id="1-kubelet"><a href="#1-kubelet" class="headerlink" title="1.kubelet"></a>1.kubelet</h3><p>​kubelet是在每个Node上都运行的&#x3D;&#x3D;主要代理进程&#x3D;&#x3D;。kubelet以<strong>PodSpec</strong>为单位来运行任务，<strong>PodSpec是一种描述Pod的YAML或JSON对象。</strong><u>kubelet会运行由各种机制提供（主要通过API Server）的一系列PodSpec，并确保这些PodSpec中描述的容器健康运行。</u>不是Kubernetes创建的容器将不属于kubelet的管理范围。<strong>kubelet负责维护容器的生命周期，同时也负责存储卷（volume）等资源的管理。</strong></p><p>​每个Node上的kubelet会<strong>定期调用</strong>Master节点上API Server进程的<strong>REST接口</strong>，报告自身状态。API Server进程接收这些信息后，<u>会将Node的状态信息更新到etcd中</u>。kubelet也通过API Server进程的<strong>Watch接口</strong>监听Pod信息，从而对Node上的Pod进行管理。</p><h3 id="2-kube-proxy"><a href="#2-kube-proxy" class="headerlink" title="2.kube-proxy"></a>2.kube-proxy</h3><p>kube-proxy主要用于<u>管理Service的访问入口</u>，包括从集群内的其他Pod到Service的访问，以及从集群外访问Service。</p><h3 id="3-容器运行时"><a href="#3-容器运行时" class="headerlink" title="3.容器运行时"></a>3.容器运行时</h3><p>容器运行时是负责运行容器的软件。Kubernetes支持多种运行时，包括Docker、containerd、cri-o、rktlet以及任何基于<strong>Kubernetes CRI（容器运行时接口）</strong>的实现。</p><h2 id="2-1-3-组件间的基本交互流程"><a href="#2-1-3-组件间的基本交互流程" class="headerlink" title="2.1.3 组件间的基本交互流程"></a>2.1.3 组件间的基本交互流程</h2><h3 id="kubectl创建Pod"><a href="#kubectl创建Pod" class="headerlink" title="kubectl创建Pod"></a>kubectl创建Pod</h3><p>当使用kubectl创建Pod时，会相继发生以下事件。</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/image-20220717072958350.png" alt="image-20220717072958350"></p><h4 id="具体发生事件"><a href="#具体发生事件" class="headerlink" title="具体发生事件"></a>具体发生事件</h4><p>（1）kubectl命令将转换为对API Server的调用。</p><p>（2）API Server验证请求并将其保存到etcd中。</p><p>（3）etcd通知API Server。</p><p>（4）API Server调用调度器。</p><p>（5）调度器决定在哪个节点运行Pod，并将其返回给APIServer。</p><p>（6）API Server将对应节点保存到etcd中。</p><p>（7）etcd通知API Server。</p><p>（8）API Server在相应的节点中调用kubelet。</p><p>（9）kubelet与容器运行时API发生交互，与容器守护进程通信以创建容器。</p><p>（10）kubelet将Pod状态更新到API Server中。</p><p>（11）API Server把最新的状态保存到etcd中。</p><h1 id="2-2-Kubernetes的核心对象"><a href="#2-2-Kubernetes的核心对象" class="headerlink" title="2.2 Kubernetes的核心对象"></a>2.2 Kubernetes的核心对象</h1><p>虽然应用程序部署的底层机制是容器，但Kubernetes在容器接口上使用了<strong>额外的抽象层</strong>，以支持<strong>弹性伸缩和生命周期管理的功能</strong>。用户并不是直接管理容器的，而是<u>定义由Kubernetes对象模型提供的各种基本类型的实例</u>，并与这些实例进行交互。</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/image-20220717073401326.png" alt="image-20220717073401326"></p><h2 id="2-2-1-Pod"><a href="#2-2-1-Pod" class="headerlink" title="2.2.1 Pod"></a>2.2.1 Pod</h2><blockquote><p> Pod是Kubernetes处理的最基本单元。容器本身并不会直接分配到主机上，而是会封装到名为Pod的对象中。</p></blockquote><p>​Pod通常表示单个应用程序，由一个或多个关系紧密的容器构成。</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/image-20220717073548873.png" alt="image-20220717073548873"></p><p>​<u>这些容器拥有同样的生命周期，作为一个整体一起编排到Node上。</u>这些容器共享环境、存储卷和IP空间。尽管Pod基于一个或多个容器，但应将Pod视作<strong>单一的整体、单独的应用程序</strong>。<u>Kubernetes以Pod为最小单位进行调度、伸缩并共享资源、管理生命周期。</u></p><p>​一般来说，用户不应自行管理Pod，因为Pod并没有提供应用程序通常会用到的一些特性，如复杂的生命周期管理及动态伸缩。建议用户使用将Pod或Pod模板作为基本组件的更高级别对象，这些对象会拥有更多的特性。</p><h2 id="2-2-2-控制器"><a href="#2-2-2-控制器" class="headerlink" title="2.2.2 控制器"></a>2.2.2 控制器</h2><p>​一般来说，用户不会直接创建Pod，而是<strong>创建控制器</strong>，<u>让控制器来管理Pod</u>。在控制器中定义Pod的部署方式（如有多少个副本、需要在哪种Node上运行等），根据不同的业务场景，Kubernetes提供了多种控制器。</p><h3 id="1．ReplicationController和ReplicaSet控制器"><a href="#1．ReplicationController和ReplicaSet控制器" class="headerlink" title="1．ReplicationController和ReplicaSet控制器"></a>1．ReplicationController和ReplicaSet控制器</h3><p>​在使用Kubernetes时，<u>通常要管理的是由多个相同Pod组成的Pod集合，而不是单个Pod。</u></p><p>例如，ReplicationController或ReplicaSet控制器基于Pod模板进行创建，能够很好地支持<strong>水平伸缩</strong>。</p><p>​<strong>ReplicationController可定义Pod模板</strong>，<u>并可以设置相应控制参数以实现水平伸缩</u>，以调节正在运行的相同的Pod数。这是在Kubernetes中<strong>调节负载并增强可用性</strong>的简单方式。</p><p>​ReplicationController能根据需要自动创建新的Pod，在ReplicationController的配置中<strong>拥有和Pod定义非常相似的模板。</strong></p><p>​ReplicationController<u>负责保证在集群中部署的Pod数量与配置中的Pod数量一致</u>。如果Pod或主机出现故障，ReplicationController会自动<strong>启用新的Pod进行补充</strong>。如果ReplicationController<u>配置中的副本数量发生改变</u>，则会<strong>启动或终止一些Pod来匹配设定好的数量</strong>。ReplicationController还可以<strong>执行滚动更新</strong>，将一组Pod逐个切换到</p><p>最新版本，从而最大限度地减少对应用程序可用性的影响。</p><p>​<strong>ReplicaSet控制器</strong>可以看作ReplicationController的另一种版本，其Pod识别功能使它在Pod管理上更具灵活性。由于ReplicaSet控制器具有<strong>副本筛选功能</strong>，因此ReplicaSet控制器才有逐渐取代ReplicationController的趋势，但ReplicaSet控制器<strong>无法实现滚动更新</strong>，无法像ReplicationController那样在后端轮流切换到最新版本。</p><p>​与Pod一样，ReplicationController和ReplicaSet控制器都是很少直接使用的对象。虽然它们都是基于Pod而设计的，增加了水平伸缩功能，提高了可靠性，但它们缺少一些在其他复杂对象中具有的更细粒度的生命周期管理功能。</p><h3 id="2-Deployment控制器"><a href="#2-Deployment控制器" class="headerlink" title="2.Deployment控制器"></a>2.Deployment控制器</h3><p>​<strong>Deployment控制器可能是最常用的工作负载对象之一。</strong>Deployment控制器以<u><strong>ReplicaSet控制器</strong>为基础</u>，是更高级的概念，<u>增加了更灵活的生命周期管理功能</u>。</p><p>​虽然Deployment控制器是<strong>基于ReplicaSet控制器</strong>的，<u>但仍有部分功能和ReplicationController相似</u>Deployment控制器解决了之前在滚动更新上存在的诸多难点。如果用ReplicationController来更新应用程序，用户需要提交一个<u>新的ReplicationController计划，以替换当前的控制器</u>。因此，对于历史记录跟踪、更新出现网络故障时的恢复以及回滚错误修改等任务，ReplicationController要么做起来非常艰难，要么需要用户自理。</p><p>​<strong>Deployment控制器是一种高级对象</strong>，<strong>旨在简化Pod的生命周期管理</strong>。<u>只要简单更改Deployment控制器的配置文件，Kubernetes就会自动调节ReplicaSet控制器，管理应用程序不同版本之间的切换，还可以实现自动维护事件历史记录及自动撤销功能</u>，如图所示。正是由于这些强大的功能，Deployment控制器可能是使用频率最高的对象。</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/image-20220717081533254.png" alt="image-20220717081533254"></p><h3 id="3-StatefulSet控制器"><a href="#3-StatefulSet控制器" class="headerlink" title="3. StatefulSet控制器"></a>3. StatefulSet控制器</h3><p>​<strong>StatefulSet控制器是一种提供了排序和唯一性保证的特殊Pod控制器。</strong>当有与部署顺序、持久数据或固定网络等相关的特殊需求时，可以使用StatefulSet控制器来进行更细粒度的控制。StatefulSet控制器主要用于有状态的应用，例如，StatefulSet控制器通常与面向数据的应用程序（比如数据库）相关联。即使StatefulSet控制器被重新分配到一个新的节点上，还需要访问同一个存储卷。</p><p>​<strong>StatefulSet控制器为每个Pod创建唯一的、基于数字的名称，从而提供稳定的网络标识符。</strong>即使要将Pod转移到另一个节点，该名称也将持续存在。同样，<strong>当需要重新调度时，可以通过Pod转移持久性数据卷</strong>。即使删除了Pod，这些卷也依然存在，以防止数据意外丢失。</p><p>​每当部署或进行伸缩调节时，StatefulSet控制器会根据名称中的<strong>标识符</strong>执行操作，这使得对执行顺序有了更大的<strong>可预测性和控制能力</strong>，它在某些情况下很有用。</p><p>​Deployment控制器下的每一个Pod都毫无区别地提供服务，但StatefulSet控制器下的Pod则不同。虽然各个Pod的定义是一样的，但是因为其数据的不同，所以<strong>提供的服务是有差异的</strong>。比如分布式存储系统适合使用StatefulSet控制器，由Pod A存储一部分数据并提供相关服务，Pod B又存储另一部分数据并提供相关服务。又比如有些服务会临时保存客户请求的数据，例如，使用服务端会话方式存放部分信息的业务网站，由于会话的不同，Pod A和Pod B能提供的服务也不尽相同，这种场景也适合使用StatefulSet控制器。</p><h3 id="4-DaemonSet"><a href="#4-DaemonSet" class="headerlink" title="4.DaemonSet"></a>4.DaemonSet</h3><p>​<strong>DaemonSet控制器是另一种特殊的Pod控制器，它会在集群的各个节点上运行单一的Pod副本</strong>。<strong>DaemonSet控制器非常适合部署那些为节点本身提供服务或执行维护的Pod。</strong></p><p>​例如，日志收集和转发、监控以及运行以增加节点本身功能为目的的服务，常设置为DaemonSet控制器。因为DaemonSet控制器通常是用于提供基本服务的，并且每个节点都需要，所以它们可以绕过某些用于阻止控制器将Pod分配给某些主机的调度限制。<u>因为DaemonSet控制器独特的职责，原本Master服务器不可用于常规的Pod调度，但DaemonSet控制器可以越过基于Pod的限制，确保基础服务的运行。</u></p><h3 id="5-Job控制器和CronJob控制器"><a href="#5-Job控制器和CronJob控制器" class="headerlink" title="5.Job控制器和CronJob控制器"></a>5.Job控制器和CronJob控制器</h3><p>​上述的各类工作负载对象都是长期运行的，拥有服务级的生命周期。Kubernetes中还有一种叫作Job控制器的工作负载对象，它基于特定任务而运行。当运行任务的容器完成工作后，Job就会成功退出。<strong>如果需要执行一次性的任务，而非提供连续的服务，Job控制器非常适合。</strong></p><p>​CronJob控制器其实在Job控制器的基础上增加了<strong>时间调度</strong>，可以在给定的时间点运行一个任务，也可以周期性地在给定时间点运行一个任务。CronJob控制器实际上和Linux系统中的Crontab控制器非常类似。</p><h2 id="2-2-3-服务与存储"><a href="#2-2-3-服务与存储" class="headerlink" title="2.2.3 服务与存储"></a>2.2.3 服务与存储</h2><h3 id="1-Service组件和Ingress"><a href="#1-Service组件和Ingress" class="headerlink" title="1. Service组件和Ingress"></a>1. Service组件和Ingress</h3><p>​在Kubernetes中，<strong>Service是内部负载均衡器中的一种组件</strong>，<strong>会将相同功能的Pod在逻辑上组合到一起，让它们表现得如同一个单一的实体。</strong></p><p>​之前介绍的各个工作负载对象只保证了支撑服务的微服务Pod的数量，但是没有解决如何访问这些服务的问题。Pod只是一个运行的应用示例，随时可能在一个节点上停止，并在另一个节点使用新的IP地址启动新的Pod，因此<strong>Pod根本无法以固定的IP地址和端口号提供服务</strong>。</p><p>​<strong>通过Service组件可以发布服务，可以跟踪并路由到所有指定类型的后端容器。</strong><u>内部使用者只需要知道Service组件提供的稳定端点即可进行访问。</u>另外，Service组件抽象可以根据需要来伸缩或替换后端的工作单元，无论Service组件具体路由到哪个Pod，其IP地址都保持稳定。通过Service组件，可以轻松获得服务发现的能力，如图。</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/image-20220717084013464.png" alt="image-20220717084013464"></p><p>​<u>每当需要给另一个应用程序或外部用户提供某些Pod的访问权限时，就可以配置一个Service组件。</u>比如，假设需要从外网访问Pod上运行的应用程序，就需要提供必要的Service组件抽象。同样，如果应用程序需要存储或查询数据，则可能还需要配置一个内部Service组件抽象，使应用程序能访问数据库Pod。</p><p>​<u>虽然在默认情况下只有Kubernetes集群内的机器（Master和Node）以及Pod应用可以访问Service组件，但通过某些策略，可以在集群之外使用Service组件。</u>例如，通过配置NodePort，可以在各个节点的外部网络接口上打开一个静态端口。该外部端口的流量将会通过内部集群IP服务自动路由到相应的Pod。</p><p>​还可以<strong>通过Ingress来整合Service组件</strong>。Ingress并不是某种服务类型，可以充当多个Service组件的统一入口。Ingress支持将路由规则合并到单个资源中，可以通过同一域名或IP地址下不同的路径来访问不同的Service组件，如图所示，实现在同一域名或IP地址下发布多个服务。</p><p>​<img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/image-20220717084449753.png" alt="image-20220717084449753"></p><h3 id="2-存储卷和持久存储卷"><a href="#2-存储卷和持久存储卷" class="headerlink" title="2.存储卷和持久存储卷"></a>2.存储卷和持久存储卷</h3><p>​容器运行时通常会提供一些机制来将存储附加到容器上，以此实现共享数据并保证这些数据在容器重启的间隙始终是可用的，这类容器的存留时间超过其他容器的生命周期，但实现起来通常缺乏灵活性</p><p>​为了解决这些问题，<strong>Kubernetes定义了自己的存储卷（volume）抽象，允许Pod中的所有容器共享数据，并在Pod终止之前一直保持可用</strong>，如图所示。</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/image-20220717085104634.png" alt="image-20220717085104634"></p><p>​这意味着紧密耦合的Pod可以轻松共享文件而不需要复杂的外部机制，Pod中的容器故障不会影响对共享文件的访问。Pod终止后，共享的存储卷会被销毁，因此对于真正需要持久化的数据来说，这并非一个好的解决方案。</p><p>​<strong>持久存储卷（persistent volume）是一种更健壮的抽象机制</strong>，<strong>不依赖于Pod的生命周期</strong>。<u>持久存储卷允许管理员为集群配置存储资源，用户可以为正在运行的Pod请求和声明存储资源。</u>带有持久存储卷的Pod一旦使用完毕，存储卷的回收策略将决定是保留存储卷（直到手动删除），还是立即删除数据。持久性数据可预防节点级的故障，并分配比本地更多的可用存储空间。</p><h2 id="2-2-4-资源划分"><a href="#2-2-4-资源划分" class="headerlink" title="2.2.4 资源划分"></a>2.2.4 资源划分</h2><h3 id="1-命名空间"><a href="#1-命名空间" class="headerlink" title="1. 命名空间"></a>1. 命名空间</h3><p>​命名空间（namespace）的主要作用是对Kubernetes集群资源进行划分。这种划分并非物理划分而是逻辑划分，用于实现多租户的资源隔离。</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/image-20220717092408558.png" alt="image-20220717092408558"></p><h3 id="2-标签和注解"><a href="#2-标签和注解" class="headerlink" title="2. 标签和注解"></a>2. 标签和注解</h3><p>​Kubernetes中的标签（label）是一种<strong>语义化标记</strong>，<u>可以附加到Kubernetes对象上，对它们进行标记或划</u>分。如果要针对不同的实例进行管理或路由，可以用标签来进行选择。例如，每种基于控制器的对象都可以使用标签来识别需要操作的Pod。Service组件也可以使用标签来确定应该将请求路由到哪些后端Pod，如图所示。</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/image-20220717092719027.png" alt="image-20220717092719027"></p><p>​<strong>标签的形式是键值对，每个单元可以拥有多个标签，但每个单元对于每个键只能拥有一个值。</strong>通常来说，相对于当作标识符的name属性，标签的使用更像是对资源进行划分细类，可以用开发阶段、可访问性级别、应用程序版本等标准对各个对象进行分类。</p><p>​<strong>注解（annotation）也是一种类似的机制，用于将任意键值信息附加到某一对象中。</strong>相对于标签，注解更灵活，可以包含少量结构化数据。一般来说，注解只是向对象添加更多元数据的一种方式，但并不用于筛选。</p><h1 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h1><h2 id="要点如下："><a href="#要点如下：" class="headerlink" title="要点如下："></a>要点如下：</h2><ul><li>Kubernetes集群主要由Master和Node组成。Master管理Node，Node管理容器。</li><li>Master的主要组件分别为kube-apiserver（负责实际操作）、etcd（负责存储）、kube-scheduler（负责Pod调度）、kubecontroller-manager（负责对象管理）。</li><li>Node的主要组件分别为kubelet（值守进程）、kube-proxy（负责服务发现）和容器运行时（负责操作容器）。</li><li>Kubernetes以Pod为最小单位进行调度、伸缩并共享资源、管理生命周期。</li><li>控制器中定义了Pod的部署方式，如有多少个副本、需要在哪种Node上运行等。根据不同的业务场景，Kubernetes提供了多种控制器，如ReplicationController、ReplicaSet控制器、Deployment控制器、StatefulSet控制器、DaemonSet控制器、Job控制器和CronJob控制器。</li><li>Service是内部负载均衡器中的一种组件，会将相同功能的Pod在逻辑上组合到一起，让它们表现得如同一个单一的实体。</li><li>Kubernetes定义了自己的存储卷抽象，允许Pod中的所有容器共享数据，在Pod终止之前一直保持可用。而持久存储卷是一种更健壮的抽象机制，不依赖于Pod的生命周期。</li><li>Label是一种语义化标签，可以附加到Kubernetes对象上，对它们进行标记或划分。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>K8S</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker快速入门</title>
    <link href="/2022/07/13/Docker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2022/07/13/Docker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Docker简介和安装"><a href="#1-Docker简介和安装" class="headerlink" title="1.Docker简介和安装"></a>1.Docker简介和安装</h1><blockquote><p>Docker是一个打包、分发、部署的工具</p><p>轻量虚拟机，只虚拟需要的运行环境</p></blockquote><h2 id="跟普通虚拟机的对比"><a href="#跟普通虚拟机的对比" class="headerlink" title="跟普通虚拟机的对比"></a>跟普通虚拟机的对比</h2><table><thead><tr><th>特性</th><th>普通虚拟机</th><th>Docker</th></tr></thead><tbody><tr><td>跨平台</td><td>通常只能在桌面级系统运行，例如 Windows&#x2F;Mac，无法在不带图形界面的服务器上运行</td><td>支持的系统非常多，各类 windows 和 Linux 都支持</td></tr><tr><td>性能</td><td>性能损耗大，内存占用高，因为是把整个完整系统都虚拟出来了</td><td>性能好，只虚拟软件所需运行环境，最大化减少没用的配置</td></tr><tr><td>自动化</td><td>需要手动安装所有东西</td><td>一个命令就可以自动部署好所需环境</td></tr><tr><td>稳定性</td><td>稳定性不高，不同系统差异大</td><td>稳定性好，不同系统都一样部署方式</td></tr></tbody></table><h2 id="打包、分发、部署"><a href="#打包、分发、部署" class="headerlink" title="打包、分发、部署"></a>打包、分发、部署</h2><p><strong>打包</strong>：把软件运行所需的依赖、第三方库、软件打包到一起，变成一个安装包</p><p><strong>分发</strong>：将打包好的“安装包”上传镜像仓库，方便他人获取安装</p><p><strong>部署</strong>：拿着“安装包”就可以一个命令运行应用，自动模拟出一样的运行环境，不管是何种操作系统。</p><h2 id="Docker部署的优势"><a href="#Docker部署的优势" class="headerlink" title="Docker部署的优势"></a>Docker部署的优势</h2><p><strong>常规应用开发部署方式</strong>：自己在Windows上开发、测试—-&gt;到Linux服务器配置运行环境部署</p><blockquote><p>问题：我机器上跑都没问题，怎么到服务器就各种问题了</p></blockquote><p><strong>Docker部署</strong>：Windows开发、测试 —-&gt;打包为Docker镜像 —-&gt;各种服务器上只需要一个命令部署好</p><blockquote><p>优点：确保了不同机器上跑都是一致的运行环境，不会出现我机器上跑正常，你机器跑就有问题的情况。</p></blockquote><h2 id="Docker-通常用来做什么"><a href="#Docker-通常用来做什么" class="headerlink" title="Docker 通常用来做什么"></a>Docker 通常用来做什么</h2><ul><li>应用分发、部署，方便传播给他人安装。特别是开源软件和提供私有部署的应用</li><li>快速安装测试&#x2F;学习软件，用完就丢（类似小程序），不把时间浪费在安装软件上。例如 Redis &#x2F; MongoDB &#x2F; ElasticSearch &#x2F; ELK</li><li>多个版本软件共存，不污染系统，例如 Python2、Python3，Redis4.0，Redis5.0</li><li>Windows 上体验&#x2F;学习各种 Linux 系统</li></ul><h2 id="重要概念：镜像、容器"><a href="#重要概念：镜像、容器" class="headerlink" title="重要概念：镜像、容器"></a>重要概念：镜像、容器</h2><p><strong>镜像</strong>：可以理解为软件安装包，可以方便的进行传播和安装。<br><strong>容器</strong>：软件安装后的状态，每个软件运行环境都是独立的、隔离的，称之为容器。</p><h2 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h2><h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a><a href="https://docs.docker.com/get-docker/">Docker安装</a></h3><h3 id="镜像加速源"><a href="#镜像加速源" class="headerlink" title="镜像加速源"></a>镜像加速源</h3><table><thead><tr><th>镜像加速器</th><th>镜像加速器地址</th></tr></thead><tbody><tr><td>Docker 中国官方镜像</td><td><a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></td></tr><tr><td>DaoCloud 镜像站</td><td><a href="http://f1361db2.m.daocloud.io/">http://f1361db2.m.daocloud.io</a></td></tr><tr><td>Azure 中国镜像</td><td><a href="https://dockerhub.azk8s.cn/">https://dockerhub.azk8s.cn</a></td></tr><tr><td>科大镜像站</td><td><a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></td></tr><tr><td>阿里云</td><td>https:&#x2F;&#x2F;<your_code>.mirror.aliyuncs.com</td></tr><tr><td>七牛云</td><td><a href="https://reg-mirror.qiniu.com/">https://reg-mirror.qiniu.com</a></td></tr><tr><td>网易云</td><td><a href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com</a></td></tr><tr><td>腾讯云</td><td><a href="https://mirror.ccs.tencentyun.com/">https://mirror.ccs.tencentyun.com</a></td></tr></tbody></table><h1 id="2-Docker快速安装软件"><a href="#2-Docker快速安装软件" class="headerlink" title="2.Docker快速安装软件"></a>2.Docker快速安装软件</h1><h2 id="直接安装的缺点"><a href="#直接安装的缺点" class="headerlink" title="直接安装的缺点"></a>直接安装的缺点</h2><ul><li>安装麻烦，可能有<strong>各种依赖</strong>，运行报错。例如：WordPress，ElasticSearch，Redis，ELK</li><li>可能对 <strong>Windows 并不友好</strong>，运行有各种<strong>兼容问题</strong>，软件只支持 Linux 上跑</li><li><strong>不方便安装多版本软件</strong>，不能共存。</li><li>电脑安装了一堆软件，拖慢电脑速度。</li><li>不同系统和硬件，安装方式不一样</li></ul><h2 id="Docker-安装的优点"><a href="#Docker-安装的优点" class="headerlink" title="Docker 安装的优点"></a>Docker 安装的优点</h2><ul><li><strong>一个命令</strong>就可以安装好，快速方便</li><li>有大量的<strong>镜像</strong>，可直接使用</li><li>没有<strong>系统兼容</strong>问题，Linux 专享软件也照样跑</li><li>支持软件<strong>多版本共存</strong></li><li>用完就丢，不拖慢电脑速度</li><li>不同系统和硬件，只要安装好 Docker 其他都一样了，一个命令搞定所有</li></ul><h2 id="Docker安装Redis"><a href="#Docker安装Redis" class="headerlink" title="Docker安装Redis"></a>Docker安装Redis</h2><p>Redis 官网：<a href="https://redis.io/">https://redis.io/</a></p><blockquote><p>官网下载安装教程只有源码安装方式，没有 Windows 版本。想要自己安装 windows 版本需要去找别人编译好的安装包。</p></blockquote><p>Docker官方镜像仓库查找Redis：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><p><img src="https://sjwx.easydoc.xyz/46901064/files/kv8zs4qr.png" alt="img"></p><p>一个命令跑起来：<code>docker run -d -p 6379:6379 --name redis redis:latest</code><br>命令参考：<a href="https://docs.docker.com/engine/reference/commandline/run/">https://docs.docker.com/engine/reference/commandline/run/</a></p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/pictureimage-20220715172116860.png" alt="image-20220715172116860"></p><h3 id="运行日志"><a href="#运行日志" class="headerlink" title="运行日志"></a>运行日志</h3><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/pictureimage-20220715172221689.png" style="zoom:80%;" /><h1 id="3-制作自己的镜像"><a href="#3-制作自己的镜像" class="headerlink" title="3.制作自己的镜像"></a>3.制作自己的镜像</h1><h3 id="为自己的-Web-项目构建镜像"><a href="#为自己的-Web-项目构建镜像" class="headerlink" title="为自己的 Web 项目构建镜像"></a>为自己的 Web 项目构建镜像</h3><p>示例项目代码：<a href="https://github.com/gzyunke/test-docker">https://github.com/gzyunke/test-docker</a><br>这是一个 Nodejs + Koa2 写的 Web 项目，提供了简单的两个演示页面。<br>软件依赖：<a href="https://nodejs.org/zh-cn/">nodejs</a><br>项目依赖库：koa、log4js、koa-router</p><blockquote><p>本文档课件配套 <a href="https://www.bilibili.com/video/BV11L411g7U1?p=3">视频教程</a></p></blockquote><h3 id="编写-Dockerfile"><a href="#编写-Dockerfile" class="headerlink" title="编写 Dockerfile"></a>编写 Dockerfile</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">11</span><br><span class="hljs-keyword">MAINTAINER</span> easydoc.net<br><br><span class="hljs-comment"># 复制代码</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> . /app</span><br><br><span class="hljs-comment"># 设置容器启动后的默认运行目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><br><span class="hljs-comment"># 运行命令，安装依赖</span><br><span class="hljs-comment"># RUN 命令可以有多个，但是可以用 &amp;&amp; 连接多个命令来减少层级。</span><br><span class="hljs-comment"># 例如 RUN npm install &amp;&amp; cd /app &amp;&amp; mkdir logs</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> npm install --registry=https://registry.npm.taobao.org</span><br><br><span class="hljs-comment"># CMD 指令只能一个，是容器启动后执行的命令，算是程序的入口。</span><br><span class="hljs-comment"># 如果还需要运行其他命令可以用 &amp;&amp; 连接，也可以写成一个shell脚本去执行。</span><br><span class="hljs-comment"># 例如 CMD cd /app &amp;&amp; ./start.sh</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> node app.js</span><br></code></pre></td></tr></table></figure><p><a href="https://docs.docker.com/engine/reference/builder/#run">Dockerfile文档</a></p><blockquote><p>实用技巧：<br>如果你写 Dockerfile 时经常遇到一些运行错误，依赖错误等，你可以直接运行一个依赖的底，然后进入终端进行配置环境，成功后再把做过的步骤命令写道 Dockerfile 文件中，这样编写调试会快很多。<br>例如上面的底是<code>node:11</code>，我们可以运行<code>docker run -it -d node:11 bash</code>，跑起来后进入容器终端配置依赖的软件，然后尝试跑起来自己的软件，最后把所有做过的步骤写入到 Dockerfile 就好了。<br>掌握好这个技巧，你的 Dockerfile 文件编写起来就非常的得心应手了。</p></blockquote><h3 id="Build-为镜像（安装包）和运行"><a href="#Build-为镜像（安装包）和运行" class="headerlink" title="Build 为镜像（安装包）和运行"></a>Build 为镜像（安装包）和运行</h3><p>编译 <code>docker build -t test:v1 .</code></p><blockquote><p><code>-t</code> 设置镜像名字和版本号<br>命令参考：<a href="https://docs.docker.com/engine/reference/commandline/build/">https://docs.docker.com/engine/reference/commandline/build/</a></p></blockquote><p>运行 <code>docker run -p 8080:8080 --name test-hello test:v1</code></p><blockquote><p><code>-p</code> 映射容器内端口到宿主机<br><code>--name</code> 容器名字<br><code>-d</code> 后台运行<br>命令参考文档：<a href="https://docs.docker.com/engine/reference/run/">https://docs.docker.com/engine/reference/run/</a></p></blockquote><h3 id="更多相关命令"><a href="#更多相关命令" class="headerlink" title="更多相关命令"></a>更多相关命令</h3><p><code>docker ps</code> 查看当前运行中的容器<br><code>docker images</code> 查看镜像列表<br><code>docker rm container-id</code> 删除指定 id 的容器<br><code>docker stop/start container-id</code> 停止&#x2F;启动指定 id 的容器<br><code>docker rmi image-id</code> 删除指定 id 的镜像<br><code>docker volume ls</code> 查看 volume 列表<br><code>docker network ls</code> 查看网络列表</p><h1 id="4-目录挂载"><a href="#4-目录挂载" class="headerlink" title="4.目录挂载"></a>4.目录挂载</h1><h2 id="现存问题"><a href="#现存问题" class="headerlink" title="现存问题"></a>现存问题</h2><ul><li>使用 Docker 运行后，我们改了项目代码不会立刻生效，需要重新<code>build</code>和<code>run</code>，很是麻烦。</li><li>容器里面产生的数据，例如 log 文件，数据库备份文件，容器删除后就丢失了。</li></ul><blockquote><p>目录挂载解决以上问题</p></blockquote><blockquote><p>本文档课件配套 <a href="https://www.bilibili.com/video/BV11L411g7U1?p=4">视频教程</a></p></blockquote><h2 id="几种挂载方式"><a href="#几种挂载方式" class="headerlink" title="几种挂载方式"></a>几种挂载方式</h2><ul><li><code>bind mount</code> 直接把宿主机目录映射到容器内，适合挂代码目录和配置文件。可挂到多个容器上</li><li><code>volume</code> 由容器创建和管理，创建在宿主机，所以删除容器不会丢失，官方推荐，更高效，Linux 文件系统，适合存储数据库数据。可挂到多个容器上</li><li><code>tmpfs mount</code> 适合存储临时文件，存宿主机内存中。不可多容器共享。</li></ul><p>文档参考：<a href="https://docs.docker.com/storage/">https://docs.docker.com/storage/</a></p><p><img src="https://sjwx.easydoc.xyz/46901064/files/kv96dc4q.png"></p><h2 id="挂载演示"><a href="#挂载演示" class="headerlink" title="挂载演示"></a>挂载演示</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">bind mount<span class="hljs-string">` 方式用绝对路径 `</span>-v D:<span class="hljs-regexp">/code:/</span>app<br>volume<span class="hljs-string">` 方式，只需要一个名字 `</span>-v db-data:/app<br></code></pre></td></tr></table></figure><p>示例：<br><code>docker run -p 8080:8080 --name test-hello -v D:/code:/app -d test:v1</code></p><blockquote><p>注意！<br>因为挂载后，容器里的代码就会替换为你本机的代码了，如果你代码目录没有<code>node_modules</code>目录，你需要在代码目录执行下<code>npm install --registry=https://registry.npm.taobao.org</code>确保依赖库都已经安装，否则可能会提示“Error: Cannot find module ‘koa’”<br>如果你的电脑没有安装 <a href="https://nodejs.org/en/">nodejs</a>，你需要安装一下才能执行上面的命令。</p></blockquote><h1 id="5-多容器通信"><a href="#5-多容器通信" class="headerlink" title="5.多容器通信"></a>5.多容器通信</h1><h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><p>项目往往都不是独立运行的，需要数据库、缓存这些东西配合运作。<br>这节我们把前面的 Web 项目增加一个 Redis 依赖，多跑一个 Redis 容器，演示如何多容器之间的通信。</p><h2 id="创建虚拟网络"><a href="#创建虚拟网络" class="headerlink" title="创建虚拟网络"></a>创建虚拟网络</h2><p>要想多容器之间互通，从 Web 容器访问 Redis 容器，我们只需要把他们放到同个网络中就可以了。</p><p>文档参考：<a href="https://docs.docker.com/engine/reference/commandline/network/">https://docs.docker.com/engine/reference/commandline/network/</a></p><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><h5 id="创建一个名为test-net的网络："><a href="#创建一个名为test-net的网络：" class="headerlink" title="创建一个名为test-net的网络："></a>创建一个名为<code>test-net</code>的网络：</h5><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">docker network create <span class="hljs-keyword">test</span>-<span class="hljs-keyword">net</span><br></code></pre></td></tr></table></figure><h5 id="运行-Redis-在-test-net-网络中，别名redis"><a href="#运行-Redis-在-test-net-网络中，别名redis" class="headerlink" title="运行 Redis 在 test-net 网络中，别名redis"></a>运行 Redis 在 <code>test-net</code> 网络中，别名<code>redis</code></h5><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">docker run</span> <span class="hljs-literal">-</span><span class="hljs-comment">d</span> <span class="hljs-literal">--</span><span class="hljs-comment">name redis</span> <span class="hljs-literal">--</span><span class="hljs-comment">network test</span><span class="hljs-literal">-</span><span class="hljs-comment">net</span> <span class="hljs-literal">--</span><span class="hljs-comment">network</span><span class="hljs-literal">-</span><span class="hljs-comment">alias redis redis:latest</span><br></code></pre></td></tr></table></figure><h5 id="修改代码中访问redis的地址为网络别名"><a href="#修改代码中访问redis的地址为网络别名" class="headerlink" title="修改代码中访问redis的地址为网络别名"></a>修改代码中访问<code>redis</code>的地址为网络别名</h5><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/picture/kv98rfvb.png"></p><h5 id="运行-Web-项目，使用同个网络"><a href="#运行-Web-项目，使用同个网络" class="headerlink" title="运行 Web 项目，使用同个网络"></a>运行 Web 项目，使用同个网络</h5><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">docker <span class="hljs-keyword">run</span> -p 8080:8080 --name <span class="hljs-keyword">test</span> -v <span class="hljs-keyword">D</span>:/<span class="hljs-keyword">test</span>:/<span class="hljs-keyword">app</span> --network <span class="hljs-keyword">test</span>-<span class="hljs-keyword">net</span> -<span class="hljs-keyword">d</span> <span class="hljs-keyword">test</span>:v1<br></code></pre></td></tr></table></figure><h5 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h5><p><code>http://localhost:8080/redis</code><br>容器终端查看数据是否一致</p><h2 id="更多相关命令-1"><a href="#更多相关命令-1" class="headerlink" title="更多相关命令"></a>更多相关命令</h2><p><code>docker ps</code> 查看当前运行中的容器<br><code>docker images</code> 查看镜像列表<br><code>docker rm container-id</code> 删除指定 id 的容器<br><code>docker stop/start container-id</code> 停止&#x2F;启动指定 id 的容器<br><code>docker rmi image-id</code> 删除指定 id 的镜像<br><code>docker volume ls</code> 查看 volume 列表<br><code>docker network ls</code> 查看网络列表</p><h1 id="6-Docker-Compose"><a href="#6-Docker-Compose" class="headerlink" title="6.Docker-Compose"></a>6.Docker-Compose</h1><h2 id="现存问题-1"><a href="#现存问题-1" class="headerlink" title="现存问题"></a>现存问题</h2><p>在上节，我们运行了两个容器：Web 项目 + Redis<br>如果项目依赖更多的第三方软件，我们需要管理的容器就更加多，每个都要单独配置运行，指定网络。<br>这节，我们使用 docker-compose 把项目的多个服务集合到一起，一键运行。</p><h2 id="安装-Docker-Compose"><a href="#安装-Docker-Compose" class="headerlink" title="安装 Docker Compose"></a>安装 Docker Compose</h2><ul><li>如果你是安装的桌面版 Docker，不需要额外安装，已经包含了。</li><li>如果是没图形界面的服务器版 Docker，你需要单独安装 <a href="https://docs.docker.com/compose/install/#install-compose-on-linux-systems">安装文档</a></li><li>运行<code>docker-compose</code>检查是否安装成功</li></ul><h2 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h2><p>要把项目依赖的多个服务集合到一起，我们需要编写一个<code>docker-compose.yml</code>文件，描述依赖哪些服务<br>参考文档：<a href="https://docs.docker.com/compose/">https://docs.docker.com/compose/</a></p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">version</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3.7&quot;</span><br><br><span class="hljs-attribute">services</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">app</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">build</span><span class="hljs-punctuation">:</span> <span class="hljs-string">./</span><br>    <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">80:8080</span><br>    <span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./:/app</span><br>    <span class="hljs-attribute">environment</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TZ=Asia/Shanghai</span><br>  <span class="hljs-attribute">redis</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">redis:5.0.13</span><br>    <span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">redis:/data</span><br>    <span class="hljs-attribute">environment</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TZ=Asia/Shanghai</span><br><br><span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">redis</span><span class="hljs-punctuation">:</span><br></code></pre></td></tr></table></figure><blockquote><p>容器默认时间不是北京时间，增加 TZ&#x3D;Asia&#x2F;Shanghai 可以改为北京时间</p></blockquote><h2 id="跑起来"><a href="#跑起来" class="headerlink" title="跑起来"></a>跑起来</h2><p>在<code>docker-compose.yml</code> 文件所在目录，执行：<code>docker-compose up</code>就可以跑起来了。<br>命令参考：<a href="https://docs.docker.com/compose/reference/up/">https://docs.docker.com/compose/reference/up/</a></p><p>在后台运行只需要加一个 -d 参数<code>docker-compose up -d</code><br>查看运行状态：<code>docker-compose ps</code><br>停止运行：<code>docker-compose stop</code><br>重启：<code>docker-compose restart</code><br>重启单个服务：<code>docker-compose restart service-name</code><br>进入容器命令行：<code>docker-compose exec service-name sh</code><br>查看容器运行log：<code>docker-compose logs [service-name]</code></p><h1 id="7-发布和部署"><a href="#7-发布和部署" class="headerlink" title="7.发布和部署"></a>7.发布和部署</h1><h2 id="镜像仓库介绍"><a href="#镜像仓库介绍" class="headerlink" title="镜像仓库介绍"></a>镜像仓库介绍</h2><p>镜像仓库用来存储我们 build 出来的“安装包”，Docker 官方提供了一个 <a href="https://hub.docker.com/">镜像库</a>，里面包含了大量镜像，基本各种软件所需依赖都有，要什么直接上去搜索。</p><p>我们也可以把自己 build 出来的镜像上传到 docker 提供的镜像库中，方便传播。<br>当然你也可以搭建自己的私有镜像库，或者使用国内各种大厂提供的镜像托管服务，例如：阿里云、腾讯云</p><blockquote><p>本文档课件配套 <a href="https://www.bilibili.com/video/BV11L411g7U1?p=7">视频教程</a></p></blockquote><h2 id="上传我们的镜像"><a href="#上传我们的镜像" class="headerlink" title="上传我们的镜像"></a>上传我们的镜像</h2><ul><li>首先你要先 <a href="https://hub.docker.com/">注册一个账号</a></li><li>创建一个镜像库<br><img src="https://sjwx.easydoc.xyz/46901064/files/kv9a2wty.png" alt="image.png"></li><li>命令行登录账号：<br><code>docker login -u username</code></li><li>新建一个tag，名字必须跟你注册账号一样<br><code>docker tag test:v1 username/test:v1</code></li><li>推上去<br><code>docker push username/test:v1</code></li><li>部署试下<br><code>docker run -dp 8080:8080 username/test:v1</code></li></ul><h5 id="docker-compose-中也可以直接用这个镜像了"><a href="#docker-compose-中也可以直接用这个镜像了" class="headerlink" title="docker-compose 中也可以直接用这个镜像了"></a>docker-compose 中也可以直接用这个镜像了</h5><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">version</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3.7&quot;</span><br><br><span class="hljs-attribute">services</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">app</span><span class="hljs-punctuation">:</span><br><span class="hljs-comment">#    build: ./</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">helloguguji/test:v1</span><br>    <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">80:8080</span><br>    <span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./:/app</span><br>    <span class="hljs-attribute">environment</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TZ=Asia/Shanghai</span><br>  <span class="hljs-attribute">redis</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">redis:5.0.13</span><br>    <span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">redis:/data</span><br>    <span class="hljs-attribute">environment</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TZ=Asia/Shanghai</span><br><br><span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">redis</span><span class="hljs-punctuation">:</span><br></code></pre></td></tr></table></figure><h2 id="阿里云容器托管"><a href="#阿里云容器托管" class="headerlink" title="阿里云容器托管"></a>阿里云容器托管</h2><p>docker 官方的镜像托管有时候上传和下载都太慢了，如果你想要更快的速度，可以使用阿里云的免费镜像托管<br>登录 <a href="https://www.aliyun.com/">阿里云</a></p><p><img src="https://sjwx.easydoc.xyz/46901064/files/kv9dqxuo.png" alt="image.png"></p><h1 id="8-备份和迁移数据"><a href="#8-备份和迁移数据" class="headerlink" title="8.备份和迁移数据"></a>8.备份和迁移数据</h1><h2 id="迁移方式介绍"><a href="#迁移方式介绍" class="headerlink" title="迁移方式介绍"></a>迁移方式介绍</h2><p>容器中的数据，如果没有用挂载目录，删除容器后就会丢失数据。</p><p>如果你是用<code>bind mount</code>直接把宿主机的目录挂进去容器，那迁移数据很方便，直接复制目录就好了<br>如果你是用<code>volume</code>方式挂载的，由于数据是由容器创建和管理的，需要用特殊的方式把数据弄出来。</p><h2 id="备份和导入-Volume-的流程"><a href="#备份和导入-Volume-的流程" class="headerlink" title="备份和导入 Volume 的流程"></a>备份和导入 Volume 的流程</h2><p>备份：</p><ul><li>运行一个 ubuntu 的容器，挂载需要备份的 volume 到容器，并且挂载宿主机目录到容器里的备份目录。</li><li>运行 tar 命令把数据压缩为一个文件</li><li>把备份文件复制到需要导入的机器</li></ul><p>导入：</p><ul><li>运行 ubuntu 容器，挂载容器的 volume，并且挂载宿主机备份文件所在目录到容器里</li><li>运行 tar 命令解压备份文件到指定目录</li></ul><h2 id="备份-MongoDB-数据演示"><a href="#备份-MongoDB-数据演示" class="headerlink" title="备份 MongoDB 数据演示"></a>备份 MongoDB 数据演示</h2><ul><li>运行一个 mongodb，创建一个名叫<code>mongo-data</code>的 volume 指向容器的 &#x2F;data 目录<br><code>docker run -p 27018:27017 --name mongo -v mongo-data:/data -d mongo:4.4</code></li><li>运行一个 Ubuntu 的容器，挂载<code>mongo</code>容器的所有 volume，映射宿主机的 backup 目录到容器里面的 &#x2F;backup 目录，然后运行 tar 命令把数据压缩打包<br><code>docker run --rm --volumes-from mongo -v d:/backup:/backup ubuntu tar cvf /backup/backup.tar /data/</code></li></ul><p>最后你就可以拿着这个 backup.tar 文件去其他地方导入了。</p><h2 id="恢复-Volume-数据演示"><a href="#恢复-Volume-数据演示" class="headerlink" title="恢复 Volume 数据演示"></a>恢复 Volume 数据演示</h2><ul><li>运行一个 ubuntu 容器，挂载 mongo 容器的所有 volumes，然后读取 &#x2F;backup 目录中的备份文件，解压到 &#x2F;data&#x2F; 目录<br><code>docker run --rm --volumes-from mongo -v d:/backup:/backup ubuntu bash -c &quot;cd /data/ &amp;&amp; tar xvf /backup/backup.tar --strip 1&quot;</code></li></ul><blockquote><p>注意，volumes-from 指定的是容器名字<br>strip 1 表示解压时去掉前面1层目录，因为压缩时包含了绝对路径</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K8S极速入门</title>
    <link href="/2022/07/13/K8S%E6%9E%81%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2022/07/13/K8S%E6%9E%81%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Kubenetes简介"><a href="#1-Kubenetes简介" class="headerlink" title="1.Kubenetes简介"></a>1.Kubenetes简介</h1>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Go Redis</title>
    <link href="/2022/07/10/Go-Redis/"/>
    <url>/2022/07/10/Go-Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1.快速入门"></a>1.快速入门</h1><h2 id="1-安装依赖包"><a href="#1-安装依赖包" class="headerlink" title="1.安装依赖包"></a>1.安装依赖包</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> -<span class="hljs-keyword">u</span> github.<span class="hljs-keyword">com</span>/<span class="hljs-keyword">go</span>-redis/redis<br></code></pre></td></tr></table></figure><h2 id="2-golang连接redis"><a href="#2-golang连接redis" class="headerlink" title="2.golang连接redis"></a>2.golang连接redis</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 根据redis配置初始化一个客户端</span><br>client := redis.NewClient(&amp;redis.Options&#123;<br>Addr:     <span class="hljs-string">&quot;localhost:6379&quot;</span>, <span class="hljs-comment">// redis地址</span><br>Password: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// redis密码，没有则留空</span><br>DB:       <span class="hljs-number">0</span>,  <span class="hljs-comment">// 默认数据库，默认是0</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="3-简单的例子"><a href="#3-简单的例子" class="headerlink" title="3.简单的例子"></a>3.简单的例子</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 设置一个key，过期时间为0，意思就是永远不过期</span><br>err := client.Set(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-number">0</span>).Err()<br><br><span class="hljs-comment">// 检测设置是否成功</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-comment">// 根据key查询缓存，通过Result函数返回两个值</span><br><span class="hljs-comment">//  第一个代表key的值，第二个代表查询错误信息</span><br>val, err := client.Get(<span class="hljs-string">&quot;key&quot;</span>).Result()<br><br><span class="hljs-comment">// 检测，查询是否出错</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;key&quot;</span>, val)<br></code></pre></td></tr></table></figure><h2 id="2-连接设置"><a href="#2-连接设置" class="headerlink" title="2.连接设置"></a>2.连接设置</h2><h2 id="1-golang连接redis"><a href="#1-golang连接redis" class="headerlink" title="1.golang连接redis"></a>1.golang连接redis</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 初始化一个新的redis client</span><br>client := redis.NewClient(&amp;redis.Options&#123;<br>Addr:     <span class="hljs-string">&quot;localhost:6379&quot;</span>, <span class="hljs-comment">// redis地址</span><br>Password: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// redis没密码，没有设置，则留空</span><br>DB:       <span class="hljs-number">0</span>,  <span class="hljs-comment">// 使用默认数据库</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>通过例子，我们知道主要通过Options配置redis的连接参数，下面对Options参数进行详细说明。</p><blockquote><p>提示：go-redis包自带了连接池，会自动维护redis连接，因此创建一次client即可，不要查询一次redis就关闭client。</p></blockquote><h1 id="2-Options参数详解"><a href="#2-Options参数详解" class="headerlink" title="2.Options参数详解"></a>2.Options参数详解</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Options <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 网络类型 tcp 或者 unix.</span><br><span class="hljs-comment">// 默认是 tcp.</span><br>Network <span class="hljs-type">string</span><br><span class="hljs-comment">// redis地址，格式 host:port</span><br>Addr <span class="hljs-type">string</span><br><br><span class="hljs-comment">// 新建一个redis连接的时候，会回调这个函数</span><br>OnConnect <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Conn)</span></span> <span class="hljs-type">error</span><br><br><span class="hljs-comment">// redis密码，redis server没有设置可以为空。</span><br>Password <span class="hljs-type">string</span><br><br><span class="hljs-comment">// redis数据库，序号从0开始，默认是0，可以不用设置</span><br>DB <span class="hljs-type">int</span><br><br><span class="hljs-comment">// redis操作失败最大重试次数，默认不重试。</span><br>MaxRetries <span class="hljs-type">int</span><br><br><span class="hljs-comment">// 最小重试时间间隔.</span><br><span class="hljs-comment">// 默认是 8ms ; -1 表示关闭.</span><br>MinRetryBackoff time.Duration<br><br><span class="hljs-comment">// 最大重试时间间隔</span><br><span class="hljs-comment">// 默认是 512ms; -1 表示关闭.</span><br>MaxRetryBackoff time.Duration<br><br><span class="hljs-comment">// redis连接超时时间.</span><br><span class="hljs-comment">// 默认是 5 秒.</span><br>DialTimeout time.Duration<br><br><span class="hljs-comment">// socket读取超时时间</span><br><span class="hljs-comment">// 默认 3 秒.</span><br>ReadTimeout time.Duration<br><br><span class="hljs-comment">// socket写超时时间</span><br>WriteTimeout time.Duration<br><br><span class="hljs-comment">// redis连接池的最大连接数.</span><br><span class="hljs-comment">// 默认连接池大小等于 cpu个数 * 10</span><br>PoolSize <span class="hljs-type">int</span><br><br><span class="hljs-comment">// redis连接池最小空闲连接数.</span><br>MinIdleConns <span class="hljs-type">int</span><br><span class="hljs-comment">// redis连接最大的存活时间，默认不会关闭过时的连接.</span><br>MaxConnAge time.Duration<br><br><span class="hljs-comment">// 当你从redis连接池获取一个连接之后，连接池最多等待这个拿出去的连接多长时间。</span><br><span class="hljs-comment">// 默认是等待 ReadTimeout + 1 秒.</span><br>PoolTimeout time.Duration<br><span class="hljs-comment">// redis连接池多久会关闭一个空闲连接.</span><br><span class="hljs-comment">// 默认是 5 分钟. -1 则表示关闭这个配置项</span><br>IdleTimeout time.Duration<br><span class="hljs-comment">// 多长时间检测一下，空闲连接</span><br><span class="hljs-comment">// 默认是 1 分钟. -1 表示关闭空闲连接检测</span><br>IdleCheckFrequency time.Duration<br><br><span class="hljs-comment">// 只读设置，如果设置为true， redis只能查询缓存不能更新。</span><br>readOnly <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-基本键值操作"><a href="#3-基本键值操作" class="headerlink" title="3.基本键值操作"></a>3.基本键值操作</h1><p>redis基本的key&#x2F;value操作，指的是针对value值的类型为字符串或者数字类型的读写操作。</p><p>golang redis常用函数列表：</p><ul><li>Set - 设置一个key的值</li><li>Get - 查询key的值</li><li>GetSet - 设置一个key的值，并返回这个key的旧值</li><li>SetNX - 如果key不存在，则设置这个key的值</li><li>MGet - 批量查询key的值</li><li>MSet - 批量设置key的值</li><li>Incr,IncrBy,IncrByFloat - 针对一个key的数值进行递增操作</li><li>Decr,DecrBy - 针对一个key的数值进行递减操作</li><li>Del - 删除key操作，可以批量删除</li><li>Expire - 设置key的过期时间</li></ul><h2 id="1-Set"><a href="#1-Set" class="headerlink" title="1.Set"></a>1.<code>Set</code></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 第三个参数为过期时间，0为永不过期</span><br>err := client.Set(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;value&quot;</span>,<span class="hljs-number">0</span>).Err()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span>&#123;<br>  <span class="hljs-built_in">panic</span>(err)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-Get"><a href="#2-Get" class="headerlink" title="2.Get"></a>2.<code>Get</code></h2><p>查询key的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Result函数返回两个值，第一个是key的值，第二个是错误信息</span><br>val, err := client.Get(<span class="hljs-string">&quot;key&quot;</span>).Result()<br><span class="hljs-comment">// 判断查询是否出错</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;key&quot;</span>, val)<br></code></pre></td></tr></table></figure><h2 id="3-GetSet"><a href="#3-GetSet" class="headerlink" title="3.GetSet"></a>3.<code>GetSet</code></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Result函数返回两个值，第一个是key的值，第二个是错误信息</span><br>oldVal, err := client.GetSet(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;new value&quot;</span>).Result()<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-comment">// 打印key的旧值</span><br>fmt.Println(<span class="hljs-string">&quot;key&quot;</span>, oldVal)<br></code></pre></td></tr></table></figure><h2 id="4-SetNX"><a href="#4-SetNX" class="headerlink" title="4.SetNX"></a>4.<code>SetNX</code></h2><p>如果key不存在，则设置这个key的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 第三个参数代表key的过期时间，0代表不会过期。</span><br>err := client.SetNX(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-number">0</span>).Err()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-MGet"><a href="#5-MGet" class="headerlink" title="5.MGet"></a>5.<code>MGet</code></h2><p>批量查询key的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// MGet函数可以传入任意个key，一次性返回多个值。</span><br><span class="hljs-comment">// 这里Result返回两个值，第一个值是一个数组，第二个值是错误信息</span><br>vals, err := client.MGet(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;key3&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(vals)<br></code></pre></td></tr></table></figure><h2 id="6-MSet"><a href="#6-MSet" class="headerlink" title="6.MSet"></a>6.<code>MSet</code></h2><p>批量设置key的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">err := client.MSet(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>, <span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>, <span class="hljs-string">&quot;key3&quot;</span>, <span class="hljs-string">&quot;value3&quot;</span>).Err()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-built_in">panic</span>(err)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-Incr-、IncrBy、IncrByFloat"><a href="#7-Incr-、IncrBy、IncrByFloat" class="headerlink" title="7.Incr 、IncrBy、IncrByFloat"></a>7.<code>Incr</code> 、<code>IncrBy</code>、<code>IncrByFloat</code></h2><p>针对一个key的值进行递增操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Incr函数每次加一</span><br>val, err := client.Incr(<span class="hljs-string">&quot;key&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;最新值&quot;</span>, val)<br><br><span class="hljs-comment">// IncrBy函数，可以指定每次递增多少</span><br>val, err := client.IncrBy(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">2</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;最新值&quot;</span>, val)<br><br><span class="hljs-comment">// IncrByFloat函数，可以指定每次递增多少，跟IncrBy的区别是累加的是浮点数</span><br>val, err := client.IncrByFloat(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">2</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;最新值&quot;</span>, val)<br><br></code></pre></td></tr></table></figure><h2 id="8-Decr、DecrBy"><a href="#8-Decr、DecrBy" class="headerlink" title="8.Decr、DecrBy"></a>8.<code>Decr</code>、<code>DecrBy</code></h2><p>针对一个key的值进行递减操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Decr函数每次减一</span><br>val, err := client.Decr(<span class="hljs-string">&quot;key&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;最新值&quot;</span>, val)<br><br><span class="hljs-comment">// DecrBy函数，可以指定每次递减多少</span><br>val, err := client.DecrBy(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">2</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;最新值&quot;</span>, val)<br></code></pre></td></tr></table></figure><h2 id="9-Del"><a href="#9-Del" class="headerlink" title="9.Del"></a>9.<code>Del</code></h2><p>删除key操作，支持批量删除</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">/ 删除key<br>client.Del(<span class="hljs-string">&quot;key&quot;</span>)<br><br><span class="hljs-comment">// 删除多个key, Del函数支持删除多个key</span><br>err := client.Del(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;key3&quot;</span>).Err()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-Expire"><a href="#10-Expire" class="headerlink" title="10.Expire"></a>10.<code>Expire</code></h2><p>设置key的过期时间，单位为<strong>秒</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">client.Expire(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h1 id="4-hash用法"><a href="#4-hash用法" class="headerlink" title="4.hash用法"></a>4.hash用法</h1><p>golang redis hash类型数据操作。</p><p>如果你希望key&#x2F;value的值也能作为hash结构进行操作，可以选择redis hash类型。</p><p>使用场景举例：<br>如果我们希望缓存一条用户信息(包括用户id、用户名、email字段)，希望能够做到局部读写用户信息（例如：读写用户名），也能够读取整条用户信息，那么hash类型就支持这些操作。</p><p>redis hash操作主要有2-3个元素组成：</p><ul><li>key - redis key 唯一标识</li><li>field - hash数据的字段名</li><li>value - 值，有些操作不需要值</li></ul><p><strong>go redis hash数据常用函数：</strong></p><ul><li>HSet - 根据key和field字段设置，field字段的值</li><li>HGet - 根据key和field字段，查询field字段的值</li><li>HGetAll - 根据key查询所有字段和值</li><li>HIncrBy - 根据key和field字段，累加数值。</li><li>HKeys - 根据key返回所有字段名</li><li>HLen - 根据key，查询hash的字段数量</li><li>HMGet - 根据key和多个字段名，批量查询多个hash字段值</li><li>HMSet - 根据key和多个字段名和字段值，批量设置hash字段值</li><li>HSetNX - 如果field字段不存在，则设置hash字段值</li><li>HDel - 根据key和字段名，删除hash字段，支持批量删除hash字段</li><li>HExists - 检测hash字段名是否存在。</li></ul><blockquote><p>提示：不管我们选择redis什么类型的数据，操作的时候都必须要有一个&#x3D;&#x3D;唯一的Key, 用来唯一标识一个数据。&#x3D;&#x3D;</p></blockquote><h2 id="1-HSet"><a href="#1-HSet" class="headerlink" title="1.HSet"></a>1.<code>HSet</code></h2><p>根据key和field字段设置，field字段的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// user_1 是hash key，username 是字段名, tizi365是字段值</span><br>err := client.HSet(<span class="hljs-string">&quot;user_1&quot;</span>, <span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;tizi365&quot;</span>).Err()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-HGet"><a href="#2-HGet" class="headerlink" title="2.HGet"></a>2.<code>HGet</code></h2><p>根据<code>key</code>和<code>field</code>字段，查询<code>field</code>字段的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// user_1 是hash key，username是字段名</span><br>username, err := client.HGet(<span class="hljs-string">&quot;user_1&quot;</span>, <span class="hljs-string">&quot;username&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(username)<br></code></pre></td></tr></table></figure><h2 id="3-HGetAll"><a href="#3-HGetAll" class="headerlink" title="3.HGetAll"></a>3.<code>HGetAll</code></h2><p>根据<code>key</code>查询所有字段和值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 一次性返回key=user_1的所有hash字段和值</span><br>data, err := client.HGetAll(<span class="hljs-string">&quot;user_1&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-comment">// data是一个map类型，这里使用使用循环迭代输出</span><br><span class="hljs-keyword">for</span> field, val := <span class="hljs-keyword">range</span> data &#123;<br>fmt.Println(field,val)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-HIncrBy"><a href="#4-HIncrBy" class="headerlink" title="4.HIncrBy"></a>4.<code>HIncrBy</code></h2><p>根据key和field字段，累加字段的数值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 累加count字段的值，一次性累加2， user_1为hash key</span><br>count, err := client.HIncrBy(<span class="hljs-string">&quot;user_1&quot;</span>, <span class="hljs-string">&quot;count&quot;</span>, <span class="hljs-number">2</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>fmt.Println(count)<br></code></pre></td></tr></table></figure><h2 id="5-HKeys"><a href="#5-HKeys" class="headerlink" title="5.HKeys"></a>5.<code>HKeys</code></h2><p>根据<code>Key</code>返回所有字段名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// keys是一个string数组</span><br>keys, err := client.HKeys(<span class="hljs-string">&quot;user_1&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>fmt.Println(keys)<br></code></pre></td></tr></table></figure><h2 id="6-HLen"><a href="#6-HLen" class="headerlink" title="6.HLen"></a>6.<code>HLen</code></h2><p>根据key，查询hash的字段数量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">size, err := client.HLen(<span class="hljs-string">&quot;key&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>fmt.Println(size)<br></code></pre></td></tr></table></figure><h2 id="7-HMGet"><a href="#7-HMGet" class="headerlink" title="7.HMGet"></a>7.<code>HMGet</code></h2><p>根据key和多个字段名，批量查询多个hash字段值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">size, err := client.HLen(<span class="hljs-string">&quot;key&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>fmt.Println(size)<br></code></pre></td></tr></table></figure><h2 id="8-HMSet"><a href="#8-HMSet" class="headerlink" title="8.HMSet"></a>8.<code>HMSet</code></h2><p>根据key和多个字段名和字段值，批量设置hash字段值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 初始化hash数据的多个字段值</span><br>data := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)<br>data[<span class="hljs-string">&quot;id&quot;</span>] = <span class="hljs-number">1</span><br>data[<span class="hljs-string">&quot;username&quot;</span>] = <span class="hljs-string">&quot;tizi&quot;</span><br><br><span class="hljs-comment">// 一次性保存多个hash字段值</span><br>err := client.HMSet(<span class="hljs-string">&quot;key&quot;</span>, data).Err()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-HSetNX"><a href="#9-HSetNX" class="headerlink" title="9.HSetNX"></a>9.<code>HSetNX</code></h2><p>如果hash不存在，则设置hash字段值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">err := client.HSetNX(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">100</span>).Err()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-HDel"><a href="#10-HDel" class="headerlink" title="10.HDel"></a>10.<code>HDel</code></h2><p>根据key和字段名，删除hash字段，支持批量删除hash字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 删除一个字段id</span><br>client.HDel(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;id&quot;</span>)<br><br><span class="hljs-comment">// 删除多个字段</span><br>client.HDel(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;username&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="11-HExists"><a href="#11-HExists" class="headerlink" title="11.HExists"></a>11.<code>HExists</code></h2><p>检查hash字段名是否存在</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 检测id字段是否存在</span><br>err := client.HExists(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;id&quot;</span>).Err()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-List用法"><a href="#5-List用法" class="headerlink" title="5.List用法"></a>5.List用法</h1><p>Redis列表是简单的字符串列表，列表是有序的，列表中的元素可以重复。</p><p>可以添加一个元素到列表的头部（左边）或者尾部（右边）</p><p><strong>golang redis list数据操作常用函数：</strong></p><ul><li>LPush - 从列表左边插入数据</li><li>LPushX - 跟LPush的区别是，仅当列表存在的时候才插入数据</li><li>RPop - 从列表的右边删除第一个数据，并返回删除的数据</li><li>RPush - 从列表右边插入数据</li><li>RPushX - 跟RPush的区别是，仅当列表存在的时候才插入数据</li><li>LPop - 从列表左边删除第一个数据，并返回删除的数据</li><li>LLen - 返回列表的大小</li><li>LRange - 返回列表的一个范围内的数据，也可以返回全部数据</li><li>LRem - 删除列表中的数据</li><li>LIndex - 根据索引坐标，查询列表中的数据</li><li>LInsert - 在指定位置插入数据</li></ul><h2 id="1-LPush"><a href="#1-LPush" class="headerlink" title="1.LPush"></a>1.<code>LPush</code></h2><p>从列表左边插入数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 插入一个数据</span><br>client.LPush(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;data1&quot;</span>)<br><br><span class="hljs-comment">// LPush支持一次插入任意个数据</span><br>err := client.LPush(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>).Err()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-LPushX"><a href="#2-LPushX" class="headerlink" title="2.LPushX"></a>2.<code>LPushX</code></h2><p>跟LPush的区别是，仅当列表存在的时候才插入数据,用法完全一样。</p><h2 id="3-RPop"><a href="#3-RPop" class="headerlink" title="3.RPop"></a>3.<code>RPop</code></h2><p>从列表的右边删除第一个数据，并返回删除的数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">val, err := client.RPop(<span class="hljs-string">&quot;key&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>fmt.Println(val)<br></code></pre></td></tr></table></figure><h2 id="4-RPush"><a href="#4-RPush" class="headerlink" title="4.RPush"></a>4.<code>RPush</code></h2><p>从列表右边插入数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 插入一个数据</span><br>client.RPush(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;data1&quot;</span>)<br><br><span class="hljs-comment">// 支持一次插入任意个数据</span><br>err := client.RPush(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>).Err()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-RPushX"><a href="#5-RPushX" class="headerlink" title="5.RPushX"></a>5.<code>RPushX</code></h2><p>跟RPush的区别是，仅当列表存在的时候才插入数据, 他们用法一样</p><h2 id="6-LPop"><a href="#6-LPop" class="headerlink" title="6.LPop"></a>6.<code>LPop</code></h2><p>从列表左边删除第一个数据，并返回删除的数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">val, err := client.LPop(<span class="hljs-string">&quot;key&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>fmt.Println(val)<br></code></pre></td></tr></table></figure><h2 id="7-LLen"><a href="#7-LLen" class="headerlink" title="7.LLen"></a>7.<code>LLen</code></h2><p>返回列表的大小</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">val, err := client.LLen(<span class="hljs-string">&quot;key&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>fmt.Println(val)<br></code></pre></td></tr></table></figure><h2 id="8-LRange"><a href="#8-LRange" class="headerlink" title="8.LRange"></a>8.<code>LRange</code></h2><p>返回列表的一个范围内的数据，也可以返回全部数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 返回从0开始到-1位置之间的数据，意思就是返回全部数据</span><br>vals, err := client.LRange(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(vals)<br></code></pre></td></tr></table></figure><h2 id="9-LRem"><a href="#9-LRem" class="headerlink" title="9.LRem"></a>9.<code>LRem</code></h2><p>删除列表中的数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 从列表左边开始，删除100， 如果出现重复元素，仅删除1次，也就是删除第一个</span><br>dels, err := client.LRem(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-comment">// 如果存在多个100，则从列表左边开始删除2个100</span><br>client.LRem(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">100</span>)<br><br><br><span class="hljs-comment">// 如果存在多个100，则从列表右边开始删除2个100</span><br><span class="hljs-comment">// 第二个参数负数表示从右边开始删除几个等于100的元素</span><br>client.LRem(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">100</span>)<br><br><span class="hljs-comment">// 如果存在多个100，第二个参数为0，表示删除所有元素等于100的数据</span><br>client.LRem(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><h2 id="10-LIndex"><a href="#10-LIndex" class="headerlink" title="10.LIndex"></a>10.<code>LIndex</code></h2><p>根据索引坐标，查询列表中的数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 列表索引从0开始计算，这里返回第6个元素</span><br>val, err := client.LIndex(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-number">5</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>fmt.Println(val)<br></code></pre></td></tr></table></figure><h2 id="11-LInsert"><a href="#11-LInsert" class="headerlink" title="11.LInsert"></a>11.<code>LInsert</code></h2><p>在指定位置插入数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 在列表中5的前面插入4</span><br><span class="hljs-comment">// before是之前的意思</span><br>err := client.LInsert(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;before&quot;</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>).Err()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-comment">// 在列表中 tizi365 元素的前面插入 欢迎你</span><br>client.LInsert(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;before&quot;</span>, <span class="hljs-string">&quot;tizi365&quot;</span>, <span class="hljs-string">&quot;欢迎你&quot;</span>)<br><br><span class="hljs-comment">// 在列表中 tizi365 元素的后面插入 2019</span><br>client.LInsert(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;after&quot;</span>, <span class="hljs-string">&quot;tizi365&quot;</span>, <span class="hljs-string">&quot;2019&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="6-集合"><a href="#6-集合" class="headerlink" title="6.集合"></a>6.集合</h1><p>redis的set类型（集合）是string类型数值的无序集合，并且集合元素唯一。</p><p>下面介绍go redis的集合用法。</p><p><strong>go redis 集合（set）常用函数列表</strong>：</p><ul><li>SAdd - 添加集合元素</li><li>SCard - 获取集合元素个数</li><li>SIsMember - 判断元素是否在集合中</li><li>SMembers - 获取集合中所有的元素</li><li>SRem - 删除集合元素</li><li>SPop,SPopN - 随机返回集合中的元素，并且删除返回的元素</li></ul><h2 id="1-SAdd"><a href="#1-SAdd" class="headerlink" title="1.SAdd"></a>1.<code>SAdd</code></h2><p>添加集合元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 添加100到集合中</span><br>err := client.SAdd(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-number">100</span>).Err()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-comment">// 将100,200,300添加到集合中</span><br>client.SAdd(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>)<br></code></pre></td></tr></table></figure><h2 id="2-SCard"><a href="#2-SCard" class="headerlink" title="2.SCard"></a>2.<code>SCard</code></h2><p>获取集合元素个数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">size, err := client.SCard(<span class="hljs-string">&quot;key&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(size)<br></code></pre></td></tr></table></figure><h2 id="3-SIsMember"><a href="#3-SIsMember" class="headerlink" title="3.SIsMember"></a>3.<code>SIsMember</code></h2><p>判断元素是否在集合中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 检测100是否包含在集合中</span><br>ok, _ := client.SIsMember(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">100</span>).Result()<br><span class="hljs-keyword">if</span> ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;集合包含指定元素&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-SMembers"><a href="#4-SMembers" class="headerlink" title="4.SMembers"></a>4.<code>SMembers</code></h2><p>获取集合中所有的元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">es, _ := client.SMembers(<span class="hljs-string">&quot;key&quot;</span>).Result()<br><span class="hljs-comment">// 返回的es是string数组</span><br>fmt.Println(es)<br></code></pre></td></tr></table></figure><h2 id="5-SRem"><a href="#5-SRem" class="headerlink" title="5.SRem"></a>5.<code>SRem</code></h2><p>删除集合元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 删除集合中的元素100</span><br>client.SRem(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">100</span>)<br><br><span class="hljs-comment">// 删除集合中的元素tizi和2019</span><br>client.SRem(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;tizi&quot;</span>, <span class="hljs-string">&quot;2019&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="6-SPop-SPopN"><a href="#6-SPop-SPopN" class="headerlink" title="6.SPop,SPopN"></a>6.<code>SPop,SPopN</code></h2><p>随机返回集合中的元素，并且删除返回的元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 随机返回集合中的一个元素，并且删除这个元素</span><br>val, _ := client.SPop(<span class="hljs-string">&quot;key&quot;</span>).Result()<br>fmt.Println(val)<br><br><span class="hljs-comment">// 随机返回集合中的5个元素，并且删除这些元素</span><br>vals, _ := client.SPopN(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">5</span>).Result()<br>fmt.Println(vals)<br></code></pre></td></tr></table></figure><h1 id="7-有序集合"><a href="#7-有序集合" class="headerlink" title="7.有序集合"></a>7.有序集合</h1><p>Redis 有序集合（sorted set）和集合一样也是string类型元素的集合,且不允许重复的成员，不同的是每个元素都会关联一个double类型的分数，这个分数主要用于集合元素排序。</p><p>下面介绍golang redis 有序集合的用法</p><p><strong>go redis有序集合常用函数:</strong></p><ul><li>ZAdd - 添加一个或者多个元素到集合，如果元素已经存在则更新分数</li><li>ZCard - 返回集合元素个数</li><li>ZCount - 统计某个分数范围内的元素个数</li><li>ZIncrBy - 增加元素的分数</li><li>ZRange,ZRevRange - 返回集合中某个索引范围的元素，根据分数从小到大排序</li><li>ZRangeByScore,ZRevRangeByScore - 根据分数范围返回集合元素，元素根据分数从小到大排序，支持分页。</li><li>ZRem - 删除集合元素</li><li>ZRemRangeByRank - 根据索引范围删除元素</li><li>ZRemRangeByScore - 根据分数范围删除元素</li><li>ZScore - 查询元素对应的分数</li><li>ZRank, ZRevRank - 查询元素的排名</li></ul><h2 id="1-ZAdd"><a href="#1-ZAdd" class="headerlink" title="1.ZAdd"></a>1.<code>ZAdd</code></h2><p>添加一个或者多个元素到集合，如果元素已经存在则更新分数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 添加一个集合元素到集合中， 这个元素的分数是2.5，元素名是tizi</span><br>err := client.ZAdd(<span class="hljs-string">&quot;key&quot;</span>, redis.Z&#123;<span class="hljs-number">2.5</span>,<span class="hljs-string">&quot;tizi&quot;</span>&#125;).Err()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是redis.Z结构体说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Z <span class="hljs-keyword">struct</span> &#123;<br>Score  <span class="hljs-type">float64</span> <span class="hljs-comment">// 分数</span><br>Member <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// 元素名</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-ZCard"><a href="#2-ZCard" class="headerlink" title="2.ZCard"></a>2.<code>ZCard</code></h2><p>返回集合元素个数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">size, err := client.ZCard(<span class="hljs-string">&quot;key&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(size)<br></code></pre></td></tr></table></figure><h2 id="3-ZCount"><a href="#3-ZCount" class="headerlink" title="3.ZCount"></a>3.<code>ZCount</code></h2><p>统计某个分数范围内的元素个数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 返回： 1&lt;=分数&lt;=5 的元素个数, 注意：&quot;1&quot;, &quot;5&quot;两个参数是字符串</span><br>size, err := client.ZCount(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(size)<br><br><span class="hljs-comment">// 返回： 1&lt;分数&lt;=5 的元素个数</span><br><span class="hljs-comment">// 说明：默认第二，第三个参数是大于等于和小于等于的关系。</span><br><span class="hljs-comment">// 如果加上（ 则表示大于或者小于，相当于去掉了等于关系。</span><br>size, err := client.ZCount(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;(1&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>).Result()<br></code></pre></td></tr></table></figure><h2 id="4-ZIncrBy"><a href="#4-ZIncrBy" class="headerlink" title="4.ZIncrBy"></a>4.<code>ZIncrBy</code></h2><p>增加元素的分数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 给元素5，加上2分</span><br>client.ZIncrBy(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">2</span>,<span class="hljs-string">&quot;5&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="5-ZRange-ZRevRange"><a href="#5-ZRange-ZRevRange" class="headerlink" title="5.ZRange,ZRevRange"></a>5.<code>ZRange,ZRevRange</code></h2><p>返回集合中某个索引范围的元素，根据分数从小到大排序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 返回从0到-1位置的集合元素， 元素按分数从小到大排序</span><br><span class="hljs-comment">// 0到-1代表则返回全部数据</span><br>vals, err := client.ZRange(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">0</span>,<span class="hljs-number">-1</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> vals &#123;<br>fmt.Println(val)<br>&#125;<br></code></pre></td></tr></table></figure><p>ZRevRange用法跟ZRange一样，区别是ZRevRange的结果是按分数从大到小排序。</p><h2 id="6-ZRangeByScore"><a href="#6-ZRangeByScore" class="headerlink" title="6.ZRangeByScore"></a>6.<code>ZRangeByScore</code></h2><p>根据分数范围返回集合元素，元素根据分数从小到大排序，支持分页。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 初始化查询条件， Offset和Count用于分页</span><br>op := redis.ZRangeBy&#123;<br>Min:<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-comment">// 最小分数</span><br>Max:<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-comment">// 最大分数</span><br>Offset:<span class="hljs-number">0</span>, <span class="hljs-comment">// 类似sql的limit, 表示开始偏移量</span><br>Count:<span class="hljs-number">5</span>, <span class="hljs-comment">// 一次返回多少数据</span><br>&#125;<br><br>vals, err := client.ZRangeByScore(<span class="hljs-string">&quot;key&quot;</span>, op).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> vals &#123;<br>fmt.Println(val)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-ZRevRangeByScore"><a href="#7-ZRevRangeByScore" class="headerlink" title="7.ZRevRangeByScore"></a>7.<code>ZRevRangeByScore</code></h2><p>用法类似ZRangeByScore，区别是元素根据分数从大到小排序。</p><h2 id="8-ZRangeByScoreWithScores"><a href="#8-ZRangeByScoreWithScores" class="headerlink" title="8.ZRangeByScoreWithScores"></a>8.<code>ZRangeByScoreWithScores</code></h2><p>用法跟ZRangeByScore一样，区别是除了返回集合元素，同时也返回元素对应的分数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 初始化查询条件， Offset和Count用于分页</span><br>op := redis.ZRangeBy&#123;<br>Min:<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-comment">// 最小分数</span><br>Max:<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-comment">// 最大分数</span><br>Offset:<span class="hljs-number">0</span>, <span class="hljs-comment">// 类似sql的limit, 表示开始偏移量</span><br>Count:<span class="hljs-number">5</span>, <span class="hljs-comment">// 一次返回多少数据</span><br>&#125;<br><br>vals, err := client.ZRangeByScoreWithScores(<span class="hljs-string">&quot;key&quot;</span>, op).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> vals &#123;<br>fmt.Println(val.Member) <span class="hljs-comment">// 集合元素</span><br>fmt.Println(val.Score) <span class="hljs-comment">// 分数</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-ZRem"><a href="#8-ZRem" class="headerlink" title="8.ZRem"></a>8.<code>ZRem</code></h2><p>删除集合元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 删除集合中的元素tizi</span><br>client.ZRem(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;tizi&quot;</span>)<br><br><span class="hljs-comment">// 删除集合中的元素tizi和xiaoli</span><br><span class="hljs-comment">// 支持一次删除多个元素</span><br>client.ZRem(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;tizi&quot;</span>, <span class="hljs-string">&quot;xiaoli&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="9-ZRemRangeByRank"><a href="#9-ZRemRangeByRank" class="headerlink" title="9.ZRemRangeByRank"></a>9.<code>ZRemRangeByRank</code></h2><p>根据索引范围删除元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 集合元素按分数排序，从最低分到高分，删除第0个元素到第5个元素。</span><br><span class="hljs-comment">// 这里相当于删除最低分的几个元素</span><br>client.ZRemRangeByRank(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>)<br><br><span class="hljs-comment">// 位置参数写成负数，代表从高分开始删除。</span><br><span class="hljs-comment">// 这个例子，删除最高分数的两个元素，-1代表最高分数的位置，-2第二高分，以此类推。</span><br>client.ZRemRangeByRank(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>)<br></code></pre></td></tr></table></figure><h2 id="10-ZRemRangeByScore"><a href="#10-ZRemRangeByScore" class="headerlink" title="10.ZRemRangeByScore"></a>10.<code>ZRemRangeByScore</code></h2><p>根据分数范围删除元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 删除范围： 2&lt;=分数&lt;=5 的元素</span><br>client.ZRemRangeByScore(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>)<br><br><span class="hljs-comment">// 删除范围： 2&lt;=分数&lt;5 的元素</span><br>client.ZRemRangeByScore(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;(5&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="11-ZScore"><a href="#11-ZScore" class="headerlink" title="11.ZScore"></a>11.<code>ZScore</code></h2><p>查询元素对应的分数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 查询集合元素tizi的分数</span><br>score, _ := client.ZScore(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;tizi&quot;</span>).Result()<br>fmt.Println(score)<br></code></pre></td></tr></table></figure><h2 id="12-ZRank"><a href="#12-ZRank" class="headerlink" title="12.ZRank"></a>12.<code>ZRank</code></h2><p>根据元素名，查询集合元素在集合中的排名，从0开始算，集合元素按分数从小到大排序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">rk, _ := client.ZRank(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;tizi&quot;</span>).Result()<br>fmt.Println(rk)<br></code></pre></td></tr></table></figure><p>ZRevRank的作用跟ZRank一样，区别是ZRevRank是按分数从大到小排序。</p><h1 id="7-发布订阅"><a href="#7-发布订阅" class="headerlink" title="7.发布订阅"></a>7.发布订阅</h1><p>Redis提供了发布订阅功能，可以用于消息的传输，Redis的发布订阅机制包括三个部分，发布者，订阅者和Channel。</p><p>发布订阅架构图：</p><p><img src="https://raw.githubusercontent.com/Wishforpeace/Typora/main/pictureredis-pubsub-20220713145951000.jpg" alt="img"></p><p>发布者和订阅者都是Redis客户端，Channel则为Redis服务器端，发布者将消息发送到某个的频道，订阅了这个频道的订阅者就能接收到这条消息。Redis的这种发布订阅机制与基于主题的发布订阅类似，Channel相当于主题。</p><p>下面介绍golang如何使用redis的发布订阅功能。</p><p><strong>go redis发布订阅常用函数：</strong></p><ul><li>Subscribe - 订阅channel</li><li>PSubscribe - 订阅channel支持通配符匹配</li><li>Publish - 将信息发送到指定的channel。</li><li>PubSubChannels - 查询活跃的channel</li><li>PubSubNumSub - 查询指定的channel有多少个订阅者</li></ul><h2 id="1-Subscribe"><a href="#1-Subscribe" class="headerlink" title="1.Subscribe"></a>1.<code>Subscribe</code></h2><p>订阅channel</p><p>例子1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 订阅channel1这个channel</span><br>sub := client.Subscribe(<span class="hljs-string">&quot;channel1&quot;</span>)<br><br><span class="hljs-comment">// 读取channel消息</span><br>iface, err := sub.Receive()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// handle error</span><br>&#125;<br><br><span class="hljs-comment">// 检测收到的消息类型</span><br><span class="hljs-keyword">switch</span> iface.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> *redis.Subscription:<br>    <span class="hljs-comment">// 订阅成功</span><br><span class="hljs-keyword">case</span> *redis.Message:<br>    <span class="hljs-comment">// 处理收到的消息</span><br>    <span class="hljs-comment">// 这里需要做一下类型转换</span><br>    m := iface.(redis.Message)<br>    <span class="hljs-comment">// 打印收到的小</span><br>fmt.Println(m.Payload)<br><span class="hljs-keyword">case</span> *redis.Pong:<br>    <span class="hljs-comment">// 收到Pong消息</span><br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// handle error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>例子2：<br>使用golang channel的方式处理消息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 订阅channel1这个channel</span><br>sub := client.Subscribe(<span class="hljs-string">&quot;channel1&quot;</span>)<br><br><span class="hljs-comment">// sub.Channel() 返回go channel，可以循环读取redis服务器发过来的消息</span><br><span class="hljs-keyword">for</span> msg := <span class="hljs-keyword">range</span> sub.Channel() &#123;<br><span class="hljs-comment">// 打印收到的消息</span><br>fmt.Println(msg.Channel)<br>fmt.Println(msg.Payload)<br>&#125;<br></code></pre></td></tr></table></figure><p>例子3：<br>取消订阅</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 订阅channel1这个channel</span><br>sub := client.Subscribe(<span class="hljs-string">&quot;channel1&quot;</span>)<br><br><span class="hljs-comment">// 忽略其他处理逻辑</span><br> <br><span class="hljs-comment">// 取消订阅</span><br>sub.Unsubscribe(<span class="hljs-string">&quot;channel1&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="2-PSubscribe"><a href="#2-PSubscribe" class="headerlink" title="2.PSubscribe"></a>2.<code>PSubscribe</code></h2><p>用法跟Subscribe一样，区别是PSubscribe订阅通道(channel)支持模式匹配。</p><p>例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 订阅channel1这个channel</span><br>sub := client.PSubscribe(<span class="hljs-string">&quot;ch_user_*&quot;</span>)<br><span class="hljs-comment">// 可以匹配ch_user_开头的任意channel</span><br></code></pre></td></tr></table></figure><h2 id="3-Publish"><a href="#3-Publish" class="headerlink" title="3.Publish"></a>3.<code>Publish</code></h2><p>将消息发送到指定的channel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 将&quot;message&quot;消息发送到channel1这个通道上</span><br>client.Publish(<span class="hljs-string">&quot;channel1&quot;</span>,<span class="hljs-string">&quot;message&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="4-PubSubChannels"><a href="#4-PubSubChannels" class="headerlink" title="4.PubSubChannels"></a>4.<code>PubSubChannels</code></h2><p>查询活跃的channel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 没有指定查询channel的匹配模式，则返回所有的channel</span><br>chs, _ := client.PubSubChannels(<span class="hljs-string">&quot;&quot;</span>).Result()<br><span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> chs &#123;<br>fmt.Println(ch)<br>&#125;<br><br><span class="hljs-comment">// 匹配user_开头的channel</span><br>chs, _ := client.PubSubChannels(<span class="hljs-string">&quot;user_*&quot;</span>).Result()<br></code></pre></td></tr></table></figure><h2 id="5-PubSubNumSub"><a href="#5-PubSubNumSub" class="headerlink" title="5.PubSubNumSub"></a>5.<code>PubSubNumSub</code></h2><p>查询指定的channel有多少个订阅者</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 查询channel1，channel2两个通道的订阅者数量</span><br>chs, _ := client.PubSubNumSub(<span class="hljs-string">&quot;channel1&quot;</span>, <span class="hljs-string">&quot;channel2&quot;</span>).Result()<br><span class="hljs-keyword">for</span> ch, count := <span class="hljs-keyword">range</span> chs &#123;<br>fmt.Println(ch) <span class="hljs-comment">// channel名字</span><br>fmt.Println(count) <span class="hljs-comment">// channel的订阅者数量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>redis事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p><ul><li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li><li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li></ul><h1 id="8-事务"><a href="#8-事务" class="headerlink" title="8.事务"></a>8.事务</h1><p>下面介绍golang redis事务用法。</p><p><strong>go redis事务常用函数：</strong></p><ul><li>TxPipeline - 以Pipeline的方式操作事务</li><li>Watch - redis乐观锁支持</li></ul><h2 id="1-TxPipeline"><a href="#1-TxPipeline" class="headerlink" title="1.TxPipeline"></a>1.<code>TxPipeline</code></h2><p>以Pipeline的方式操作事务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 开启一个TxPipeline事务</span><br>pipe := client.TxPipeline()<br><br><span class="hljs-comment">// 执行事务操作，可以通过pipe读写redis</span><br>incr := pipe.Incr(<span class="hljs-string">&quot;tx_pipeline_counter&quot;</span>)<br>pipe.Expire(<span class="hljs-string">&quot;tx_pipeline_counter&quot;</span>, time.Hour)<br><br><span class="hljs-comment">// 上面代码等同于执行下面redis命令</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//     MULTI</span><br><span class="hljs-comment">//     INCR pipeline_counter</span><br><span class="hljs-comment">//     EXPIRE pipeline_counts 3600</span><br><span class="hljs-comment">//     EXEC</span><br><br><span class="hljs-comment">// 通过Exec函数提交redis事务</span><br>_, err := pipe.Exec()<br><br><span class="hljs-comment">// 提交事务后，我们可以查询事务操作的结果</span><br><span class="hljs-comment">// 前面执行Incr函数，在没有执行exec函数之前，实际上还没开始运行。</span><br>fmt.Println(incr.Val(), err)<br></code></pre></td></tr></table></figure><h2 id="2-watch"><a href="#2-watch" class="headerlink" title="2.watch"></a>2.<code>watch</code></h2><p>redis乐观锁支持，可以通过watch监听一些Key, 如果这些key的值没有被其他人改变的话，才可以提交事务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义一个回调函数，用于处理事务逻辑</span><br>fn := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(tx *redis.Tx)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 先查询下当前watch监听的key的值</span><br>v, err := tx.Get(<span class="hljs-string">&quot;key&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &amp;&amp; err != redis.Nil &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">// 这里可以处理业务</span><br>fmt.Println(v)<br><br><span class="hljs-comment">// 如果key的值没有改变的话，Pipelined函数才会调用成功</span><br>_, err = tx.Pipelined(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(pipe redis.Pipeliner)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 在这里给key设置最新值</span><br>pipe.Set(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;new value&quot;</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">// 使用Watch监听一些Key, 同时绑定一个回调函数fn, 监听Key后的逻辑写在fn这个回调函数里面</span><br><span class="hljs-comment">// 如果想监听多个key，可以这么写：client.Watch(fn, &quot;key1&quot;, &quot;key2&quot;, &quot;key3&quot;)</span><br>client.Watch(fn, <span class="hljs-string">&quot;key&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习笔记</title>
    <link href="/2022/07/09/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/09/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL学习笔记"><a href="#MySQL学习笔记" class="headerlink" title="MySQL学习笔记"></a>MySQL学习笔记</h1><h2 id="一、登录MySQL"><a href="#一、登录MySQL" class="headerlink" title="一、登录MySQL"></a>一、登录MySQL</h2><p>当 MySQL 服务已经运行时, 我们可以通过 MySQL 自带的客户端工具登录到 MySQL 数据库中, 首先打开命令提示符, 输入以下格式的命名:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql -h 主机名 -u 用户名 -<span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><strong>-h</strong> : 指定客户端所要登录的 MySQL 主机名, 登录本机(localhost 或 127.0.0.1)该参数可以省略;</li><li><strong>-u</strong> : 登录的用户名;</li><li><strong>-p</strong> : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。</li></ul><p>如果我们要登录本机的 MySQL 数据库，只需要输入以下命令即可：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql -u root -<span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure><p>按回车确认, 如果安装正确且 MySQL 正在运行, 会得到以下响应:</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Enter</span> <span class="hljs-variable">password</span><span class="hljs-operator">:</span><br></code></pre></td></tr></table></figure><p>若密码存在, 输入密码登录, 不存在则直接按回车登录。登录成功后你将会看到 Welcome to the MySQL monitor… 的提示语。</p><p>然后命令提示符会一直以 <strong>mysq&gt;</strong> 加一个闪烁的光标等待命令的输入, 输入 <strong>exit</strong> 或 <strong>quit</strong> 退出登录。</p><h2 id="二、MySQL管理"><a href="#二、MySQL管理" class="headerlink" title="二、MySQL管理"></a>二、MySQL管理</h2><h3 id="启动及关闭MySQL服务器"><a href="#启动及关闭MySQL服务器" class="headerlink" title="启动及关闭MySQL服务器"></a>启动及关闭MySQL服务器</h3><h4 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h4><p>首先我们通过命令检查MySQL服务器是否启动</p><p><code>ps -ef | grep mysqld</code></p><p>如果MySql已经启动，以上命令将输出mysql进程列表， 如果mysql未启动，你可以使用以下命令来启动mysql服务器:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">root@host# </span><span class="language-bash"><span class="hljs-built_in">cd</span> /usr/bin</span><br>./mysqld_safe &amp;<br></code></pre></td></tr></table></figure><p>如果你想关闭目前运行的 MySQL 服务器, 你可以执行以下命令:</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit">root<span class="hljs-symbol">@host</span><span class="hljs-meta"># cd /usr/bin</span><br>./mysqladmin -u root -p <span class="hljs-built_in">shutdown</span><br>Enter password: ******<br></code></pre></td></tr></table></figure><h3 id="MySQL-用户设置"><a href="#MySQL-用户设置" class="headerlink" title="MySQL 用户设置"></a>MySQL 用户设置</h3><p>如果你需要添加 MySQL 用户，你只需要在 mysql 数据库中的 user 表添加新用户即可。</p><p>以下为添加用户的的实例，用户名为guest，密码为guest123，并授权用户可进行 SELECT, INSERT 和 UPDATE操作权限：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">root@host# mysql -u root -p<br>Enter <span class="hljs-keyword">password</span>:*******<br>mysql&gt; use mysql;<br><span class="hljs-keyword">Database</span> changed<br><br>mysql&gt; <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> <br>          (host, <span class="hljs-keyword">user</span>, <span class="hljs-keyword">password</span>, <br>           select_priv, insert_priv, update_priv) <br>           <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-string">&#x27;guest&#x27;</span>, <br>           <span class="hljs-keyword">PASSWORD</span>(<span class="hljs-string">&#x27;guest123&#x27;</span>), <span class="hljs-string">&#x27;Y&#x27;</span>, <span class="hljs-string">&#x27;Y&#x27;</span>, <span class="hljs-string">&#x27;Y&#x27;</span>);<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-keyword">row</span> affected (<span class="hljs-number">0.20</span> sec)<br><br>mysql&gt; FLUSH <span class="hljs-keyword">PRIVILEGES</span>;<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-keyword">row</span> affected (<span class="hljs-number">0.01</span> sec)<br><br>mysql&gt; <span class="hljs-keyword">SELECT</span> host, <span class="hljs-keyword">user</span>, <span class="hljs-keyword">password</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">user</span> = <span class="hljs-string">&#x27;guest&#x27;</span>;<br>+<span class="hljs-comment">-----------+---------+------------------+</span><br>| host      | <span class="hljs-keyword">user</span>    | <span class="hljs-keyword">password</span>         |<br>+<span class="hljs-comment">-----------+---------+------------------+</span><br>| localhost | guest | <span class="hljs-number">6</span>f8c114b58f2ce9e |<br>+<span class="hljs-comment">-----------+---------+------------------+</span><br><span class="hljs-number">1</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>在添加用户时，请注意使用MySQL提供的 PASSWORD() 函数来对密码进行加密。 你可以在以上实例看到用户密码加密后为： 6f8c114b58f2ce9e.</p><p><strong>注意：</strong>在 MySQL5.7 中 user 表的 password 已换成了<strong>authentication_string</strong>。</p><p><strong>注意：</strong>password() 加密函数已经在 8.0.11 中移除了，可以使用 MD5() 函数代替。</p><p><strong>注意：</strong>在注意需要执行 <strong>FLUSH PRIVILEGES</strong> 语句。 这个命令执行后会重新载入授权表。</p><p>如果你不使用该命令，你就无法使用新创建的用户来连接mysql服务器，除非你重启mysql服务器。</p><p>你可以在创建用户时，为用户指定权限，在对应的权限列中，在插入语句中设置为 ‘Y’ 即可，用户权限列表如下：</p><ul><li>Select_priv</li><li>Insert_priv</li><li>Update_priv</li><li>Delete_priv</li><li>Create_priv</li><li>Drop_priv</li><li>Reload_priv</li><li>Shutdown_priv</li><li>Process_priv</li><li>File_priv</li><li>Grant_priv</li><li>References_priv</li><li>Index_priv</li><li>Alter_priv</li></ul><p>另外一种添加用户的方法为通过SQL的 GRANT 命令，以下命令会给指定数据库TUTORIALS添加用户 zara ，密码为 zara123 。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">root@host# mysql -u root -p<br>Enter <span class="hljs-keyword">password</span>:*******<br>mysql&gt; use mysql;<br><span class="hljs-keyword">Database</span> changed<br><br>mysql&gt; <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>,<span class="hljs-keyword">INSERT</span>,<span class="hljs-keyword">UPDATE</span>,<span class="hljs-keyword">DELETE</span>,<span class="hljs-keyword">CREATE</span>,<span class="hljs-keyword">DROP</span><br>    -&gt; <span class="hljs-keyword">ON</span> TUTORIALS.*<br>    -&gt; <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;zara&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span><br>    -&gt; IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;zara123&#x27;</span>;<br></code></pre></td></tr></table></figure><p>以上命令会在mysql数据库中的user表创建一条用户信息记录。</p><p><strong>注意:</strong> MySQL 的SQL语句以分号 (;) 作为结束标识。</p><h3 id="x2F-etc-x2F-my-cnf-文件配置"><a href="#x2F-etc-x2F-my-cnf-文件配置" class="headerlink" title="&#x2F;etc&#x2F;my.cnf 文件配置"></a>&#x2F;etc&#x2F;my.cnf 文件配置</h3><p>一般情况下，你不需要修改该配置文件，该文件默认配置如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[mysqld]<br>datadir=<span class="hljs-regexp">/var/</span>lib/mysql<br>socket=<span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/mysql/my</span>sql.sock<br><br>[mysql.server]<br>user=mysql<br>basedir=<span class="hljs-regexp">/var/</span>lib<br><br>[safe_mysqld]<br>err-log=<span class="hljs-regexp">/var/</span>log/mysqld.log<br>pid-<span class="hljs-keyword">file</span>=<span class="hljs-regexp">/var/</span>run<span class="hljs-regexp">/mysqld/my</span>sqld.pid<br></code></pre></td></tr></table></figure><p>在配置文件中，你可以指定不同的错误日志文件存放的目录，一般你不需要改动这些配置。</p><hr><h3 id="管理MySQL的命令"><a href="#管理MySQL的命令" class="headerlink" title="管理MySQL的命令"></a>管理MySQL的命令</h3><p>以下列出了使用Mysql数据库过程中常用的命令：</p><ul><li><p><strong>USE *数据库名*</strong> :<br>选择要操作的Mysql数据库，使用该命令后所有Mysql命令都只针对该数据库。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">mysql&gt; use RUNOOB<span class="hljs-comment">;</span><br>Database changed<br></code></pre></td></tr></table></figure></li><li><p><strong>SHOW DATABASES:</strong><br>列出 MySQL 数据库管理系统的数据库列表。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; SHOW DATABASES;</span><br><span class="hljs-section">+--------------------+</span><br><span class="hljs-section">| Database           |</span><br><span class="hljs-section">+--------------------+</span><br>| information<span class="hljs-emphasis">_schema |</span><br><span class="hljs-emphasis">| RUNOOB             |</span><br><span class="hljs-emphasis">| cdcol              |</span><br><span class="hljs-emphasis">| mysql              |</span><br><span class="hljs-emphasis">| onethink           |</span><br><span class="hljs-emphasis">| performance_</span>schema |<br>| phpmyadmin         |<br>| test               |<br>| wecenter           |<br><span class="hljs-section">| wordpress          |</span><br><span class="hljs-section">+--------------------+</span><br>10 rows in set (0.02 sec)<br></code></pre></td></tr></table></figure></li><li><p><strong>SHOW TABLES:</strong><br>显示指定数据库的所有表，使用该命令前需要使用 use 命令来选择要操作的数据库。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">mysql&gt; use RUNOOB;<br>Database changed<br><span class="hljs-section">mysql&gt; SHOW TABLES;</span><br><span class="hljs-section">+------------------+</span><br><span class="hljs-section">| Tables_in_runoob |</span><br><span class="hljs-section">+------------------+</span><br>| employee<span class="hljs-emphasis">_tbl     |</span><br><span class="hljs-emphasis">| runoob_tbl       |</span><br><span class="hljs-emphasis">| tcount_</span>tbl       |<br><span class="hljs-code">+------------------+</span><br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure></li><li><p><strong>SHOW COLUMNS FROM *数据表*:</strong><br>显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">mysql&gt; SHOW COLUMNS FROM runoob_tbl;<br>+-----------------+--------------+------+-----+---------+-------+<br>|<span class="hljs-string"> Field           </span>|<span class="hljs-string"> Type         </span>|<span class="hljs-string"> Null </span>|<span class="hljs-string"> Key </span>|<span class="hljs-string"> Default </span>|<span class="hljs-string"> Extra </span>|<br>+-----------------+--------------+------+-----+---------+-------+<br>|<span class="hljs-string"> runoob_id       </span>|<span class="hljs-string"> int(11)      </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string"> PRI </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string">       </span>|<br>|<span class="hljs-string"> runoob_title    </span>|<span class="hljs-string"> varchar(255) </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string">       </span>|<br>|<span class="hljs-string"> runoob_author   </span>|<span class="hljs-string"> varchar(255) </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string">       </span>|<br>|<span class="hljs-string"> submission_date </span>|<span class="hljs-string"> date         </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string">       </span>|<br>+-----------------+--------------+------+-----+---------+-------+<br>4 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure></li><li><p><strong>SHOW INDEX FROM *数据表*:</strong><br>显示数据表的详细索引信息，包括PRIMARY KEY（主键）。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">mysql&gt; SHOW INDEX FROM runoob_tbl;<br>+<span class="hljs-params">------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">--------------</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">-----------</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">--------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">---------------</span>+<br>| Table      | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |<br>+<span class="hljs-params">------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">--------------</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">-----------</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">--------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">---------------</span>+<br>| runoob_tbl |          0 | PRIMARY  |            1 | runoob_id   | A         |           2 |     NULL | NULL   |      | BTREE      |         |               |<br>+<span class="hljs-params">------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">--------------</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">-----------</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">--------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">---------------</span>+<br>1 row in <span class="hljs-keyword">set</span> <span class="hljs-params">(0.00 sec)</span><br></code></pre></td></tr></table></figure></li><li><p><strong>SHOW TABLE STATUS [FROM db_name] [LIKE ‘pattern’] \G:</strong><br>该命令将输出Mysql数据库管理系统的性能及统计信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">TABLE</span> STATUS  <span class="hljs-keyword">FROM</span> RUNOOB;   # 显示数据库 RUNOOB 中所有表的信息<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">TABLE</span> STATUS <span class="hljs-keyword">from</span> RUNOOB <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;runoob%&#x27;</span>;     # 表名以runoob开头的表的信息<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">TABLE</span> STATUS <span class="hljs-keyword">from</span> RUNOOB <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;runoob%&#x27;</span>\G;   # 加上 \G，查询结果按列打印<br></code></pre></td></tr></table></figure></li></ul><p>Gif 图演示：</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/03/mysql-admin.gif" alt="img"></p><h2 id="三、MySQL-PHP语法"><a href="#三、MySQL-PHP语法" class="headerlink" title="三、MySQL PHP语法"></a>三、MySQL PHP语法</h2><p>MySQL 可应用于多种语言，包括 PERL, C, C++, JAVA 和 PHP，在这些语言中，MySQL 在 PHP 的 web 开发中是应用最广泛。</p><p>在本教程中我们大部分实例都采用了 PHP 语言。如果你想了解 MySQL 在 PHP 中的应用，可以访问我们的 <a href="https://www.runoob.com/php/php-mysql-intro.html">PHP 中使用 Mysqli 介绍</a>。</p><p>PHP 提供了多种方式来访问和操作Mysql数据库记录。PHP MySQL 函数格式如下：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">mysqli_function</span>(<span class="hljs-params">value,value,...</span>)</span>;<br></code></pre></td></tr></table></figure><p>以上格式中 function部分描述了mysql函数的功能，如</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">mysqli_connect</span>($connect);<br><span class="hljs-built_in">mysqli_query</span>($connect,&quot;SQL 语句&quot;);<br><span class="hljs-built_in">mysqli_fetch_array</span>()<br><span class="hljs-built_in">mysqli_close</span>()<br></code></pre></td></tr></table></figure><p>以下实例展示了PHP调用mysql函数的语法：</p><h3 id="实例-MySQLi"><a href="#实例-MySQLi" class="headerlink" title="实例 (MySQLi)"></a>实例 (MySQLi)</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$retval</span> = <span class="hljs-title function_ invoke__">mysqli_function</span>(value, [value,...]);<br><span class="hljs-keyword">if</span>( !<span class="hljs-variable">$retval</span> )<br>&#123;<br>   <span class="hljs-keyword">die</span> ( <span class="hljs-string">&quot;相关错误信息&quot;</span> );<br>&#125;<br><span class="hljs-comment">// 其他 MySQL 或 PHP 语句</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h2 id="四、MySQL连接"><a href="#四、MySQL连接" class="headerlink" title="四、MySQL连接"></a>四、MySQL连接</h2><h3 id="使用mysql二进制方式连接"><a href="#使用mysql二进制方式连接" class="headerlink" title="使用mysql二进制方式连接"></a>使用mysql二进制方式连接</h3><p>您可以使用MySQL二进制方式进入到mysql命令提示符下来连接MySQL数据库。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>以下是从命令行中连接mysql服务器的简单实例：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@host]</span><span class="hljs-meta"># mysql -u root -p</span><br>Enter password:******<br></code></pre></td></tr></table></figure><p>在登录成功后会出现 mysql&gt; 命令提示窗口，你可以在上面执行任何 SQL 语句。</p><p>以上命令执行后，登录成功输出结果如下:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Welcome <span class="hljs-keyword">to</span> the MySQL monitor.  Commands <span class="hljs-keyword">end</span> <span class="hljs-keyword">with</span> ; <span class="hljs-keyword">or</span> \g.<br>Your MySQL <span class="hljs-keyword">connection</span> id <span class="hljs-keyword">is</span> <span class="hljs-number">2854760</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">server</span> <span class="hljs-keyword">version</span>: <span class="hljs-number">5.0</span><span class="hljs-number">.9</span><br><br><span class="hljs-keyword">Type</span> <span class="hljs-string">&#x27;help;&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;\h&#x27;</span> <span class="hljs-keyword">for</span> help. <span class="hljs-keyword">Type</span> <span class="hljs-string">&#x27;\c&#x27;</span> <span class="hljs-keyword">to</span> clear the buffer.<br></code></pre></td></tr></table></figure><p>在以上实例中，我们使用了root用户登录到mysql服务器，当然你也可以使用其他mysql用户登录。</p><p>如果用户权限足够，任何用户都可以在mysql的命令提示窗口中进行SQL操作。</p><p>退出 mysql&gt; 命令提示窗口可以使用 exit 命令，如下所示：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">mysql&gt; <span class="hljs-keyword">exit</span><br>Bye<br></code></pre></td></tr></table></figure><hr><h3 id="使用-PHP-脚本连接-MySQL"><a href="#使用-PHP-脚本连接-MySQL" class="headerlink" title="使用 PHP 脚本连接 MySQL"></a>使用 PHP 脚本连接 MySQL</h3><p>PHP 提供了 mysqli_connect() 函数来连接数据库。</p><p>该函数有 6 个参数，在成功链接到 MySQL 后返回连接标识，失败返回 FALSE 。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">mysqli<span class="hljs-constructor">_connect(<span class="hljs-params">host</span>, <span class="hljs-params">username</span>, <span class="hljs-params">password</span>, <span class="hljs-params">dbname</span>,<span class="hljs-params">port</span>, <span class="hljs-params">socket</span>)</span>;<br></code></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><em>host</em></td><td align="left">可选。规定主机名或 IP 地址。</td></tr><tr><td align="left"><em>username</em></td><td align="left">可选。规定 MySQL 用户名。</td></tr><tr><td align="left"><em>password</em></td><td align="left">可选。规定 MySQL 密码。</td></tr><tr><td align="left"><em>dbname</em></td><td align="left">可选。规定默认使用的数据库。</td></tr><tr><td align="left"><em>port</em></td><td align="left">可选。规定尝试连接到 MySQL 服务器的端口号。</td></tr><tr><td align="left"><em>socket</em></td><td align="left">可选。规定 socket 或要使用的已命名 pipe。</td></tr></tbody></table><p>你可以使用 PHP 的 mysqli_close() 函数来断开与 MySQL 数据库的链接。</p><p>该函数只有一个参数为 mysqli_connect() 函数创建连接成功后返回的 MySQL 连接标识符。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">bool</span> mysqli_close ( mysqli <span class="hljs-variable">$link</span> )<br></code></pre></td></tr></table></figure><p>本函数关闭指定的连接标识所关联的到 MySQL 服务器的非持久连接。如果没有指定 link_identifier，则关闭上一个打开的连接。</p><p><strong>提示：</strong>通常不需要使用 mysqli_close()，因为已打开的非持久连接会在脚本执行完毕后自动关闭。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>你可以尝试以下实例来连接到你的 MySQL 服务器:</p><h3 id="连接-MySQL"><a href="#连接-MySQL" class="headerlink" title="连接 MySQL"></a>连接 MySQL</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-variable">$dbhost</span> = <span class="hljs-string">&#x27;localhost&#x27;</span>;  <span class="hljs-comment">// mysql服务器主机地址 </span><br><span class="hljs-variable">$dbuser</span> = <span class="hljs-string">&#x27;root&#x27;</span>;            <span class="hljs-comment">// mysql用户名 </span><br><span class="hljs-variable">$dbpass</span> = <span class="hljs-string">&#x27;123456&#x27;</span>;          <span class="hljs-comment">// mysql用户名密码 </span><br><span class="hljs-variable">$conn</span> = <span class="hljs-title function_ invoke__">mysqli_connect</span>(<span class="hljs-variable">$dbhost</span>, <span class="hljs-variable">$dbuser</span>, <span class="hljs-variable">$dbpass</span>); <br><span class="hljs-keyword">if</span>(! <span class="hljs-variable">$conn</span> ) <br>&#123;    <br><span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;Could not connect: &#x27;</span> . <span class="hljs-title function_ invoke__">mysqli_error</span>()); <br>&#125; <br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;数据库连接成功！&#x27;</span>; <br><span class="hljs-title function_ invoke__">mysqli_close</span>(<span class="hljs-variable">$conn</span>); <br><span class="hljs-meta">?&gt;</span><br><br><br><br><br></code></pre></td></tr></table></figure><h2 id="五、创建数据库"><a href="#五、创建数据库" class="headerlink" title="五、创建数据库"></a>五、创建数据库</h2><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> 数据库名;<br></code></pre></td></tr></table></figure><p>以下命令简单的演示了创建数据库的过程，数据名为 RUNOOB:</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@host]</span><span class="hljs-meta"># mysql -u root -p   </span><br>Enter password:******  <span class="hljs-meta"># 登录后进入终端</span><br><br>mysql&gt; create DATABASE RUNOOB<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="六、删除数据库"><a href="#六、删除数据库" class="headerlink" title="六、删除数据库"></a>六、删除数据库</h2><h3 id="drop-命令删除数据库"><a href="#drop-命令删除数据库" class="headerlink" title="drop 命令删除数据库"></a>drop 命令删除数据库</h3><p>drop 命令格式：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">database</span> &lt;数据库名&gt;;<br></code></pre></td></tr></table></figure><p>例如删除名为 RUNOOB 的数据库：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">mysql&gt; <span class="hljs-keyword">drop</span> <span class="hljs-keyword">database</span> RUNOOB;<br></code></pre></td></tr></table></figure><h3 id="使用-mysqladmin-删除数据库"><a href="#使用-mysqladmin-删除数据库" class="headerlink" title="使用 mysqladmin 删除数据库"></a>使用 mysqladmin 删除数据库</h3><p>你也可以使用 mysql <strong>mysqladmin</strong> 命令在终端来执行删除命令。</p><p>以下实例删除数据库 RUNOOB(该数据库在前一章节已创建)：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@host]</span><span class="hljs-meta"># mysqladmin -u root -p drop RUNOOB</span><br>Enter password:******<br></code></pre></td></tr></table></figure><p>执行以上删除数据库命令后，会出现一个提示框，来确认是否真的删除数据库：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Dropping the <span class="hljs-keyword">database</span> <span class="hljs-keyword">is</span> potentially a very bad thing <span class="hljs-keyword">to</span> <span class="hljs-keyword">do</span>.<br><span class="hljs-keyword">Any</span> data stored <span class="hljs-keyword">in</span> the <span class="hljs-keyword">database</span> will be destroyed.<br><br><span class="hljs-keyword">Do</span> you really want <span class="hljs-keyword">to</span> <span class="hljs-keyword">drop</span> the <span class="hljs-string">&#x27;RUNOOB&#x27;</span> <span class="hljs-keyword">database</span> [y/N] y<br><span class="hljs-keyword">Database</span> &quot;RUNOOB&quot; dropped<br></code></pre></td></tr></table></figure><h2 id="七、选择数据库"><a href="#七、选择数据库" class="headerlink" title="七、选择数据库"></a>七、选择数据库</h2><h3 id="从命令提示窗口中选择MySQL数据库"><a href="#从命令提示窗口中选择MySQL数据库" class="headerlink" title="从命令提示窗口中选择MySQL数据库"></a>从命令提示窗口中选择MySQL数据库</h3><p>在 mysql&gt; 提示窗口中可以很简单的选择特定的数据库。你可以使用SQL命令来选择指定的数据库。</p><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><p>以下实例选取了数据库 RUNOOB:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[root@host]</span># mysql -u root -<span class="hljs-selector-tag">p</span><br>Enter password:******<br>mysql&gt; use RUNOOB;<br>Database changed<br>mysql&gt;<br></code></pre></td></tr></table></figure><p>执行以上命令后，你就已经成功选择了 RUNOOB 数据库，在后续的操作中都会在 RUNOOB 数据库中执行。</p><h2 id="八、数据类型"><a href="#八、数据类型" class="headerlink" title="八、数据类型"></a>八、数据类型</h2><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>MySQL 支持所有标准 SQL 数值数据类型。</p><p>这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL 和 NUMERIC)，以及近似数值数据类型(FLOAT、REAL 和 DOUBLE PRECISION)。</p><p>关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。</p><p>BIT数据类型保存位字段值，并且支持 MyISAM、MEMORY、InnoDB 和 BDB表。</p><p>作为 SQL 标准的扩展，MySQL 也支持整数类型 TINYINT、MEDIUMINT 和 BIGINT。下面的表显示了需要的每个整数类型的存储和范围。</p><table><thead><tr><th align="left">类型</th><th align="left">大小</th><th align="left">范围（有符号）</th><th align="left">范围（无符号）</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">TINYINT</td><td align="left">1 Bytes</td><td align="left">(-128，127)</td><td align="left">(0，255)</td><td align="left">小整数值</td></tr><tr><td align="left">SMALLINT</td><td align="left">2 Bytes</td><td align="left">(-32 768，32 767)</td><td align="left">(0，65 535)</td><td align="left">大整数值</td></tr><tr><td align="left">MEDIUMINT</td><td align="left">3 Bytes</td><td align="left">(-8 388 608，8 388 607)</td><td align="left">(0，16 777 215)</td><td align="left">大整数值</td></tr><tr><td align="left">INT或INTEGER</td><td align="left">4 Bytes</td><td align="left">(-2 147 483 648，2 147 483 647)</td><td align="left">(0，4 294 967 295)</td><td align="left">大整数值</td></tr><tr><td align="left">BIGINT</td><td align="left">8 Bytes</td><td align="left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td align="left">(0，18 446 744 073 709 551 615)</td><td align="left">极大整数值</td></tr><tr><td align="left">FLOAT</td><td align="left">4 Bytes</td><td align="left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td align="left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td align="left">单精度 浮点数值</td></tr><tr><td align="left">DOUBLE</td><td align="left">8 Bytes</td><td align="left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">双精度 浮点数值</td></tr><tr><td align="left">DECIMAL</td><td align="left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td align="left">依赖于M和D的值</td><td align="left">依赖于M和D的值</td><td align="left">小数值</td></tr></tbody></table><hr><h3 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h3><p>表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。</p><p>每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。</p><p>TIMESTAMP类型有专有的自动更新特性，将在后面描述。</p><table><thead><tr><th align="left">类型</th><th align="left">大小 ( bytes)</th><th align="left">范围</th><th align="left">格式</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">DATE</td><td align="left">3</td><td align="left">1000-01-01&#x2F;9999-12-31</td><td align="left">YYYY-MM-DD</td><td align="left">日期值</td></tr><tr><td align="left">TIME</td><td align="left">3</td><td align="left">‘-838:59:59’&#x2F;‘838:59:59’</td><td align="left">HH:MM:SS</td><td align="left">时间值或持续时间</td></tr><tr><td align="left">YEAR</td><td align="left">1</td><td align="left">1901&#x2F;2155</td><td align="left">YYYY</td><td align="left">年份值</td></tr><tr><td align="left">DATETIME</td><td align="left">8</td><td align="left">1000-01-01 00:00:00&#x2F;9999-12-31 23:59:59</td><td align="left">YYYY-MM-DD HH:MM:SS</td><td align="left">混合日期和时间值</td></tr><tr><td align="left">TIMESTAMP</td><td align="left">4</td><td align="left">1970-01-01 00:00:00&#x2F;2038结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td align="left">YYYYMMDD HHMMSS</td><td align="left">混合日期和时间值，时间戳</td></tr></tbody></table><hr><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。</p><table><thead><tr><th align="left">类型</th><th align="left">大小</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">CHAR</td><td align="left">0-255 bytes</td><td align="left">定长字符串</td></tr><tr><td align="left">VARCHAR</td><td align="left">0-65535 bytes</td><td align="left">变长字符串</td></tr><tr><td align="left">TINYBLOB</td><td align="left">0-255 bytes</td><td align="left">不超过 255 个字符的二进制字符串</td></tr><tr><td align="left">TINYTEXT</td><td align="left">0-255 bytes</td><td align="left">短文本字符串</td></tr><tr><td align="left">BLOB</td><td align="left">0-65 535 bytes</td><td align="left">二进制形式的长文本数据</td></tr><tr><td align="left">TEXT</td><td align="left">0-65 535 bytes</td><td align="left">长文本数据</td></tr><tr><td align="left">MEDIUMBLOB</td><td align="left">0-16 777 215 bytes</td><td align="left">二进制形式的中等长度文本数据</td></tr><tr><td align="left">MEDIUMTEXT</td><td align="left">0-16 777 215 bytes</td><td align="left">中等长度文本数据</td></tr><tr><td align="left">LONGBLOB</td><td align="left">0-4 294 967 295 bytes</td><td align="left">二进制形式的极大文本数据</td></tr><tr><td align="left">LONGTEXT</td><td align="left">0-4 294 967 295 bytes</td><td align="left">极大文本数据</td></tr></tbody></table><p><strong>注意</strong>：char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。</p><p>CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p><p>BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。</p><p>BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。</p><p>有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。</p><h2 id="九、创建数据表"><a href="#九、创建数据表" class="headerlink" title="九、创建数据表"></a>九、创建数据表</h2><p>创建MySQL数据表需要以下信息：</p><ul><li>表名</li><li>表字段名</li><li>定义每个表字段</li></ul><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p>以下为创建MySQL数据表的SQL通用语法：</p><p><code>CREATE TABLE table_name(column_name column_type):</code></p><p>以下例子中我们将在RUNOOB数据库中创建数据表runoob_tbl:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE IF NOT EXISTS `runoob_tbl`(<br>   `runoob_id` INT UNSIGNED AUTO_INCREMENT,<br>   `runoob_title` VARCHAR(100) NOT NULL,<br>   `runoob_author` VARCHAR(40) NOT NULL,<br>   `submission_date` DATE,<br>   PRIMARY KEY ( `runoob_id` )<br>)ENGINE=InnoDB DEFAULT CHARSET=utf8;<br></code></pre></td></tr></table></figure><p>实例解析：</p><ul><li>如果你不想字段为NULL可以设置字段的属性为NOT NULL，在操作数据库时如果输入该字段的数据为NULL，就会报错；</li><li>AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动+1；</li><li>PRIMARY KEY关键字用于定义为主键。您可以使用多列来定义主键，列间以逗号分隔。</li><li>ENGINE设置存储引擎，CHARSET设置编码。</li></ul><h3 id="通过命令提示符创建表"><a href="#通过命令提示符创建表" class="headerlink" title="通过命令提示符创建表"></a>通过命令提示符创建表</h3><p>通过 mysql&gt; 命令窗口可以很简单的创建MySQL数据表。你可以使用 SQL 语句 <strong>CREATE TABLE</strong> 来创建数据表。</p><h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><p>以下为创建数据表 runoob_tbl 实例:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">root@host# mysql -u root -p<br>Enter <span class="hljs-keyword">password</span>:*******<br>mysql&gt; use RUNOOB;<br><span class="hljs-keyword">Database</span> changed<br>mysql&gt; <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> runoob_tbl(<br>   -&gt; runoob_id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>   -&gt; runoob_title <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   -&gt; runoob_author <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">40</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   -&gt; submission_date <span class="hljs-type">DATE</span>,<br>   -&gt; <span class="hljs-keyword">PRIMARY KEY</span> ( runoob_id )<br>   -&gt; )ENGINE=InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.16</span> sec)<br>mysql&gt;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>MySQL命令终止符为分号 <strong>;</strong> 。</p><p><strong>注意：</strong> <strong>-&gt;</strong> 是换行符标识，不要复制</p><h2 id="十、删除数据表"><a href="#十、删除数据表" class="headerlink" title="十、删除数据表"></a>十、删除数据表</h2><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><p>以下为删除MySQL数据表的通用语法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-built_in">table_name</span> ;<br></code></pre></td></tr></table></figure><h2 id="在命令提示窗口中删除数据表"><a href="#在命令提示窗口中删除数据表" class="headerlink" title="在命令提示窗口中删除数据表"></a>在命令提示窗口中删除数据表</h2><p>在mysql&gt;命令提示窗口中删除数据表SQL语句为 <strong>DROP TABLE</strong> ：</p><h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><p>以下实例删除了数据表runoob_tbl:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">root@host# mysql -u root -p<br>Enter password:*******<br>mysql&gt; use RUNOOB;<br>Database changed<br>mysql&gt; DROP TABLE runoob_tbl;<br>Query OK, 0 rows affected (0.8 sec)<br>mysql&gt;<br></code></pre></td></tr></table></figure><h2 id="十一、插入数据"><a href="#十一、插入数据" class="headerlink" title="十一、插入数据"></a>十一、插入数据</h2><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><p>以下为向MySQL数据表插入数据通用的 <strong>INSERT INTO</strong> SQL语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INFO table_name (field1,field2,...fieldN)<br>VALUES<br>(value1, value2,...valueN);<br></code></pre></td></tr></table></figure><h3 id="通过命令提示窗口插入数据"><a href="#通过命令提示窗口插入数据" class="headerlink" title="通过命令提示窗口插入数据"></a>通过命令提示窗口插入数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mysql">root@host# mysql -u root -p password;<br>Enter password:*******<br>mysql&gt; use RUNOOB;<br>Database changed<br>mysql&gt; Query OK, 1 rows affected, 1 warnings (0.01 sec)<br>mysql&gt; INSERT INTO runoob_tbl<br>    -&gt; (runoob_title, runoob_author, submission_date)<br>    -&gt; VALUES<br>    -&gt; (&quot;学习 PHP&quot;, &quot;菜鸟教程&quot;, NOW());<br>Query OK, 1 rows affected, 1 warnings (0.01 sec)<br>mysql&gt; INSERT INTO runoob_tbl<br>    -&gt; (runoob_title, runoob_author, submission_date)<br>    -&gt; VALUES<br>    -&gt; (&quot;学习 MySQL&quot;, &quot;菜鸟教程&quot;, NOW());<br>Query OK, 1 rows affected, 1 warnings (0.01 sec)<br>mysql&gt; INSERT INTO runoob_tbl<br>    -&gt; (runoob_title, runoob_author, submission_date)<br>    -&gt; VALUES<br>    -&gt; (&quot;JAVA 教程&quot;, &quot;RUNOOB.COM&quot;, &#x27;2016-05-06&#x27;);<br>Query OK, 1 rows affected (0.00 sec)<br>mysql&gt;<br></code></pre></td></tr></table></figure><h2 id="十二、查询数据"><a href="#十二、查询数据" class="headerlink" title="十二、查询数据"></a>十二、查询数据</h2><p>MySQL 数据库使用SQL SELECT语句来查询数据。</p><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><p>以下为在MySQL数据库中查询数据通用的 SELECT 语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column_name,column_name<br>FROM table_name<br>[WHERE Clause]<br>[LIMIT N][ OFFSET M]<br></code></pre></td></tr></table></figure><ul><li><p>查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。</p></li><li><p>SELECT 命令可以读取一条或者多条记录。</p></li><li><p>你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据</p></li><li><p>你可以使用 WHERE 语句来包含任何条件。</p></li><li><p>你可以使用 LIMIT 属性来设定返回的记录数。</p></li><li><p>你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。通过命令提示符获取数据</p><p>以下实例我们将通过 SQL SELECT 命令来获取 MySQL 数据表 runoob_tbl 的数据：</p></li></ul><h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><p>  以下实例将返回数据表 runoob_tbl 的所有记录:</p><h3 id="读取数据表："><a href="#读取数据表：" class="headerlink" title="读取数据表："></a>读取数据表：</h3><p>  <code>select * from runoob_tbl;</code></p><p>  输出结果：</p><p>  <img src="https://www.runoob.com/wp-content/uploads/2014/03/DB742246-84F3-4447-BD43-6BAEADD7CA91.jpg" alt="img"></p><h2 id="十三、MySQL-WHERE字句"><a href="#十三、MySQL-WHERE字句" class="headerlink" title="十三、MySQL WHERE字句"></a>十三、MySQL WHERE字句</h2><p>我们知道从 MySQL 表中使用 SQL SELECT 语句来读取数据。</p><p>如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句中。</p><h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><p>以下是 SQL SELECT 语句使用 WHERE 子句从数据表中读取数据的通用语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT field1, field2,...fieldN FROM table_name1, table_name2...<br>[WHERE condition1 [AND [OR]] condition2.....<br></code></pre></td></tr></table></figure><ul><li>查询语句中你可以使用一个或者多个表，表之间使用逗号**,** 分割，并使用WHERE语句来设定查询条件。</li><li>你可以在 WHERE 子句中指定任何条件。</li><li>你可以使用 AND 或者 OR 指定一个或多个条件。</li><li>WHERE 子句也可以运用于 SQL 的 DELETE 或者 UPDATE 命令。</li><li>WHERE 子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。</li></ul><p>以下为操作符列表，可用于 WHERE 子句中。</p><p>下表中实例假定 A 为 10, B 为 20</p><table><thead><tr><th align="left">操作符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&#x3D;</td><td align="left">等号，检测两个值是否相等，如果相等返回true</td><td align="left">(A &#x3D; B) 返回false。</td></tr><tr><td align="left">&lt;&gt;, !&#x3D;</td><td align="left">不等于，检测两个值是否相等，如果不相等返回true</td><td align="left">(A !&#x3D; B) 返回 true。</td></tr><tr><td align="left">&gt;</td><td align="left">大于号，检测左边的值是否大于右边的值, 如果左边的值大于右边的值返回true</td><td align="left">(A &gt; B) 返回false。</td></tr><tr><td align="left">&lt;</td><td align="left">小于号，检测左边的值是否小于右边的值, 如果左边的值小于右边的值返回true</td><td align="left">(A &lt; B) 返回 true。</td></tr><tr><td align="left">&gt;&#x3D;</td><td align="left">大于等于号，检测左边的值是否大于或等于右边的值, 如果左边的值大于或等于右边的值返回true</td><td align="left">(A &gt;&#x3D; B) 返回false。</td></tr><tr><td align="left">&lt;&#x3D;</td><td align="left">小于等于号，检测左边的值是否小于或等于右边的值, 如果左边的值小于或等于右边的值返回true</td><td align="left">(A &lt;&#x3D; B) 返回 true。</td></tr></tbody></table><p>如果我们想在 MySQL 数据表中读取指定的数据，WHERE 子句是非常有用的。</p><p>使用主键来作为 WHERE 子句的条件查询是非常快速的。</p><p>如果给定的条件在表中没有任何匹配的记录，那么查询不会返回任何数据。</p><h3 id="从命令提示符中读取数据"><a href="#从命令提示符中读取数据" class="headerlink" title="从命令提示符中读取数据"></a>从命令提示符中读取数据</h3><p>我们将在SQL SELECT语句使用WHERE子句来读取MySQL数据表 runoob_tbl 中的数据：</p><p>实例</p><p>以下实例将读取 runoob_tbl 表中 runoob_author 字段值为 Sanjay 的所有记录：</p><h3 id="SQL-SELECT-WHERE-子句"><a href="#SQL-SELECT-WHERE-子句" class="headerlink" title="SQL SELECT WHERE 子句"></a>SQL SELECT WHERE 子句</h3><p>SELECT * from runoob_tbl WHERE runoob_author&#x3D;’菜鸟教程’;</p><p>输出结果：</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/03/CED9CA9C-E4C7-4809-875C-A7E48F430059.jpg" alt="img"></p><p>MySQL 的 WHERE 子句的字符串比较是不区分大小写的。 你可以使用 BINARY 关键字来设定 WHERE 子句的字符串比较是区分大小写的。</p><p>如下实例:</p><h3 id="BINARY-关键字"><a href="#BINARY-关键字" class="headerlink" title="BINARY 关键字"></a>BINARY 关键字</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * from runoob_tbl WHERE BINARY runoob_author=&#x27;runoob.com&#x27;;<br>Empty set (0.01 sec)<br> <br>mysql&gt; SELECT * from runoob_tbl WHERE BINARY runoob_author=&#x27;RUNOOB.COM&#x27;;<br>+-----------+---------------+---------------+-----------------+<br>| runoob_id | runoob_title  | runoob_author | submission_date |<br>+-----------+---------------+---------------+-----------------+<br>| 3         | JAVA 教程   | RUNOOB.COM    | 2016-05-06      |<br>| 4         | 学习 Python | RUNOOB.COM    | 2016-03-06      |<br>+-----------+---------------+---------------+-----------------+<br>2 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure><p>实例中使用了 <strong>BINARY</strong> 关键字，是区分大小写的，所以 <strong>runoob_author&#x3D;’runoob.com’</strong> 的查询条件是没有数据的。</p><h2 id="十四、MySQL-UPDATE更新"><a href="#十四、MySQL-UPDATE更新" class="headerlink" title="十四、MySQL UPDATE更新"></a>十四、MySQL UPDATE更新</h2><p>如果我们需要修改或更新 MySQL 中的数据，我们可以使用 SQL UPDATE 命令来操作。</p><h3 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h3><p>以下是UPDATE命令修改MySQL数据表数据通用的SQL语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE table_name SET field1=new-value1, field2=new-value2<br>[WHERE Clause]<br></code></pre></td></tr></table></figure><ul><li>你可以同时更新一个或多个字段。</li><li>你可以在 WHERE 子句中指定任何条件。</li><li>你可以在一个单独表中同时更新数据。</li></ul><p>当你需要更新数据表中指定行的数据时 WHERE 子句是非常有用的。</p><p>通过命令提示符更新数据</p><p>以下我们将在 SQL UPDATE 命令使用 WHERE 子句来更新 runoob_tbl 表中指定的数据：</p><h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><p>以下实例将更新数据表中 runoob_id 为 3 的 runoob_title 字段值：</p><h3 id="SQL-UPDATE-语句："><a href="#SQL-UPDATE-语句：" class="headerlink" title="SQL UPDATE 语句："></a>SQL UPDATE 语句：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; UPDATE runoob_tbl SET runoob_title=&#x27;学习 C++&#x27; WHERE runoob_id=3;<br>Query OK, 1 rows affected (0.01 sec)<br> <br>mysql&gt; SELECT * from runoob_tbl WHERE runoob_id=3;<br>+-----------+--------------+---------------+-----------------+<br>| runoob_id | runoob_title | runoob_author | submission_date |<br>+-----------+--------------+---------------+-----------------+<br>| 3         | 学习 C++   | RUNOOB.COM    | 2016-05-06      |<br>+-----------+--------------+---------------+-----------------+<br>1 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure><p>从结果上看，runoob_id 为 3 的 runoob_title 已被修改</p><h2 id="十五、DELETE语句"><a href="#十五、DELETE语句" class="headerlink" title="十五、DELETE语句"></a>十五、DELETE语句</h2><p>你可以使用 SQL 的 DELETE FROM 命令来删除 MySQL 数据表中的记录。</p><p>你可以在 <strong>mysql&gt;</strong> 命令提示符或 PHP 脚本中执行该命令。</p><h3 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h3><p>以下是SQL DELETE语句从MySQL数据表中删除数据的通用语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM table_name [WHERE Clause]<br></code></pre></td></tr></table></figure><ul><li>如果没有指定 WHERE 子句，MySQL 表中的所有记录将被删除。</li><li>你可以在 WHERE 子句中指定任何条件</li><li>您可以在单个表中一次性删除记录。</li></ul><p>当你想删除数据表中指定的记录时 WHERE 子句是非常有用的。</p><h3 id="从命令行中删除数据"><a href="#从命令行中删除数据" class="headerlink" title="从命令行中删除数据"></a>从命令行中删除数据</h3><p>这里我们将在 SQL DELETE 命令中使用 WHERE 子句来删除 MySQL 数据表 runoob_tbl 所选的数据。</p><h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><p>以下实例将删除 runoob_tbl 表中 runoob_id 为3 的记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; use RUNOOB;<br>Database changed<br>mysql&gt; DELETE FROM runoob_tbl WHERE runoob_id=3;<br>Query OK, 1 row affected (0.23 sec)<br><br></code></pre></td></tr></table></figure><h2 id="十六、LIKE字句"><a href="#十六、LIKE字句" class="headerlink" title="十六、LIKE字句"></a>十六、LIKE字句</h2><p>我们知道在 MySQL 中使用 SQL SELECT 命令来读取数据， 同时我们可以在 SELECT 语句中使用 WHERE 子句来获取指定的记录。</p><p>WHERE 子句中可以使用等号 <strong>&#x3D;</strong> 来设定获取数据的条件，如 “runoob_author &#x3D; ‘RUNOOB.COM’”。</p><p>但是有时候我们需要获取 runoob_author 字段含有&#x3D;&#x3D;”COM”&#x3D;&#x3D; 字符的所有记录，这时我们就需要在 WHERE 子句中使用 SQL LIKE 子句。</p><p>SQL LIKE 子句中使用百分号 **%**字符来表示任意字符，类似于UNIX或正则表达式中的星号 *****。</p><p>如果没有使用百分号 <strong>%</strong>, LIKE 子句与等号 <strong>&#x3D;</strong> 的效果是一样的。</p><h3 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h3><p>以下是 SQL SELECT 语句使用 LIKE 子句从数据表中读取数据的通用语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT field1, field2,...fieldN <br>FROM table_name<br>WHERE field1 LIKE condition1 [AND [OR]] filed2 = &#x27;somevalue&#x27;<br></code></pre></td></tr></table></figure><ul><li><p>你可以在 WHERE 子句中指定任何条件。</p></li><li><p>你可以在 WHERE 子句中使用LIKE子句。</p></li><li><p>你可以使用&#x3D;&#x3D;LIKE子句代替等号 **&#x3D;**。&#x3D;&#x3D;</p></li><li><p>LIKE 通常与 <strong>%</strong> 一同使用，类似于一个元字符的搜索。</p></li><li><p>你可以使用 AND 或者 OR 指定一个或多个条件。</p></li><li><p>你可以在 DELETE 或 UPDATE 命令中使用 WHERE…LIKE 子句来指定条件。</p></li></ul><h3 id="在命令提示符中使用-LIKE-子句"><a href="#在命令提示符中使用-LIKE-子句" class="headerlink" title="在命令提示符中使用 LIKE 子句"></a>在命令提示符中使用 LIKE 子句</h3><p>  以下我们将在 SQL SELECT 命令中使用 WHERE…LIKE 子句来从MySQL数据表 runoob_tbl 中读取数据。</p><p>  实例</p><p>  以下是我们将 runoob_tbl 表中获取 runoob_author 字段中以 <strong>COM</strong> 为结尾的的所有记录：</p><h3 id="SQL-LIKE-语句："><a href="#SQL-LIKE-语句：" class="headerlink" title="SQL LIKE 语句："></a>SQL LIKE 语句：</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; use RUNOOB;<br>Database changed<br>mysql&gt; SELECT * from runoob_tbl  WHERE runoob_author LIKE &#x27;%COM&#x27;;<br>+-----------+---------------+---------------+-----------------+<br>| runoob_id | runoob_title  | runoob_author | submission_date |<br>+-----------+---------------+---------------+-----------------+<br>| 3         | 学习 Java   | RUNOOB.COM    | 2015-05-01      |<br>| 4         | 学习 Python | RUNOOB.COM    | 2016-03-06      |<br>+-----------+---------------+---------------+-----------------+<br>2 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure><h2 id="十七、UNION操作符"><a href="#十七、UNION操作符" class="headerlink" title="十七、UNION操作符"></a>十七、UNION操作符</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>MySQL UNION 操作符用于连接&#x3D;&#x3D;两个以上的 SELECT 语句&#x3D;&#x3D;的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。</p><h3 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h3><p>MySQL UNION 操作符语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT expression1, expression2, ... expression_n<br>FROM tables<br>[WHERE conditions]<br>UNION [ALL | DISTINCT]<br>SELECT expression1, expression2, ... expression_n<br>FROM tables<br>[WHERE conditions];<br></code></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><strong>expression1, expression2, … expression_n</strong>: 要检索的列。</li><li><strong>tables:</strong> 要检索的数据表。</li><li><strong>WHERE conditions:</strong> 可选， 检索条件。</li><li><strong>DISTINCT:</strong> 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。</li><li><strong>ALL:</strong> 可选，返回所有结果集，包含重复数据。</li></ul><h3 id="演示数据库"><a href="#演示数据库" class="headerlink" title="演示数据库"></a>演示数据库</h3><p>在本教程中，我们将使用 RUNOOB 样本数据库。</p><p>下面是选自 “Websites” 表的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM Websites;<br>+----+--------------+---------------------------+-------+---------+<br>| id | name         | url                       | alexa | country |<br>+----+--------------+---------------------------+-------+---------+<br>| 1  | Google       | https://www.google.cm/    | 1     | USA     |<br>| 2  | 淘宝          | https://www.taobao.com/   | 13    | CN      |<br>| 3  | 菜鸟教程      | http://www.runoob.com/    | 4689  | CN      |<br>| 4  | 微博          | http://weibo.com/         | 20    | CN      |<br>| 5  | Facebook     | https://www.facebook.com/ | 3     | USA     |<br>| 7  | stackoverflow | http://stackoverflow.com/ |   0 | IND     |<br>+----+---------------+---------------------------+-------+---------+<br></code></pre></td></tr></table></figure><p>下面是 “apps” APP 的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM apps;<br>+----+------------+-------------------------+---------+<br>| id | app_name   | url                     | country |<br>+----+------------+-------------------------+---------+<br>|  1 | QQ APP     | http://im.qq.com/       | CN      |<br>|  2 | 微博 APP | http://weibo.com/       | CN      |<br>|  3 | 淘宝 APP | https://www.taobao.com/ | CN      |<br>+----+------------+-------------------------+---------+<br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="SQL-UNION-实例"><a href="#SQL-UNION-实例" class="headerlink" title="SQL UNION 实例"></a>SQL UNION 实例</h3><p>下面的 SQL 语句从 “Websites” 和 “apps” 表中选取所有<strong>不同的</strong>country（只有不同的值）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT country FROM Websites<br>UNION<br>SELECT country FROM apps<br>ORDER BY country;<br></code></pre></td></tr></table></figure><p>执行以上 SQL 输出结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2013/09/union1.jpg" alt="img"></p><p><strong>注释：</strong>UNION 不能用于列出两个表中所有的country。如果一些网站和APP来自同一个国家，每个国家只会列出一次。UNION 只会选取不同的值。请使用 UNION ALL 来选取重复的值！</p><h3 id="SQL-UNION-ALL-实例"><a href="#SQL-UNION-ALL-实例" class="headerlink" title="SQL UNION ALL 实例"></a>SQL UNION ALL 实例</h3><p>下面的 SQL 语句使用 UNION ALL 从 “Websites” 和 “apps” 表中选取<strong>所有的</strong>country（也有重复的值）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT country FROM Websites<br>UNION ALL<br>SELECT country FROM apps<br>ORDER BY country;<br></code></pre></td></tr></table></figure><p>执行以上 SQL 输出结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2013/09/union2.jpg" alt="img"></p><h3 id="带有-WHERE-的-SQL-UNION-ALL"><a href="#带有-WHERE-的-SQL-UNION-ALL" class="headerlink" title="带有 WHERE 的 SQL UNION ALL"></a>带有 WHERE 的 SQL UNION ALL</h3><p>下面的 SQL 语句使用 UNION ALL 从 “Websites” 和 “apps” 表中选取<strong>所有的</strong>中国(CN)的数据（也有重复的值）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT country, name FROM Websites<br>WHERE country=&#x27;CN&#x27;<br>UNION ALL<br>SELECT country, app_name FROM apps<br>WHERE country=&#x27;CN&#x27;<br>ORDER BY country;<br></code></pre></td></tr></table></figure><p>执行以上 SQL 输出结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2013/09/AAA99C7B-36A5-43FB-B489-F8CE63B62C71.jpg" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
